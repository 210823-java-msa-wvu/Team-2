<<<<<<< HEAD
{"version":3,"file":"forms.d.ts","sources":["forms.d.ts"],"names":[],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA;AACA;AACA;AACA;AACA","sourcesContent":["/**\r\n * @license Angular v12.2.10\r\n * (c) 2010-2021 Google LLC. https://angular.io/\r\n * License: MIT\r\n */\r\n\r\nimport { AfterViewInit } from '@angular/core';\r\nimport { ElementRef } from '@angular/core';\r\nimport { EventEmitter } from '@angular/core';\r\nimport { InjectionToken } from '@angular/core';\r\nimport { Injector } from '@angular/core';\r\nimport { ModuleWithProviders } from '@angular/core';\r\nimport { Observable } from 'rxjs';\r\nimport { OnChanges } from '@angular/core';\r\nimport { OnDestroy } from '@angular/core';\r\nimport { OnInit } from '@angular/core';\r\nimport { Renderer2 } from '@angular/core';\r\nimport { SimpleChanges } from '@angular/core';\r\nimport { StaticProvider } from '@angular/core';\r\nimport { Type } from '@angular/core';\r\nimport { Version } from '@angular/core';\r\n\r\n/**\r\n * This is the base class for `FormControl`, `FormGroup`, and `FormArray`.\r\n *\r\n * It provides some of the shared behavior that all controls and groups of controls have, like\r\n * running validators, calculating status, and resetting state. It also defines the properties\r\n * that are shared between all sub-classes, like `value`, `valid`, and `dirty`. It shouldn't be\r\n * instantiated directly.\r\n *\r\n * @see [Forms Guide](/guide/forms)\r\n * @see [Reactive Forms Guide](/guide/reactive-forms)\r\n * @see [Dynamic Forms Guide](/guide/dynamic-form)\r\n *\r\n * @publicApi\r\n */\r\nexport declare abstract class AbstractControl {\r\n    private _parent;\r\n    private _asyncValidationSubscription;\r\n    /**\r\n     * The current value of the control.\r\n     *\r\n     * * For a `FormControl`, the current value.\r\n     * * For an enabled `FormGroup`, the values of enabled controls as an object\r\n     * with a key-value pair for each member of the group.\r\n     * * For a disabled `FormGroup`, the values of all controls as an object\r\n     * with a key-value pair for each member of the group.\r\n     * * For a `FormArray`, the values of enabled controls as an array.\r\n     *\r\n     */\r\n    readonly value: any;\r\n    /**\r\n     * Initialize the AbstractControl instance.\r\n     *\r\n     * @param validators The function or array of functions that is used to determine the validity of\r\n     *     this control synchronously.\r\n     * @param asyncValidators The function or array of functions that is used to determine validity of\r\n     *     this control asynchronously.\r\n     */\r\n    constructor(validators: ValidatorFn | ValidatorFn[] | null, asyncValidators: AsyncValidatorFn | AsyncValidatorFn[] | null);\r\n    /**\r\n     * Returns the function that is used to determine the validity of this control synchronously.\r\n     * If multiple validators have been added, this will be a single composed function.\r\n     * See `Validators.compose()` for additional information.\r\n     */\r\n    get validator(): ValidatorFn | null;\r\n    set validator(validatorFn: ValidatorFn | null);\r\n    /**\r\n     * Returns the function that is used to determine the validity of this control asynchronously.\r\n     * If multiple validators have been added, this will be a single composed function.\r\n     * See `Validators.compose()` for additional information.\r\n     */\r\n    get asyncValidator(): AsyncValidatorFn | null;\r\n    set asyncValidator(asyncValidatorFn: AsyncValidatorFn | null);\r\n    /**\r\n     * The parent control.\r\n     */\r\n    get parent(): FormGroup | FormArray | null;\r\n    /**\r\n     * The validation status of the control. There are four possible\r\n     * validation status values:\r\n     *\r\n     * * **VALID**: This control has passed all validation checks.\r\n     * * **INVALID**: This control has failed at least one validation check.\r\n     * * **PENDING**: This control is in the midst of conducting a validation check.\r\n     * * **DISABLED**: This control is exempt from validation checks.\r\n     *\r\n     * These status values are mutually exclusive, so a control cannot be\r\n     * both valid AND invalid or invalid AND disabled.\r\n     */\r\n    readonly status: string;\r\n    /**\r\n     * A control is `valid` when its `status` is `VALID`.\r\n     *\r\n     * @see {@link AbstractControl.status}\r\n     *\r\n     * @returns True if the control has passed all of its validation tests,\r\n     * false otherwise.\r\n     */\r\n    get valid(): boolean;\r\n    /**\r\n     * A control is `invalid` when its `status` is `INVALID`.\r\n     *\r\n     * @see {@link AbstractControl.status}\r\n     *\r\n     * @returns True if this control has failed one or more of its validation checks,\r\n     * false otherwise.\r\n     */\r\n    get invalid(): boolean;\r\n    /**\r\n     * A control is `pending` when its `status` is `PENDING`.\r\n     *\r\n     * @see {@link AbstractControl.status}\r\n     *\r\n     * @returns True if this control is in the process of conducting a validation check,\r\n     * false otherwise.\r\n     */\r\n    get pending(): boolean;\r\n    /**\r\n     * A control is `disabled` when its `status` is `DISABLED`.\r\n     *\r\n     * Disabled controls are exempt from validation checks and\r\n     * are not included in the aggregate value of their ancestor\r\n     * controls.\r\n     *\r\n     * @see {@link AbstractControl.status}\r\n     *\r\n     * @returns True if the control is disabled, false otherwise.\r\n     */\r\n    get disabled(): boolean;\r\n    /**\r\n     * A control is `enabled` as long as its `status` is not `DISABLED`.\r\n     *\r\n     * @returns True if the control has any status other than 'DISABLED',\r\n     * false if the status is 'DISABLED'.\r\n     *\r\n     * @see {@link AbstractControl.status}\r\n     *\r\n     */\r\n    get enabled(): boolean;\r\n    /**\r\n     * An object containing any errors generated by failing validation,\r\n     * or null if there are no errors.\r\n     */\r\n    readonly errors: ValidationErrors | null;\r\n    /**\r\n     * A control is `pristine` if the user has not yet changed\r\n     * the value in the UI.\r\n     *\r\n     * @returns True if the user has not yet changed the value in the UI; compare `dirty`.\r\n     * Programmatic changes to a control's value do not mark it dirty.\r\n     */\r\n    readonly pristine: boolean;\r\n    /**\r\n     * A control is `dirty` if the user has changed the value\r\n     * in the UI.\r\n     *\r\n     * @returns True if the user has changed the value of this control in the UI; compare `pristine`.\r\n     * Programmatic changes to a control's value do not mark it dirty.\r\n     */\r\n    get dirty(): boolean;\r\n    /**\r\n     * True if the control is marked as `touched`.\r\n     *\r\n     * A control is marked `touched` once the user has triggered\r\n     * a `blur` event on it.\r\n     */\r\n    readonly touched: boolean;\r\n    /**\r\n     * True if the control has not been marked as touched\r\n     *\r\n     * A control is `untouched` if the user has not yet triggered\r\n     * a `blur` event on it.\r\n     */\r\n    get untouched(): boolean;\r\n    /**\r\n     * A multicasting observable that emits an event every time the value of the control changes, in\r\n     * the UI or programmatically. It also emits an event each time you call enable() or disable()\r\n     * without passing along {emitEvent: false} as a function argument.\r\n     */\r\n    readonly valueChanges: Observable<any>;\r\n    /**\r\n     * A multicasting observable that emits an event every time the validation `status` of the control\r\n     * recalculates.\r\n     *\r\n     * @see {@link AbstractControl.status}\r\n     *\r\n     */\r\n    readonly statusChanges: Observable<any>;\r\n    /**\r\n     * Reports the update strategy of the `AbstractControl` (meaning\r\n     * the event on which the control updates itself).\r\n     * Possible values: `'change'` | `'blur'` | `'submit'`\r\n     * Default value: `'change'`\r\n     */\r\n    get updateOn(): FormHooks;\r\n    /**\r\n     * Sets the synchronous validators that are active on this control.  Calling\r\n     * this overwrites any existing synchronous validators.\r\n     *\r\n     * When you add or remove a validator at run time, you must call\r\n     * `updateValueAndValidity()` for the new validation to take effect.\r\n     *\r\n     * If you want to add a new validator without affecting existing ones, consider\r\n     * using `addValidators()` method instead.\r\n     */\r\n    setValidators(validators: ValidatorFn | ValidatorFn[] | null): void;\r\n    /**\r\n     * Sets the asynchronous validators that are active on this control. Calling this\r\n     * overwrites any existing asynchronous validators.\r\n     *\r\n     * When you add or remove a validator at run time, you must call\r\n     * `updateValueAndValidity()` for the new validation to take effect.\r\n     *\r\n     * If you want to add a new validator without affecting existing ones, consider\r\n     * using `addAsyncValidators()` method instead.\r\n     */\r\n    setAsyncValidators(validators: AsyncValidatorFn | AsyncValidatorFn[] | null): void;\r\n    /**\r\n     * Add a synchronous validator or validators to this control, without affecting other validators.\r\n     *\r\n     * When you add or remove a validator at run time, you must call\r\n     * `updateValueAndValidity()` for the new validation to take effect.\r\n     *\r\n     * Adding a validator that already exists will have no effect. If duplicate validator functions\r\n     * are present in the `validators` array, only the first instance would be added to a form\r\n     * control.\r\n     *\r\n     * @param validators The new validator function or functions to add to this control.\r\n     */\r\n    addValidators(validators: ValidatorFn | ValidatorFn[]): void;\r\n    /**\r\n     * Add an asynchronous validator or validators to this control, without affecting other\r\n     * validators.\r\n     *\r\n     * When you add or remove a validator at run time, you must call\r\n     * `updateValueAndValidity()` for the new validation to take effect.\r\n     *\r\n     * Adding a validator that already exists will have no effect.\r\n     *\r\n     * @param validators The new asynchronous validator function or functions to add to this control.\r\n     */\r\n    addAsyncValidators(validators: AsyncValidatorFn | AsyncValidatorFn[]): void;\r\n    /**\r\n     * Remove a synchronous validator from this control, without affecting other validators.\r\n     * Validators are compared by function reference; you must pass a reference to the exact same\r\n     * validator function as the one that was originally set. If a provided validator is not found,\r\n     * it is ignored.\r\n     *\r\n     * When you add or remove a validator at run time, you must call\r\n     * `updateValueAndValidity()` for the new validation to take effect.\r\n     *\r\n     * @param validators The validator or validators to remove.\r\n     */\r\n    removeValidators(validators: ValidatorFn | ValidatorFn[]): void;\r\n    /**\r\n     * Remove an asynchronous validator from this control, without affecting other validators.\r\n     * Validators are compared by function reference; you must pass a reference to the exact same\r\n     * validator function as the one that was originally set. If a provided validator is not found, it\r\n     * is ignored.\r\n     *\r\n     * When you add or remove a validator at run time, you must call\r\n     * `updateValueAndValidity()` for the new validation to take effect.\r\n     *\r\n     * @param validators The asynchronous validator or validators to remove.\r\n     */\r\n    removeAsyncValidators(validators: AsyncValidatorFn | AsyncValidatorFn[]): void;\r\n    /**\r\n     * Check whether a synchronous validator function is present on this control. The provided\r\n     * validator must be a reference to the exact same function that was provided.\r\n     *\r\n     * @param validator The validator to check for presence. Compared by function reference.\r\n     * @returns Whether the provided validator was found on this control.\r\n     */\r\n    hasValidator(validator: ValidatorFn): boolean;\r\n    /**\r\n     * Check whether an asynchronous validator function is present on this control. The provided\r\n     * validator must be a reference to the exact same function that was provided.\r\n     *\r\n     * @param validator The asynchronous validator to check for presence. Compared by function\r\n     *     reference.\r\n     * @returns Whether the provided asynchronous validator was found on this control.\r\n     */\r\n    hasAsyncValidator(validator: AsyncValidatorFn): boolean;\r\n    /**\r\n     * Empties out the synchronous validator list.\r\n     *\r\n     * When you add or remove a validator at run time, you must call\r\n     * `updateValueAndValidity()` for the new validation to take effect.\r\n     *\r\n     */\r\n    clearValidators(): void;\r\n    /**\r\n     * Empties out the async validator list.\r\n     *\r\n     * When you add or remove a validator at run time, you must call\r\n     * `updateValueAndValidity()` for the new validation to take effect.\r\n     *\r\n     */\r\n    clearAsyncValidators(): void;\r\n    /**\r\n     * Marks the control as `touched`. A control is touched by focus and\r\n     * blur events that do not change the value.\r\n     *\r\n     * @see `markAsUntouched()`\r\n     * @see `markAsDirty()`\r\n     * @see `markAsPristine()`\r\n     *\r\n     * @param opts Configuration options that determine how the control propagates changes\r\n     * and emits events after marking is applied.\r\n     * * `onlySelf`: When true, mark only this control. When false or not supplied,\r\n     * marks all direct ancestors. Default is false.\r\n     */\r\n    markAsTouched(opts?: {\r\n        onlySelf?: boolean;\r\n    }): void;\r\n    /**\r\n     * Marks the control and all its descendant controls as `touched`.\r\n     * @see `markAsTouched()`\r\n     */\r\n    markAllAsTouched(): void;\r\n    /**\r\n     * Marks the control as `untouched`.\r\n     *\r\n     * If the control has any children, also marks all children as `untouched`\r\n     * and recalculates the `touched` status of all parent controls.\r\n     *\r\n     * @see `markAsTouched()`\r\n     * @see `markAsDirty()`\r\n     * @see `markAsPristine()`\r\n     *\r\n     * @param opts Configuration options that determine how the control propagates changes\r\n     * and emits events after the marking is applied.\r\n     * * `onlySelf`: When true, mark only this control. When false or not supplied,\r\n     * marks all direct ancestors. Default is false.\r\n     */\r\n    markAsUntouched(opts?: {\r\n        onlySelf?: boolean;\r\n    }): void;\r\n    /**\r\n     * Marks the control as `dirty`. A control becomes dirty when\r\n     * the control's value is changed through the UI; compare `markAsTouched`.\r\n     *\r\n     * @see `markAsTouched()`\r\n     * @see `markAsUntouched()`\r\n     * @see `markAsPristine()`\r\n     *\r\n     * @param opts Configuration options that determine how the control propagates changes\r\n     * and emits events after marking is applied.\r\n     * * `onlySelf`: When true, mark only this control. When false or not supplied,\r\n     * marks all direct ancestors. Default is false.\r\n     */\r\n    markAsDirty(opts?: {\r\n        onlySelf?: boolean;\r\n    }): void;\r\n    /**\r\n     * Marks the control as `pristine`.\r\n     *\r\n     * If the control has any children, marks all children as `pristine`,\r\n     * and recalculates the `pristine` status of all parent\r\n     * controls.\r\n     *\r\n     * @see `markAsTouched()`\r\n     * @see `markAsUntouched()`\r\n     * @see `markAsDirty()`\r\n     *\r\n     * @param opts Configuration options that determine how the control emits events after\r\n     * marking is applied.\r\n     * * `onlySelf`: When true, mark only this control. When false or not supplied,\r\n     * marks all direct ancestors. Default is false.\r\n     */\r\n    markAsPristine(opts?: {\r\n        onlySelf?: boolean;\r\n    }): void;\r\n    /**\r\n     * Marks the control as `pending`.\r\n     *\r\n     * A control is pending while the control performs async validation.\r\n     *\r\n     * @see {@link AbstractControl.status}\r\n     *\r\n     * @param opts Configuration options that determine how the control propagates changes and\r\n     * emits events after marking is applied.\r\n     * * `onlySelf`: When true, mark only this control. When false or not supplied,\r\n     * marks all direct ancestors. Default is false.\r\n     * * `emitEvent`: When true or not supplied (the default), the `statusChanges`\r\n     * observable emits an event with the latest status the control is marked pending.\r\n     * When false, no events are emitted.\r\n     *\r\n     */\r\n    markAsPending(opts?: {\r\n        onlySelf?: boolean;\r\n        emitEvent?: boolean;\r\n    }): void;\r\n    /**\r\n     * Disables the control. This means the control is exempt from validation checks and\r\n     * excluded from the aggregate value of any parent. Its status is `DISABLED`.\r\n     *\r\n     * If the control has children, all children are also disabled.\r\n     *\r\n     * @see {@link AbstractControl.status}\r\n     *\r\n     * @param opts Configuration options that determine how the control propagates\r\n     * changes and emits events after the control is disabled.\r\n     * * `onlySelf`: When true, mark only this control. When false or not supplied,\r\n     * marks all direct ancestors. Default is false.\r\n     * * `emitEvent`: When true or not supplied (the default), both the `statusChanges` and\r\n     * `valueChanges`\r\n     * observables emit events with the latest status and value when the control is disabled.\r\n     * When false, no events are emitted.\r\n     */\r\n    disable(opts?: {\r\n        onlySelf?: boolean;\r\n        emitEvent?: boolean;\r\n    }): void;\r\n    /**\r\n     * Enables the control. This means the control is included in validation checks and\r\n     * the aggregate value of its parent. Its status recalculates based on its value and\r\n     * its validators.\r\n     *\r\n     * By default, if the control has children, all children are enabled.\r\n     *\r\n     * @see {@link AbstractControl.status}\r\n     *\r\n     * @param opts Configure options that control how the control propagates changes and\r\n     * emits events when marked as untouched\r\n     * * `onlySelf`: When true, mark only this control. When false or not supplied,\r\n     * marks all direct ancestors. Default is false.\r\n     * * `emitEvent`: When true or not supplied (the default), both the `statusChanges` and\r\n     * `valueChanges`\r\n     * observables emit events with the latest status and value when the control is enabled.\r\n     * When false, no events are emitted.\r\n     */\r\n    enable(opts?: {\r\n        onlySelf?: boolean;\r\n        emitEvent?: boolean;\r\n    }): void;\r\n    private _updateAncestors;\r\n    /**\r\n     * @param parent Sets the parent of the control\r\n     */\r\n    setParent(parent: FormGroup | FormArray): void;\r\n    /**\r\n     * Sets the value of the control. Abstract method (implemented in sub-classes).\r\n     */\r\n    abstract setValue(value: any, options?: Object): void;\r\n    /**\r\n     * Patches the value of the control. Abstract method (implemented in sub-classes).\r\n     */\r\n    abstract patchValue(value: any, options?: Object): void;\r\n    /**\r\n     * Resets the control. Abstract method (implemented in sub-classes).\r\n     */\r\n    abstract reset(value?: any, options?: Object): void;\r\n    /**\r\n     * Recalculates the value and validation status of the control.\r\n     *\r\n     * By default, it also updates the value and validity of its ancestors.\r\n     *\r\n     * @param opts Configuration options determine how the control propagates changes and emits events\r\n     * after updates and validity checks are applied.\r\n     * * `onlySelf`: When true, only update this control. When false or not supplied,\r\n     * update all direct ancestors. Default is false.\r\n     * * `emitEvent`: When true or not supplied (the default), both the `statusChanges` and\r\n     * `valueChanges`\r\n     * observables emit events with the latest status and value when the control is updated.\r\n     * When false, no events are emitted.\r\n     */\r\n    updateValueAndValidity(opts?: {\r\n        onlySelf?: boolean;\r\n        emitEvent?: boolean;\r\n    }): void;\r\n    private _setInitialStatus;\r\n    private _runValidator;\r\n    private _runAsyncValidator;\r\n    private _cancelExistingSubscription;\r\n    /**\r\n     * Sets errors on a form control when running validations manually, rather than automatically.\r\n     *\r\n     * Calling `setErrors` also updates the validity of the parent control.\r\n     *\r\n     * @usageNotes\r\n     *\r\n     * ### Manually set the errors for a control\r\n     *\r\n     * ```\r\n     * const login = new FormControl('someLogin');\r\n     * login.setErrors({\r\n     *   notUnique: true\r\n     * });\r\n     *\r\n     * expect(login.valid).toEqual(false);\r\n     * expect(login.errors).toEqual({ notUnique: true });\r\n     *\r\n     * login.setValue('someOtherLogin');\r\n     *\r\n     * expect(login.valid).toEqual(true);\r\n     * ```\r\n     */\r\n    setErrors(errors: ValidationErrors | null, opts?: {\r\n        emitEvent?: boolean;\r\n    }): void;\r\n    /**\r\n     * Retrieves a child control given the control's name or path.\r\n     *\r\n     * @param path A dot-delimited string or array of string/number values that define the path to the\r\n     * control.\r\n     *\r\n     * @usageNotes\r\n     * ### Retrieve a nested control\r\n     *\r\n     * For example, to get a `name` control nested within a `person` sub-group:\r\n     *\r\n     * * `this.form.get('person.name');`\r\n     *\r\n     * -OR-\r\n     *\r\n     * * `this.form.get(['person', 'name']);`\r\n     *\r\n     * ### Retrieve a control in a FormArray\r\n     *\r\n     * When accessing an element inside a FormArray, you can use an element index.\r\n     * For example, to get a `price` control from the first element in an `items` array you can use:\r\n     *\r\n     * * `this.form.get('items.0.price');`\r\n     *\r\n     * -OR-\r\n     *\r\n     * * `this.form.get(['items', 0, 'price']);`\r\n     */\r\n    get(path: Array<string | number> | string): AbstractControl | null;\r\n    /**\r\n     * @description\r\n     * Reports error data for the control with the given path.\r\n     *\r\n     * @param errorCode The code of the error to check\r\n     * @param path A list of control names that designates how to move from the current control\r\n     * to the control that should be queried for errors.\r\n     *\r\n     * @usageNotes\r\n     * For example, for the following `FormGroup`:\r\n     *\r\n     * ```\r\n     * form = new FormGroup({\r\n     *   address: new FormGroup({ street: new FormControl() })\r\n     * });\r\n     * ```\r\n     *\r\n     * The path to the 'street' control from the root form would be 'address' -> 'street'.\r\n     *\r\n     * It can be provided to this method in one of two formats:\r\n     *\r\n     * 1. An array of string control names, e.g. `['address', 'street']`\r\n     * 1. A period-delimited list of control names in one string, e.g. `'address.street'`\r\n     *\r\n     * @returns error data for that particular error. If the control or error is not present,\r\n     * null is returned.\r\n     */\r\n    getError(errorCode: string, path?: Array<string | number> | string): any;\r\n    /**\r\n     * @description\r\n     * Reports whether the control with the given path has the error specified.\r\n     *\r\n     * @param errorCode The code of the error to check\r\n     * @param path A list of control names that designates how to move from the current control\r\n     * to the control that should be queried for errors.\r\n     *\r\n     * @usageNotes\r\n     * For example, for the following `FormGroup`:\r\n     *\r\n     * ```\r\n     * form = new FormGroup({\r\n     *   address: new FormGroup({ street: new FormControl() })\r\n     * });\r\n     * ```\r\n     *\r\n     * The path to the 'street' control from the root form would be 'address' -> 'street'.\r\n     *\r\n     * It can be provided to this method in one of two formats:\r\n     *\r\n     * 1. An array of string control names, e.g. `['address', 'street']`\r\n     * 1. A period-delimited list of control names in one string, e.g. `'address.street'`\r\n     *\r\n     * If no path is given, this method checks for the error on the current control.\r\n     *\r\n     * @returns whether the given error is present in the control at the given path.\r\n     *\r\n     * If the control is not present, false is returned.\r\n     */\r\n    hasError(errorCode: string, path?: Array<string | number> | string): boolean;\r\n    /**\r\n     * Retrieves the top-level ancestor of this control.\r\n     */\r\n    get root(): AbstractControl;\r\n    private _calculateStatus;\r\n}\r\n\r\n/**\r\n * @description\r\n * Base class for control directives.\r\n *\r\n * This class is only used internally in the `ReactiveFormsModule` and the `FormsModule`.\r\n *\r\n * @publicApi\r\n */\r\nexport declare abstract class AbstractControlDirective {\r\n    /**\r\n     * @description\r\n     * A reference to the underlying control.\r\n     *\r\n     * @returns the control that backs this directive. Most properties fall through to that instance.\r\n     */\r\n    abstract get control(): AbstractControl | null;\r\n    /**\r\n     * @description\r\n     * Reports the value of the control if it is present, otherwise null.\r\n     */\r\n    get value(): any;\r\n    /**\r\n     * @description\r\n     * Reports whether the control is valid. A control is considered valid if no\r\n     * validation errors exist with the current value.\r\n     * If the control is not present, null is returned.\r\n     */\r\n    get valid(): boolean | null;\r\n    /**\r\n     * @description\r\n     * Reports whether the control is invalid, meaning that an error exists in the input value.\r\n     * If the control is not present, null is returned.\r\n     */\r\n    get invalid(): boolean | null;\r\n    /**\r\n     * @description\r\n     * Reports whether a control is pending, meaning that that async validation is occurring and\r\n     * errors are not yet available for the input value. If the control is not present, null is\r\n     * returned.\r\n     */\r\n    get pending(): boolean | null;\r\n    /**\r\n     * @description\r\n     * Reports whether the control is disabled, meaning that the control is disabled\r\n     * in the UI and is exempt from validation checks and excluded from aggregate\r\n     * values of ancestor controls. If the control is not present, null is returned.\r\n     */\r\n    get disabled(): boolean | null;\r\n    /**\r\n     * @description\r\n     * Reports whether the control is enabled, meaning that the control is included in ancestor\r\n     * calculations of validity or value. If the control is not present, null is returned.\r\n     */\r\n    get enabled(): boolean | null;\r\n    /**\r\n     * @description\r\n     * Reports the control's validation errors. If the control is not present, null is returned.\r\n     */\r\n    get errors(): ValidationErrors | null;\r\n    /**\r\n     * @description\r\n     * Reports whether the control is pristine, meaning that the user has not yet changed\r\n     * the value in the UI. If the control is not present, null is returned.\r\n     */\r\n    get pristine(): boolean | null;\r\n    /**\r\n     * @description\r\n     * Reports whether the control is dirty, meaning that the user has changed\r\n     * the value in the UI. If the control is not present, null is returned.\r\n     */\r\n    get dirty(): boolean | null;\r\n    /**\r\n     * @description\r\n     * Reports whether the control is touched, meaning that the user has triggered\r\n     * a `blur` event on it. If the control is not present, null is returned.\r\n     */\r\n    get touched(): boolean | null;\r\n    /**\r\n     * @description\r\n     * Reports the validation status of the control. Possible values include:\r\n     * 'VALID', 'INVALID', 'DISABLED', and 'PENDING'.\r\n     * If the control is not present, null is returned.\r\n     */\r\n    get status(): string | null;\r\n    /**\r\n     * @description\r\n     * Reports whether the control is untouched, meaning that the user has not yet triggered\r\n     * a `blur` event on it. If the control is not present, null is returned.\r\n     */\r\n    get untouched(): boolean | null;\r\n    /**\r\n     * @description\r\n     * Returns a multicasting observable that emits a validation status whenever it is\r\n     * calculated for the control. If the control is not present, null is returned.\r\n     */\r\n    get statusChanges(): Observable<any> | null;\r\n    /**\r\n     * @description\r\n     * Returns a multicasting observable of value changes for the control that emits every time the\r\n     * value of the control changes in the UI or programmatically.\r\n     * If the control is not present, null is returned.\r\n     */\r\n    get valueChanges(): Observable<any> | null;\r\n    /**\r\n     * @description\r\n     * Returns an array that represents the path from the top-level form to this control.\r\n     * Each index is the string name of the control on that level.\r\n     */\r\n    get path(): string[] | null;\r\n    /**\r\n     * Contains the result of merging synchronous validators into a single validator function\r\n     * (combined using `Validators.compose`).\r\n     */\r\n    private _composedValidatorFn;\r\n    /**\r\n     * Contains the result of merging asynchronous validators into a single validator function\r\n     * (combined using `Validators.composeAsync`).\r\n     */\r\n    private _composedAsyncValidatorFn;\r\n    /**\r\n     * @description\r\n     * Synchronous validator function composed of all the synchronous validators registered with this\r\n     * directive.\r\n     */\r\n    get validator(): ValidatorFn | null;\r\n    /**\r\n     * @description\r\n     * Asynchronous validator function composed of all the asynchronous validators registered with\r\n     * this directive.\r\n     */\r\n    get asyncValidator(): AsyncValidatorFn | null;\r\n    private _onDestroyCallbacks;\r\n    /**\r\n     * @description\r\n     * Resets the control with the provided value if the control is present.\r\n     */\r\n    reset(value?: any): void;\r\n    /**\r\n     * @description\r\n     * Reports whether the control with the given path has the error specified.\r\n     *\r\n     * @param errorCode The code of the error to check\r\n     * @param path A list of control names that designates how to move from the current control\r\n     * to the control that should be queried for errors.\r\n     *\r\n     * @usageNotes\r\n     * For example, for the following `FormGroup`:\r\n     *\r\n     * ```\r\n     * form = new FormGroup({\r\n     *   address: new FormGroup({ street: new FormControl() })\r\n     * });\r\n     * ```\r\n     *\r\n     * The path to the 'street' control from the root form would be 'address' -> 'street'.\r\n     *\r\n     * It can be provided to this method in one of two formats:\r\n     *\r\n     * 1. An array of string control names, e.g. `['address', 'street']`\r\n     * 1. A period-delimited list of control names in one string, e.g. `'address.street'`\r\n     *\r\n     * If no path is given, this method checks for the error on the current control.\r\n     *\r\n     * @returns whether the given error is present in the control at the given path.\r\n     *\r\n     * If the control is not present, false is returned.\r\n     */\r\n    hasError(errorCode: string, path?: Array<string | number> | string): boolean;\r\n    /**\r\n     * @description\r\n     * Reports error data for the control with the given path.\r\n     *\r\n     * @param errorCode The code of the error to check\r\n     * @param path A list of control names that designates how to move from the current control\r\n     * to the control that should be queried for errors.\r\n     *\r\n     * @usageNotes\r\n     * For example, for the following `FormGroup`:\r\n     *\r\n     * ```\r\n     * form = new FormGroup({\r\n     *   address: new FormGroup({ street: new FormControl() })\r\n     * });\r\n     * ```\r\n     *\r\n     * The path to the 'street' control from the root form would be 'address' -> 'street'.\r\n     *\r\n     * It can be provided to this method in one of two formats:\r\n     *\r\n     * 1. An array of string control names, e.g. `['address', 'street']`\r\n     * 1. A period-delimited list of control names in one string, e.g. `'address.street'`\r\n     *\r\n     * @returns error data for that particular error. If the control or error is not present,\r\n     * null is returned.\r\n     */\r\n    getError(errorCode: string, path?: Array<string | number> | string): any;\r\n}\r\n\r\n/**\r\n * Interface for options provided to an `AbstractControl`.\r\n *\r\n * @publicApi\r\n */\r\nexport declare interface AbstractControlOptions {\r\n    /**\r\n     * @description\r\n     * The list of validators applied to a control.\r\n     */\r\n    validators?: ValidatorFn | ValidatorFn[] | null;\r\n    /**\r\n     * @description\r\n     * The list of async validators applied to control.\r\n     */\r\n    asyncValidators?: AsyncValidatorFn | AsyncValidatorFn[] | null;\r\n    /**\r\n     * @description\r\n     * The event name for control to update upon.\r\n     */\r\n    updateOn?: 'change' | 'blur' | 'submit';\r\n}\r\n\r\n/**\r\n * @description\r\n * A base class for code shared between the `NgModelGroup` and `FormGroupName` directives.\r\n *\r\n * @publicApi\r\n */\r\nexport declare class AbstractFormGroupDirective extends ControlContainer implements OnInit, OnDestroy {\r\n    /** @nodoc */\r\n    ngOnInit(): void;\r\n    /** @nodoc */\r\n    ngOnDestroy(): void;\r\n    /**\r\n     * @description\r\n     * The `FormGroup` bound to this directive.\r\n     */\r\n    get control(): FormGroup;\r\n    /**\r\n     * @description\r\n     * The path to this group from the top-level directive.\r\n     */\r\n    get path(): string[];\r\n    /**\r\n     * @description\r\n     * The top-level directive for this group if present, otherwise null.\r\n     */\r\n    get formDirective(): Form | null;\r\n}\r\n\r\n/**\r\n * A base class for Validator-based Directives. The class contains common logic shared across such\r\n * Directives.\r\n *\r\n * For internal use only, this class is not intended for use outside of the Forms package.\r\n */\r\ndeclare abstract class AbstractValidatorDirective implements Validator {\r\n    private _validator;\r\n    private _onChange;\r\n    /**\r\n     * Helper function invoked from child classes to process changes (from `ngOnChanges` hook).\r\n     * @nodoc\r\n     */\r\n    handleChanges(changes: SimpleChanges): void;\r\n    /** @nodoc */\r\n    validate(control: AbstractControl): ValidationErrors | null;\r\n    /** @nodoc */\r\n    registerOnValidatorChange(fn: () => void): void;\r\n}\r\n\r\ndeclare type AnyControlStatus = 'untouched' | 'touched' | 'pristine' | 'dirty' | 'valid' | 'invalid' | 'pending' | 'submitted';\r\n\r\n/**\r\n * @description\r\n * An interface implemented by classes that perform asynchronous validation.\r\n *\r\n * @usageNotes\r\n *\r\n * ### Provide a custom async validator directive\r\n *\r\n * The following example implements the `AsyncValidator` interface to create an\r\n * async validator directive with a custom error key.\r\n *\r\n * ```typescript\r\n * import { of } from 'rxjs';\r\n *\r\n * @Directive({\r\n *   selector: '[customAsyncValidator]',\r\n *   providers: [{provide: NG_ASYNC_VALIDATORS, useExisting: CustomAsyncValidatorDirective, multi:\r\n * true}]\r\n * })\r\n * class CustomAsyncValidatorDirective implements AsyncValidator {\r\n *   validate(control: AbstractControl): Observable<ValidationErrors|null> {\r\n *     return of({'custom': true});\r\n *   }\r\n * }\r\n * ```\r\n *\r\n * @publicApi\r\n */\r\nexport declare interface AsyncValidator extends Validator {\r\n    /**\r\n     * @description\r\n     * Method that performs async validation against the provided control.\r\n     *\r\n     * @param control The control to validate against.\r\n     *\r\n     * @returns A promise or observable that resolves a map of validation errors\r\n     * if validation fails, otherwise null.\r\n     */\r\n    validate(control: AbstractControl): Promise<ValidationErrors | null> | Observable<ValidationErrors | null>;\r\n}\r\n\r\n/**\r\n * @description\r\n * A function that receives a control and returns a Promise or observable\r\n * that emits validation errors if present, otherwise null.\r\n *\r\n * @publicApi\r\n */\r\nexport declare interface AsyncValidatorFn {\r\n    (control: AbstractControl): Promise<ValidationErrors | null> | Observable<ValidationErrors | null>;\r\n}\r\n\r\n/**\r\n * @description\r\n * A `ControlValueAccessor` for writing a value and listening to changes on a checkbox input\r\n * element.\r\n *\r\n * @usageNotes\r\n *\r\n * ### Using a checkbox with a reactive form.\r\n *\r\n * The following example shows how to use a checkbox with a reactive form.\r\n *\r\n * ```ts\r\n * const rememberLoginControl = new FormControl();\r\n * ```\r\n *\r\n * ```\r\n * <input type=\"checkbox\" [formControl]=\"rememberLoginControl\">\r\n * ```\r\n *\r\n * @ngModule ReactiveFormsModule\r\n * @ngModule FormsModule\r\n * @publicApi\r\n */\r\nexport declare class CheckboxControlValueAccessor extends ɵangular_packages_forms_forms_g implements ControlValueAccessor {\r\n    /**\r\n     * Sets the \"checked\" property on the input element.\r\n     * @nodoc\r\n     */\r\n    writeValue(value: any): void;\r\n}\r\n\r\n/**\r\n * A Directive that adds the `required` validator to checkbox controls marked with the\r\n * `required` attribute. The directive is provided with the `NG_VALIDATORS` multi-provider list.\r\n *\r\n * @see [Form Validation](guide/form-validation)\r\n *\r\n * @usageNotes\r\n *\r\n * ### Adding a required checkbox validator using template-driven forms\r\n *\r\n * The following example shows how to add a checkbox required validator to an input attached to an\r\n * ngModel binding.\r\n *\r\n * ```\r\n * <input type=\"checkbox\" name=\"active\" ngModel required>\r\n * ```\r\n *\r\n * @publicApi\r\n * @ngModule FormsModule\r\n * @ngModule ReactiveFormsModule\r\n */\r\nexport declare class CheckboxRequiredValidator extends RequiredValidator {\r\n    /**\r\n     * Method that validates whether or not the checkbox has been checked.\r\n     * Returns the validation result if enabled, otherwise null.\r\n     * @nodoc\r\n     */\r\n    validate(control: AbstractControl): ValidationErrors | null;\r\n}\r\n\r\n/**\r\n * @description\r\n * Provide this token to control if form directives buffer IME input until\r\n * the \"compositionend\" event occurs.\r\n * @publicApi\r\n */\r\nexport declare const COMPOSITION_BUFFER_MODE: InjectionToken<boolean>;\r\n\r\n/**\r\n * @description\r\n * A base class for directives that contain multiple registered instances of `NgControl`.\r\n * Only used by the forms module.\r\n *\r\n * @publicApi\r\n */\r\nexport declare abstract class ControlContainer extends AbstractControlDirective {\r\n    /**\r\n     * @description\r\n     * The name for the control\r\n     */\r\n    name: string | number | null;\r\n    /**\r\n     * @description\r\n     * The top-level form directive for the control.\r\n     */\r\n    get formDirective(): Form | null;\r\n    /**\r\n     * @description\r\n     * The path to this group.\r\n     */\r\n    get path(): string[] | null;\r\n}\r\n\r\n/**\r\n * @description\r\n * Defines an interface that acts as a bridge between the Angular forms API and a\r\n * native element in the DOM.\r\n *\r\n * Implement this interface to create a custom form control directive\r\n * that integrates with Angular forms.\r\n *\r\n * @see DefaultValueAccessor\r\n *\r\n * @publicApi\r\n */\r\nexport declare interface ControlValueAccessor {\r\n    /**\r\n     * @description\r\n     * Writes a new value to the element.\r\n     *\r\n     * This method is called by the forms API to write to the view when programmatic\r\n     * changes from model to view are requested.\r\n     *\r\n     * @usageNotes\r\n     * ### Write a value to the element\r\n     *\r\n     * The following example writes a value to the native DOM element.\r\n     *\r\n     * ```ts\r\n     * writeValue(value: any): void {\r\n     *   this._renderer.setProperty(this._elementRef.nativeElement, 'value', value);\r\n     * }\r\n     * ```\r\n     *\r\n     * @param obj The new value for the element\r\n     */\r\n    writeValue(obj: any): void;\r\n    /**\r\n     * @description\r\n     * Registers a callback function that is called when the control's value\r\n     * changes in the UI.\r\n     *\r\n     * This method is called by the forms API on initialization to update the form\r\n     * model when values propagate from the view to the model.\r\n     *\r\n     * When implementing the `registerOnChange` method in your own value accessor,\r\n     * save the given function so your class calls it at the appropriate time.\r\n     *\r\n     * @usageNotes\r\n     * ### Store the change function\r\n     *\r\n     * The following example stores the provided function as an internal method.\r\n     *\r\n     * ```ts\r\n     * registerOnChange(fn: (_: any) => void): void {\r\n     *   this._onChange = fn;\r\n     * }\r\n     * ```\r\n     *\r\n     * When the value changes in the UI, call the registered\r\n     * function to allow the forms API to update itself:\r\n     *\r\n     * ```ts\r\n     * host: {\r\n     *    '(change)': '_onChange($event.target.value)'\r\n     * }\r\n     * ```\r\n     *\r\n     * @param fn The callback function to register\r\n     */\r\n    registerOnChange(fn: any): void;\r\n    /**\r\n     * @description\r\n     * Registers a callback function that is called by the forms API on initialization\r\n     * to update the form model on blur.\r\n     *\r\n     * When implementing `registerOnTouched` in your own value accessor, save the given\r\n     * function so your class calls it when the control should be considered\r\n     * blurred or \"touched\".\r\n     *\r\n     * @usageNotes\r\n     * ### Store the callback function\r\n     *\r\n     * The following example stores the provided function as an internal method.\r\n     *\r\n     * ```ts\r\n     * registerOnTouched(fn: any): void {\r\n     *   this._onTouched = fn;\r\n     * }\r\n     * ```\r\n     *\r\n     * On blur (or equivalent), your class should call the registered function to allow\r\n     * the forms API to update itself:\r\n     *\r\n     * ```ts\r\n     * host: {\r\n     *    '(blur)': '_onTouched()'\r\n     * }\r\n     * ```\r\n     *\r\n     * @param fn The callback function to register\r\n     */\r\n    registerOnTouched(fn: any): void;\r\n    /**\r\n     * @description\r\n     * Function that is called by the forms API when the control status changes to\r\n     * or from 'DISABLED'. Depending on the status, it enables or disables the\r\n     * appropriate DOM element.\r\n     *\r\n     * @usageNotes\r\n     * The following is an example of writing the disabled property to a native DOM element:\r\n     *\r\n     * ```ts\r\n     * setDisabledState(isDisabled: boolean): void {\r\n     *   this._renderer.setProperty(this._elementRef.nativeElement, 'disabled', isDisabled);\r\n     * }\r\n     * ```\r\n     *\r\n     * @param isDisabled The disabled status to set on the element\r\n     */\r\n    setDisabledState?(isDisabled: boolean): void;\r\n}\r\n\r\n/**\r\n * The default `ControlValueAccessor` for writing a value and listening to changes on input\r\n * elements. The accessor is used by the `FormControlDirective`, `FormControlName`, and\r\n * `NgModel` directives.\r\n *\r\n * {@searchKeywords ngDefaultControl}\r\n *\r\n * @usageNotes\r\n *\r\n * ### Using the default value accessor\r\n *\r\n * The following example shows how to use an input element that activates the default value accessor\r\n * (in this case, a text field).\r\n *\r\n * ```ts\r\n * const firstNameControl = new FormControl();\r\n * ```\r\n *\r\n * ```\r\n * <input type=\"text\" [formControl]=\"firstNameControl\">\r\n * ```\r\n *\r\n * This value accessor is used by default for `<input type=\"text\">` and `<textarea>` elements, but\r\n * you could also use it for custom components that have similar behavior and do not require special\r\n * processing. In order to attach the default value accessor to a custom element, add the\r\n * `ngDefaultControl` attribute as shown below.\r\n *\r\n * ```\r\n * <custom-input-component ngDefaultControl [(ngModel)]=\"value\"></custom-input-component>\r\n * ```\r\n *\r\n * @ngModule ReactiveFormsModule\r\n * @ngModule FormsModule\r\n * @publicApi\r\n */\r\nexport declare class DefaultValueAccessor extends ɵangular_packages_forms_forms_f implements ControlValueAccessor {\r\n    private _compositionMode;\r\n    /** Whether the user is creating a composition string (IME events). */\r\n    private _composing;\r\n    constructor(renderer: Renderer2, elementRef: ElementRef, _compositionMode: boolean);\r\n    /**\r\n     * Sets the \"value\" property on the input element.\r\n     * @nodoc\r\n     */\r\n    writeValue(value: any): void;\r\n}\r\n\r\n/**\r\n * A directive that adds the `email` validator to controls marked with the\r\n * `email` attribute. The directive is provided with the `NG_VALIDATORS` multi-provider list.\r\n *\r\n * @see [Form Validation](guide/form-validation)\r\n *\r\n * @usageNotes\r\n *\r\n * ### Adding an email validator\r\n *\r\n * The following example shows how to add an email validator to an input attached to an ngModel\r\n * binding.\r\n *\r\n * ```\r\n * <input type=\"email\" name=\"email\" ngModel email>\r\n * <input type=\"email\" name=\"email\" ngModel email=\"true\">\r\n * <input type=\"email\" name=\"email\" ngModel [email]=\"true\">\r\n * ```\r\n *\r\n * @publicApi\r\n * @ngModule FormsModule\r\n * @ngModule ReactiveFormsModule\r\n */\r\nexport declare class EmailValidator implements Validator {\r\n    private _enabled;\r\n    private _onChange?;\r\n    /**\r\n     * @description\r\n     * Tracks changes to the email attribute bound to this directive.\r\n     */\r\n    set email(value: boolean | string);\r\n    /**\r\n     * Method that validates whether an email address is valid.\r\n     * Returns the validation result if enabled, otherwise null.\r\n     * @nodoc\r\n     */\r\n    validate(control: AbstractControl): ValidationErrors | null;\r\n    /**\r\n     * Registers a callback function to call when the validator inputs change.\r\n     * @nodoc\r\n     */\r\n    registerOnValidatorChange(fn: () => void): void;\r\n}\r\n\r\n/**\r\n * @description\r\n * An interface implemented by `FormGroupDirective` and `NgForm` directives.\r\n *\r\n * Only used by the `ReactiveFormsModule` and `FormsModule`.\r\n *\r\n * @publicApi\r\n */\r\nexport declare interface Form {\r\n    /**\r\n     * @description\r\n     * Add a control to this form.\r\n     *\r\n     * @param dir The control directive to add to the form.\r\n     */\r\n    addControl(dir: NgControl): void;\r\n    /**\r\n     * @description\r\n     * Remove a control from this form.\r\n     *\r\n     * @param dir: The control directive to remove from the form.\r\n     */\r\n    removeControl(dir: NgControl): void;\r\n    /**\r\n     * @description\r\n     * The control directive from which to get the `FormControl`.\r\n     *\r\n     * @param dir: The control directive.\r\n     */\r\n    getControl(dir: NgControl): FormControl;\r\n    /**\r\n     * @description\r\n     * Add a group of controls to this form.\r\n     *\r\n     * @param dir: The control group directive to add.\r\n     */\r\n    addFormGroup(dir: AbstractFormGroupDirective): void;\r\n    /**\r\n     * @description\r\n     * Remove a group of controls to this form.\r\n     *\r\n     * @param dir: The control group directive to remove.\r\n     */\r\n    removeFormGroup(dir: AbstractFormGroupDirective): void;\r\n    /**\r\n     * @description\r\n     * The `FormGroup` associated with a particular `AbstractFormGroupDirective`.\r\n     *\r\n     * @param dir: The form group directive from which to get the `FormGroup`.\r\n     */\r\n    getFormGroup(dir: AbstractFormGroupDirective): FormGroup;\r\n    /**\r\n     * @description\r\n     * Update the model for a particular control with a new value.\r\n     *\r\n     * @param dir: The control directive to update.\r\n     * @param value: The new value for the control.\r\n     */\r\n    updateModel(dir: NgControl, value: any): void;\r\n}\r\n\r\n/**\r\n * Tracks the value and validity state of an array of `FormControl`,\r\n * `FormGroup` or `FormArray` instances.\r\n *\r\n * A `FormArray` aggregates the values of each child `FormControl` into an array.\r\n * It calculates its status by reducing the status values of its children. For example, if one of\r\n * the controls in a `FormArray` is invalid, the entire array becomes invalid.\r\n *\r\n * `FormArray` is one of the three fundamental building blocks used to define forms in Angular,\r\n * along with `FormControl` and `FormGroup`.\r\n *\r\n * @usageNotes\r\n *\r\n * ### Create an array of form controls\r\n *\r\n * ```\r\n * const arr = new FormArray([\r\n *   new FormControl('Nancy', Validators.minLength(2)),\r\n *   new FormControl('Drew'),\r\n * ]);\r\n *\r\n * console.log(arr.value);   // ['Nancy', 'Drew']\r\n * console.log(arr.status);  // 'VALID'\r\n * ```\r\n *\r\n * ### Create a form array with array-level validators\r\n *\r\n * You include array-level validators and async validators. These come in handy\r\n * when you want to perform validation that considers the value of more than one child\r\n * control.\r\n *\r\n * The two types of validators are passed in separately as the second and third arg\r\n * respectively, or together as part of an options object.\r\n *\r\n * ```\r\n * const arr = new FormArray([\r\n *   new FormControl('Nancy'),\r\n *   new FormControl('Drew')\r\n * ], {validators: myValidator, asyncValidators: myAsyncValidator});\r\n * ```\r\n *\r\n * ### Set the updateOn property for all controls in a form array\r\n *\r\n * The options object is used to set a default value for each child\r\n * control's `updateOn` property. If you set `updateOn` to `'blur'` at the\r\n * array level, all child controls default to 'blur', unless the child\r\n * has explicitly specified a different `updateOn` value.\r\n *\r\n * ```ts\r\n * const arr = new FormArray([\r\n *    new FormControl()\r\n * ], {updateOn: 'blur'});\r\n * ```\r\n *\r\n * ### Adding or removing controls from a form array\r\n *\r\n * To change the controls in the array, use the `push`, `insert`, `removeAt` or `clear` methods\r\n * in `FormArray` itself. These methods ensure the controls are properly tracked in the\r\n * form's hierarchy. Do not modify the array of `AbstractControl`s used to instantiate\r\n * the `FormArray` directly, as that result in strange and unexpected behavior such\r\n * as broken change detection.\r\n *\r\n * @publicApi\r\n */\r\nexport declare class FormArray extends AbstractControl {\r\n    controls: AbstractControl[];\r\n    /**\r\n     * Creates a new `FormArray` instance.\r\n     *\r\n     * @param controls An array of child controls. Each child control is given an index\r\n     * where it is registered.\r\n     *\r\n     * @param validatorOrOpts A synchronous validator function, or an array of\r\n     * such functions, or an `AbstractControlOptions` object that contains validation functions\r\n     * and a validation trigger.\r\n     *\r\n     * @param asyncValidator A single async validator or array of async validator functions\r\n     *\r\n     */\r\n    constructor(controls: AbstractControl[], validatorOrOpts?: ValidatorFn | ValidatorFn[] | AbstractControlOptions | null, asyncValidator?: AsyncValidatorFn | AsyncValidatorFn[] | null);\r\n    /**\r\n     * Get the `AbstractControl` at the given `index` in the array.\r\n     *\r\n     * @param index Index in the array to retrieve the control\r\n     */\r\n    at(index: number): AbstractControl;\r\n    /**\r\n     * Insert a new `AbstractControl` at the end of the array.\r\n     *\r\n     * @param control Form control to be inserted\r\n     * @param options Specifies whether this FormArray instance should emit events after a new\r\n     *     control is added.\r\n     * * `emitEvent`: When true or not supplied (the default), both the `statusChanges` and\r\n     * `valueChanges` observables emit events with the latest status and value when the control is\r\n     * inserted. When false, no events are emitted.\r\n     */\r\n    push(control: AbstractControl, options?: {\r\n        emitEvent?: boolean;\r\n    }): void;\r\n    /**\r\n     * Insert a new `AbstractControl` at the given `index` in the array.\r\n     *\r\n     * @param index Index in the array to insert the control\r\n     * @param control Form control to be inserted\r\n     * @param options Specifies whether this FormArray instance should emit events after a new\r\n     *     control is inserted.\r\n     * * `emitEvent`: When true or not supplied (the default), both the `statusChanges` and\r\n     * `valueChanges` observables emit events with the latest status and value when the control is\r\n     * inserted. When false, no events are emitted.\r\n     */\r\n    insert(index: number, control: AbstractControl, options?: {\r\n        emitEvent?: boolean;\r\n    }): void;\r\n    /**\r\n     * Remove the control at the given `index` in the array.\r\n     *\r\n     * @param index Index in the array to remove the control\r\n     * @param options Specifies whether this FormArray instance should emit events after a\r\n     *     control is removed.\r\n     * * `emitEvent`: When true or not supplied (the default), both the `statusChanges` and\r\n     * `valueChanges` observables emit events with the latest status and value when the control is\r\n     * removed. When false, no events are emitted.\r\n     */\r\n    removeAt(index: number, options?: {\r\n        emitEvent?: boolean;\r\n    }): void;\r\n    /**\r\n     * Replace an existing control.\r\n     *\r\n     * @param index Index in the array to replace the control\r\n     * @param control The `AbstractControl` control to replace the existing control\r\n     * @param options Specifies whether this FormArray instance should emit events after an\r\n     *     existing control is replaced with a new one.\r\n     * * `emitEvent`: When true or not supplied (the default), both the `statusChanges` and\r\n     * `valueChanges` observables emit events with the latest status and value when the control is\r\n     * replaced with a new one. When false, no events are emitted.\r\n     */\r\n    setControl(index: number, control: AbstractControl, options?: {\r\n        emitEvent?: boolean;\r\n    }): void;\r\n    /**\r\n     * Length of the control array.\r\n     */\r\n    get length(): number;\r\n    /**\r\n     * Sets the value of the `FormArray`. It accepts an array that matches\r\n     * the structure of the control.\r\n     *\r\n     * This method performs strict checks, and throws an error if you try\r\n     * to set the value of a control that doesn't exist or if you exclude the\r\n     * value of a control.\r\n     *\r\n     * @usageNotes\r\n     * ### Set the values for the controls in the form array\r\n     *\r\n     * ```\r\n     * const arr = new FormArray([\r\n     *   new FormControl(),\r\n     *   new FormControl()\r\n     * ]);\r\n     * console.log(arr.value);   // [null, null]\r\n     *\r\n     * arr.setValue(['Nancy', 'Drew']);\r\n     * console.log(arr.value);   // ['Nancy', 'Drew']\r\n     * ```\r\n     *\r\n     * @param value Array of values for the controls\r\n     * @param options Configure options that determine how the control propagates changes and\r\n     * emits events after the value changes\r\n     *\r\n     * * `onlySelf`: When true, each change only affects this control, and not its parent. Default\r\n     * is false.\r\n     * * `emitEvent`: When true or not supplied (the default), both the `statusChanges` and\r\n     * `valueChanges`\r\n     * observables emit events with the latest status and value when the control value is updated.\r\n     * When false, no events are emitted.\r\n     * The configuration options are passed to the {@link AbstractControl#updateValueAndValidity\r\n     * updateValueAndValidity} method.\r\n     */\r\n    setValue(value: any[], options?: {\r\n        onlySelf?: boolean;\r\n        emitEvent?: boolean;\r\n    }): void;\r\n    /**\r\n     * Patches the value of the `FormArray`. It accepts an array that matches the\r\n     * structure of the control, and does its best to match the values to the correct\r\n     * controls in the group.\r\n     *\r\n     * It accepts both super-sets and sub-sets of the array without throwing an error.\r\n     *\r\n     * @usageNotes\r\n     * ### Patch the values for controls in a form array\r\n     *\r\n     * ```\r\n     * const arr = new FormArray([\r\n     *    new FormControl(),\r\n     *    new FormControl()\r\n     * ]);\r\n     * console.log(arr.value);   // [null, null]\r\n     *\r\n     * arr.patchValue(['Nancy']);\r\n     * console.log(arr.value);   // ['Nancy', null]\r\n     * ```\r\n     *\r\n     * @param value Array of latest values for the controls\r\n     * @param options Configure options that determine how the control propagates changes and\r\n     * emits events after the value changes\r\n     *\r\n     * * `onlySelf`: When true, each change only affects this control, and not its parent. Default\r\n     * is false.\r\n     * * `emitEvent`: When true or not supplied (the default), both the `statusChanges` and\r\n     * `valueChanges` observables emit events with the latest status and value when the control value\r\n     * is updated. When false, no events are emitted. The configuration options are passed to\r\n     * the {@link AbstractControl#updateValueAndValidity updateValueAndValidity} method.\r\n     */\r\n    patchValue(value: any[], options?: {\r\n        onlySelf?: boolean;\r\n        emitEvent?: boolean;\r\n    }): void;\r\n    /**\r\n     * Resets the `FormArray` and all descendants are marked `pristine` and `untouched`, and the\r\n     * value of all descendants to null or null maps.\r\n     *\r\n     * You reset to a specific form state by passing in an array of states\r\n     * that matches the structure of the control. The state is a standalone value\r\n     * or a form state object with both a value and a disabled status.\r\n     *\r\n     * @usageNotes\r\n     * ### Reset the values in a form array\r\n     *\r\n     * ```ts\r\n     * const arr = new FormArray([\r\n     *    new FormControl(),\r\n     *    new FormControl()\r\n     * ]);\r\n     * arr.reset(['name', 'last name']);\r\n     *\r\n     * console.log(arr.value);  // ['name', 'last name']\r\n     * ```\r\n     *\r\n     * ### Reset the values in a form array and the disabled status for the first control\r\n     *\r\n     * ```\r\n     * arr.reset([\r\n     *   {value: 'name', disabled: true},\r\n     *   'last'\r\n     * ]);\r\n     *\r\n     * console.log(arr.value);  // ['last']\r\n     * console.log(arr.at(0).status);  // 'DISABLED'\r\n     * ```\r\n     *\r\n     * @param value Array of values for the controls\r\n     * @param options Configure options that determine how the control propagates changes and\r\n     * emits events after the value changes\r\n     *\r\n     * * `onlySelf`: When true, each change only affects this control, and not its parent. Default\r\n     * is false.\r\n     * * `emitEvent`: When true or not supplied (the default), both the `statusChanges` and\r\n     * `valueChanges`\r\n     * observables emit events with the latest status and value when the control is reset.\r\n     * When false, no events are emitted.\r\n     * The configuration options are passed to the {@link AbstractControl#updateValueAndValidity\r\n     * updateValueAndValidity} method.\r\n     */\r\n    reset(value?: any, options?: {\r\n        onlySelf?: boolean;\r\n        emitEvent?: boolean;\r\n    }): void;\r\n    /**\r\n     * The aggregate value of the array, including any disabled controls.\r\n     *\r\n     * Reports all values regardless of disabled status.\r\n     * For enabled controls only, the `value` property is the best way to get the value of the array.\r\n     */\r\n    getRawValue(): any[];\r\n    /**\r\n     * Remove all controls in the `FormArray`.\r\n     *\r\n     * @param options Specifies whether this FormArray instance should emit events after all\r\n     *     controls are removed.\r\n     * * `emitEvent`: When true or not supplied (the default), both the `statusChanges` and\r\n     * `valueChanges` observables emit events with the latest status and value when all controls\r\n     * in this FormArray instance are removed. When false, no events are emitted.\r\n     *\r\n     * @usageNotes\r\n     * ### Remove all elements from a FormArray\r\n     *\r\n     * ```ts\r\n     * const arr = new FormArray([\r\n     *    new FormControl(),\r\n     *    new FormControl()\r\n     * ]);\r\n     * console.log(arr.length);  // 2\r\n     *\r\n     * arr.clear();\r\n     * console.log(arr.length);  // 0\r\n     * ```\r\n     *\r\n     * It's a simpler and more efficient alternative to removing all elements one by one:\r\n     *\r\n     * ```ts\r\n     * const arr = new FormArray([\r\n     *    new FormControl(),\r\n     *    new FormControl()\r\n     * ]);\r\n     *\r\n     * while (arr.length) {\r\n     *    arr.removeAt(0);\r\n     * }\r\n     * ```\r\n     */\r\n    clear(options?: {\r\n        emitEvent?: boolean;\r\n    }): void;\r\n    private _registerControl;\r\n}\r\n\r\n/**\r\n * @description\r\n *\r\n * Syncs a nested `FormArray` to a DOM element.\r\n *\r\n * This directive is designed to be used with a parent `FormGroupDirective` (selector:\r\n * `[formGroup]`).\r\n *\r\n * It accepts the string name of the nested `FormArray` you want to link, and\r\n * will look for a `FormArray` registered with that name in the parent\r\n * `FormGroup` instance you passed into `FormGroupDirective`.\r\n *\r\n * @see [Reactive Forms Guide](guide/reactive-forms)\r\n * @see `AbstractControl`\r\n *\r\n * @usageNotes\r\n *\r\n * ### Example\r\n *\r\n * {@example forms/ts/nestedFormArray/nested_form_array_example.ts region='Component'}\r\n *\r\n * @ngModule ReactiveFormsModule\r\n * @publicApi\r\n */\r\nexport declare class FormArrayName extends ControlContainer implements OnInit, OnDestroy {\r\n    /**\r\n     * @description\r\n     * Tracks the name of the `FormArray` bound to the directive. The name corresponds\r\n     * to a key in the parent `FormGroup` or `FormArray`.\r\n     * Accepts a name as a string or a number.\r\n     * The name in the form of a string is useful for individual forms,\r\n     * while the numerical form allows for form arrays to be bound\r\n     * to indices when iterating over arrays in a `FormArray`.\r\n     */\r\n    name: string | number | null;\r\n    constructor(parent: ControlContainer, validators: (Validator | ValidatorFn)[], asyncValidators: (AsyncValidator | AsyncValidatorFn)[]);\r\n    /**\r\n     * A lifecycle method called when the directive's inputs are initialized. For internal use only.\r\n     * @throws If the directive does not have a valid parent.\r\n     * @nodoc\r\n     */\r\n    ngOnInit(): void;\r\n    /**\r\n     * A lifecycle method called before the directive's instance is destroyed. For internal use only.\r\n     * @nodoc\r\n     */\r\n    ngOnDestroy(): void;\r\n    /**\r\n     * @description\r\n     * The `FormArray` bound to this directive.\r\n     */\r\n    get control(): FormArray;\r\n    /**\r\n     * @description\r\n     * The top-level directive for this group if present, otherwise null.\r\n     */\r\n    get formDirective(): FormGroupDirective | null;\r\n    /**\r\n     * @description\r\n     * Returns an array that represents the path from the top-level form to this control.\r\n     * Each index is the string name of the control on that level.\r\n     */\r\n    get path(): string[];\r\n    private _checkParentType;\r\n}\r\n\r\n/**\r\n * @description\r\n * Creates an `AbstractControl` from a user-specified configuration.\r\n *\r\n * The `FormBuilder` provides syntactic sugar that shortens creating instances of a `FormControl`,\r\n * `FormGroup`, or `FormArray`. It reduces the amount of boilerplate needed to build complex\r\n * forms.\r\n *\r\n * @see [Reactive Forms Guide](/guide/reactive-forms)\r\n *\r\n * @publicApi\r\n */\r\nexport declare class FormBuilder {\r\n    /**\r\n     * @description\r\n     * Construct a new `FormGroup` instance.\r\n     *\r\n     * @param controlsConfig A collection of child controls. The key for each child is the name\r\n     * under which it is registered.\r\n     *\r\n     * @param options Configuration options object for the `FormGroup`. The object should have the\r\n     * the `AbstractControlOptions` type and might contain the following fields:\r\n     * * `validators`: A synchronous validator function, or an array of validator functions\r\n     * * `asyncValidators`: A single async validator or array of async validator functions\r\n     * * `updateOn`: The event upon which the control should be updated (options: 'change' | 'blur' |\r\n     * submit')\r\n     */\r\n    group(controlsConfig: {\r\n        [key: string]: any;\r\n    }, options?: AbstractControlOptions | null): FormGroup;\r\n    /**\r\n     * @description\r\n     * Construct a new `FormGroup` instance.\r\n     *\r\n     * @deprecated This API is not typesafe and can result in issues with Closure Compiler renaming.\r\n     * Use the `FormBuilder#group` overload with `AbstractControlOptions` instead.\r\n     * Note that `AbstractControlOptions` expects `validators` and `asyncValidators` to be valid\r\n     * validators. If you have custom validators, make sure their validation function parameter is\r\n     * `AbstractControl` and not a sub-class, such as `FormGroup`. These functions will be called with\r\n     * an object of type `AbstractControl` and that cannot be automatically downcast to a subclass, so\r\n     * TypeScript sees this as an error. For example, change the `(group: FormGroup) =>\r\n     * ValidationErrors|null` signature to be `(group: AbstractControl) => ValidationErrors|null`.\r\n     *\r\n     * @param controlsConfig A collection of child controls. The key for each child is the name\r\n     * under which it is registered.\r\n     *\r\n     * @param options Configuration options object for the `FormGroup`. The legacy configuration\r\n     * object consists of:\r\n     * * `validator`: A synchronous validator function, or an array of validator functions\r\n     * * `asyncValidator`: A single async validator or array of async validator functions\r\n     * Note: the legacy format is deprecated and might be removed in one of the next major versions\r\n     * of Angular.\r\n     */\r\n    group(controlsConfig: {\r\n        [key: string]: any;\r\n    }, options: {\r\n        [key: string]: any;\r\n    }): FormGroup;\r\n    /**\r\n     * @description\r\n     * Construct a new `FormControl` with the given state, validators and options.\r\n     *\r\n     * @param formState Initializes the control with an initial state value, or\r\n     * with an object that contains both a value and a disabled status.\r\n     *\r\n     * @param validatorOrOpts A synchronous validator function, or an array of\r\n     * such functions, or an `AbstractControlOptions` object that contains\r\n     * validation functions and a validation trigger.\r\n     *\r\n     * @param asyncValidator A single async validator or array of async validator\r\n     * functions.\r\n     *\r\n     * @usageNotes\r\n     *\r\n     * ### Initialize a control as disabled\r\n     *\r\n     * The following example returns a control with an initial value in a disabled state.\r\n     *\r\n     * <code-example path=\"forms/ts/formBuilder/form_builder_example.ts\" region=\"disabled-control\">\r\n     * </code-example>\r\n     */\r\n    control(formState: any, validatorOrOpts?: ValidatorFn | ValidatorFn[] | AbstractControlOptions | null, asyncValidator?: AsyncValidatorFn | AsyncValidatorFn[] | null): FormControl;\r\n    /**\r\n     * Constructs a new `FormArray` from the given array of configurations,\r\n     * validators and options.\r\n     *\r\n     * @param controlsConfig An array of child controls or control configs. Each\r\n     * child control is given an index when it is registered.\r\n     *\r\n     * @param validatorOrOpts A synchronous validator function, or an array of\r\n     * such functions, or an `AbstractControlOptions` object that contains\r\n     * validation functions and a validation trigger.\r\n     *\r\n     * @param asyncValidator A single async validator or array of async validator\r\n     * functions.\r\n     */\r\n    array(controlsConfig: any[], validatorOrOpts?: ValidatorFn | ValidatorFn[] | AbstractControlOptions | null, asyncValidator?: AsyncValidatorFn | AsyncValidatorFn[] | null): FormArray;\r\n}\r\n\r\n/**\r\n * Tracks the value and validation status of an individual form control.\r\n *\r\n * This is one of the three fundamental building blocks of Angular forms, along with\r\n * `FormGroup` and `FormArray`. It extends the `AbstractControl` class that\r\n * implements most of the base functionality for accessing the value, validation status,\r\n * user interactions and events. See [usage examples below](#usage-notes).\r\n *\r\n * @see `AbstractControl`\r\n * @see [Reactive Forms Guide](guide/reactive-forms)\r\n * @see [Usage Notes](#usage-notes)\r\n *\r\n * @usageNotes\r\n *\r\n * ### Initializing Form Controls\r\n *\r\n * Instantiate a `FormControl`, with an initial value.\r\n *\r\n * ```ts\r\n * const control = new FormControl('some value');\r\n * console.log(control.value);     // 'some value'\r\n *```\r\n *\r\n * The following example initializes the control with a form state object. The `value`\r\n * and `disabled` keys are required in this case.\r\n *\r\n * ```ts\r\n * const control = new FormControl({ value: 'n/a', disabled: true });\r\n * console.log(control.value);     // 'n/a'\r\n * console.log(control.status);    // 'DISABLED'\r\n * ```\r\n *\r\n * The following example initializes the control with a synchronous validator.\r\n *\r\n * ```ts\r\n * const control = new FormControl('', Validators.required);\r\n * console.log(control.value);      // ''\r\n * console.log(control.status);     // 'INVALID'\r\n * ```\r\n *\r\n * The following example initializes the control using an options object.\r\n *\r\n * ```ts\r\n * const control = new FormControl('', {\r\n *    validators: Validators.required,\r\n *    asyncValidators: myAsyncValidator\r\n * });\r\n * ```\r\n *\r\n * ### Configure the control to update on a blur event\r\n *\r\n * Set the `updateOn` option to `'blur'` to update on the blur `event`.\r\n *\r\n * ```ts\r\n * const control = new FormControl('', { updateOn: 'blur' });\r\n * ```\r\n *\r\n * ### Configure the control to update on a submit event\r\n *\r\n * Set the `updateOn` option to `'submit'` to update on a submit `event`.\r\n *\r\n * ```ts\r\n * const control = new FormControl('', { updateOn: 'submit' });\r\n * ```\r\n *\r\n * ### Reset the control back to an initial value\r\n *\r\n * You reset to a specific form state by passing through a standalone\r\n * value or a form state object that contains both a value and a disabled state\r\n * (these are the only two properties that cannot be calculated).\r\n *\r\n * ```ts\r\n * const control = new FormControl('Nancy');\r\n *\r\n * console.log(control.value); // 'Nancy'\r\n *\r\n * control.reset('Drew');\r\n *\r\n * console.log(control.value); // 'Drew'\r\n * ```\r\n *\r\n * ### Reset the control back to an initial value and disabled\r\n *\r\n * ```\r\n * const control = new FormControl('Nancy');\r\n *\r\n * console.log(control.value); // 'Nancy'\r\n * console.log(control.status); // 'VALID'\r\n *\r\n * control.reset({ value: 'Drew', disabled: true });\r\n *\r\n * console.log(control.value); // 'Drew'\r\n * console.log(control.status); // 'DISABLED'\r\n * ```\r\n *\r\n * @publicApi\r\n */\r\nexport declare class FormControl extends AbstractControl {\r\n    /**\r\n     * Creates a new `FormControl` instance.\r\n     *\r\n     * @param formState Initializes the control with an initial value,\r\n     * or an object that defines the initial value and disabled state.\r\n     *\r\n     * @param validatorOrOpts A synchronous validator function, or an array of\r\n     * such functions, or an `AbstractControlOptions` object that contains validation functions\r\n     * and a validation trigger.\r\n     *\r\n     * @param asyncValidator A single async validator or array of async validator functions\r\n     *\r\n     */\r\n    constructor(formState?: any, validatorOrOpts?: ValidatorFn | ValidatorFn[] | AbstractControlOptions | null, asyncValidator?: AsyncValidatorFn | AsyncValidatorFn[] | null);\r\n    /**\r\n     * Sets a new value for the form control.\r\n     *\r\n     * @param value The new value for the control.\r\n     * @param options Configuration options that determine how the control propagates changes\r\n     * and emits events when the value changes.\r\n     * The configuration options are passed to the {@link AbstractControl#updateValueAndValidity\r\n     * updateValueAndValidity} method.\r\n     *\r\n     * * `onlySelf`: When true, each change only affects this control, and not its parent. Default is\r\n     * false.\r\n     * * `emitEvent`: When true or not supplied (the default), both the `statusChanges` and\r\n     * `valueChanges`\r\n     * observables emit events with the latest status and value when the control value is updated.\r\n     * When false, no events are emitted.\r\n     * * `emitModelToViewChange`: When true or not supplied  (the default), each change triggers an\r\n     * `onChange` event to\r\n     * update the view.\r\n     * * `emitViewToModelChange`: When true or not supplied (the default), each change triggers an\r\n     * `ngModelChange`\r\n     * event to update the model.\r\n     *\r\n     */\r\n    setValue(value: any, options?: {\r\n        onlySelf?: boolean;\r\n        emitEvent?: boolean;\r\n        emitModelToViewChange?: boolean;\r\n        emitViewToModelChange?: boolean;\r\n    }): void;\r\n    /**\r\n     * Patches the value of a control.\r\n     *\r\n     * This function is functionally the same as {@link FormControl#setValue setValue} at this level.\r\n     * It exists for symmetry with {@link FormGroup#patchValue patchValue} on `FormGroups` and\r\n     * `FormArrays`, where it does behave differently.\r\n     *\r\n     * @see `setValue` for options\r\n     */\r\n    patchValue(value: any, options?: {\r\n        onlySelf?: boolean;\r\n        emitEvent?: boolean;\r\n        emitModelToViewChange?: boolean;\r\n        emitViewToModelChange?: boolean;\r\n    }): void;\r\n    /**\r\n     * Resets the form control, marking it `pristine` and `untouched`, and setting\r\n     * the value to null.\r\n     *\r\n     * @param formState Resets the control with an initial value,\r\n     * or an object that defines the initial value and disabled state.\r\n     *\r\n     * @param options Configuration options that determine how the control propagates changes\r\n     * and emits events after the value changes.\r\n     *\r\n     * * `onlySelf`: When true, each change only affects this control, and not its parent. Default is\r\n     * false.\r\n     * * `emitEvent`: When true or not supplied (the default), both the `statusChanges` and\r\n     * `valueChanges`\r\n     * observables emit events with the latest status and value when the control is reset.\r\n     * When false, no events are emitted.\r\n     *\r\n     */\r\n    reset(formState?: any, options?: {\r\n        onlySelf?: boolean;\r\n        emitEvent?: boolean;\r\n    }): void;\r\n    /**\r\n     * Register a listener for change events.\r\n     *\r\n     * @param fn The method that is called when the value changes\r\n     */\r\n    registerOnChange(fn: Function): void;\r\n    /**\r\n     * Register a listener for disabled events.\r\n     *\r\n     * @param fn The method that is called when the disabled status changes.\r\n     */\r\n    registerOnDisabledChange(fn: (isDisabled: boolean) => void): void;\r\n    private _applyFormState;\r\n}\r\n\r\n/**\r\n * @description\r\n * Synchronizes a standalone `FormControl` instance to a form control element.\r\n *\r\n * Note that support for using the `ngModel` input property and `ngModelChange` event with reactive\r\n * form directives was deprecated in Angular v6 and is scheduled for removal in\r\n * a future version of Angular.\r\n * For details, see [Deprecated features](guide/deprecations#ngmodel-with-reactive-forms).\r\n *\r\n * @see [Reactive Forms Guide](guide/reactive-forms)\r\n * @see `FormControl`\r\n * @see `AbstractControl`\r\n *\r\n * @usageNotes\r\n *\r\n * The following example shows how to register a standalone control and set its value.\r\n *\r\n * {@example forms/ts/simpleFormControl/simple_form_control_example.ts region='Component'}\r\n *\r\n * @ngModule ReactiveFormsModule\r\n * @publicApi\r\n */\r\nexport declare class FormControlDirective extends NgControl implements OnChanges, OnDestroy {\r\n    private _ngModelWarningConfig;\r\n    /**\r\n     * Internal reference to the view model value.\r\n     * @nodoc\r\n     */\r\n    viewModel: any;\r\n    /**\r\n     * @description\r\n     * Tracks the `FormControl` instance bound to the directive.\r\n     */\r\n    form: FormControl;\r\n    /**\r\n     * @description\r\n     * Triggers a warning in dev mode that this input should not be used with reactive forms.\r\n     */\r\n    set isDisabled(isDisabled: boolean);\r\n    /** @deprecated as of v6 */\r\n    model: any;\r\n    /** @deprecated as of v6 */\r\n    update: EventEmitter<any>;\r\n    constructor(validators: (Validator | ValidatorFn)[], asyncValidators: (AsyncValidator | AsyncValidatorFn)[], valueAccessors: ControlValueAccessor[], _ngModelWarningConfig: string | null);\r\n    /** @nodoc */\r\n    ngOnChanges(changes: SimpleChanges): void;\r\n    /** @nodoc */\r\n    ngOnDestroy(): void;\r\n    /**\r\n     * @description\r\n     * Returns an array that represents the path from the top-level form to this control.\r\n     * Each index is the string name of the control on that level.\r\n     */\r\n    get path(): string[];\r\n    /**\r\n     * @description\r\n     * The `FormControl` bound to this directive.\r\n     */\r\n    get control(): FormControl;\r\n    /**\r\n     * @description\r\n     * Sets the new value for the view model and emits an `ngModelChange` event.\r\n     *\r\n     * @param newValue The new value for the view model.\r\n     */\r\n    viewToModelUpdate(newValue: any): void;\r\n    private _isControlChanged;\r\n}\r\n\r\n/**\r\n * @description\r\n * Syncs a `FormControl` in an existing `FormGroup` to a form control\r\n * element by name.\r\n *\r\n * @see [Reactive Forms Guide](guide/reactive-forms)\r\n * @see `FormControl`\r\n * @see `AbstractControl`\r\n *\r\n * @usageNotes\r\n *\r\n * ### Register `FormControl` within a group\r\n *\r\n * The following example shows how to register multiple form controls within a form group\r\n * and set their value.\r\n *\r\n * {@example forms/ts/simpleFormGroup/simple_form_group_example.ts region='Component'}\r\n *\r\n * To see `formControlName` examples with different form control types, see:\r\n *\r\n * * Radio buttons: `RadioControlValueAccessor`\r\n * * Selects: `SelectControlValueAccessor`\r\n *\r\n * ### Use with ngModel is deprecated\r\n *\r\n * Support for using the `ngModel` input property and `ngModelChange` event with reactive\r\n * form directives has been deprecated in Angular v6 and is scheduled for removal in\r\n * a future version of Angular.\r\n *\r\n * For details, see [Deprecated features](guide/deprecations#ngmodel-with-reactive-forms).\r\n *\r\n * @ngModule ReactiveFormsModule\r\n * @publicApi\r\n */\r\nexport declare class FormControlName extends NgControl implements OnChanges, OnDestroy {\r\n    private _ngModelWarningConfig;\r\n    private _added;\r\n    /**\r\n     * @description\r\n     * Tracks the `FormControl` instance bound to the directive.\r\n     */\r\n    readonly control: FormControl;\r\n    /**\r\n     * @description\r\n     * Tracks the name of the `FormControl` bound to the directive. The name corresponds\r\n     * to a key in the parent `FormGroup` or `FormArray`.\r\n     * Accepts a name as a string or a number.\r\n     * The name in the form of a string is useful for individual forms,\r\n     * while the numerical form allows for form controls to be bound\r\n     * to indices when iterating over controls in a `FormArray`.\r\n     */\r\n    name: string | number | null;\r\n    /**\r\n     * @description\r\n     * Triggers a warning in dev mode that this input should not be used with reactive forms.\r\n     */\r\n    set isDisabled(isDisabled: boolean);\r\n    /** @deprecated as of v6 */\r\n    model: any;\r\n    /** @deprecated as of v6 */\r\n    update: EventEmitter<any>;\r\n    constructor(parent: ControlContainer, validators: (Validator | ValidatorFn)[], asyncValidators: (AsyncValidator | AsyncValidatorFn)[], valueAccessors: ControlValueAccessor[], _ngModelWarningConfig: string | null);\r\n    /** @nodoc */\r\n    ngOnChanges(changes: SimpleChanges): void;\r\n    /** @nodoc */\r\n    ngOnDestroy(): void;\r\n    /**\r\n     * @description\r\n     * Sets the new value for the view model and emits an `ngModelChange` event.\r\n     *\r\n     * @param newValue The new value for the view model.\r\n     */\r\n    viewToModelUpdate(newValue: any): void;\r\n    /**\r\n     * @description\r\n     * Returns an array that represents the path from the top-level form to this control.\r\n     * Each index is the string name of the control on that level.\r\n     */\r\n    get path(): string[];\r\n    /**\r\n     * @description\r\n     * The top-level directive for this group if present, otherwise null.\r\n     */\r\n    get formDirective(): any;\r\n    private _checkParentType;\r\n    private _setUpControl;\r\n}\r\n\r\n/**\r\n * Tracks the value and validity state of a group of `FormControl` instances.\r\n *\r\n * A `FormGroup` aggregates the values of each child `FormControl` into one object,\r\n * with each control name as the key.  It calculates its status by reducing the status values\r\n * of its children. For example, if one of the controls in a group is invalid, the entire\r\n * group becomes invalid.\r\n *\r\n * `FormGroup` is one of the three fundamental building blocks used to define forms in Angular,\r\n * along with `FormControl` and `FormArray`.\r\n *\r\n * When instantiating a `FormGroup`, pass in a collection of child controls as the first\r\n * argument. The key for each child registers the name for the control.\r\n *\r\n * @usageNotes\r\n *\r\n * ### Create a form group with 2 controls\r\n *\r\n * ```\r\n * const form = new FormGroup({\r\n *   first: new FormControl('Nancy', Validators.minLength(2)),\r\n *   last: new FormControl('Drew'),\r\n * });\r\n *\r\n * console.log(form.value);   // {first: 'Nancy', last; 'Drew'}\r\n * console.log(form.status);  // 'VALID'\r\n * ```\r\n *\r\n * ### Create a form group with a group-level validator\r\n *\r\n * You include group-level validators as the second arg, or group-level async\r\n * validators as the third arg. These come in handy when you want to perform validation\r\n * that considers the value of more than one child control.\r\n *\r\n * ```\r\n * const form = new FormGroup({\r\n *   password: new FormControl('', Validators.minLength(2)),\r\n *   passwordConfirm: new FormControl('', Validators.minLength(2)),\r\n * }, passwordMatchValidator);\r\n *\r\n *\r\n * function passwordMatchValidator(g: FormGroup) {\r\n *    return g.get('password').value === g.get('passwordConfirm').value\r\n *       ? null : {'mismatch': true};\r\n * }\r\n * ```\r\n *\r\n * Like `FormControl` instances, you choose to pass in\r\n * validators and async validators as part of an options object.\r\n *\r\n * ```\r\n * const form = new FormGroup({\r\n *   password: new FormControl('')\r\n *   passwordConfirm: new FormControl('')\r\n * }, { validators: passwordMatchValidator, asyncValidators: otherValidator });\r\n * ```\r\n *\r\n * ### Set the updateOn property for all controls in a form group\r\n *\r\n * The options object is used to set a default value for each child\r\n * control's `updateOn` property. If you set `updateOn` to `'blur'` at the\r\n * group level, all child controls default to 'blur', unless the child\r\n * has explicitly specified a different `updateOn` value.\r\n *\r\n * ```ts\r\n * const c = new FormGroup({\r\n *   one: new FormControl()\r\n * }, { updateOn: 'blur' });\r\n * ```\r\n *\r\n * @publicApi\r\n */\r\nexport declare class FormGroup extends AbstractControl {\r\n    controls: {\r\n        [key: string]: AbstractControl;\r\n    };\r\n    /**\r\n     * Creates a new `FormGroup` instance.\r\n     *\r\n     * @param controls A collection of child controls. The key for each child is the name\r\n     * under which it is registered.\r\n     *\r\n     * @param validatorOrOpts A synchronous validator function, or an array of\r\n     * such functions, or an `AbstractControlOptions` object that contains validation functions\r\n     * and a validation trigger.\r\n     *\r\n     * @param asyncValidator A single async validator or array of async validator functions\r\n     *\r\n     */\r\n    constructor(controls: {\r\n        [key: string]: AbstractControl;\r\n    }, validatorOrOpts?: ValidatorFn | ValidatorFn[] | AbstractControlOptions | null, asyncValidator?: AsyncValidatorFn | AsyncValidatorFn[] | null);\r\n    /**\r\n     * Registers a control with the group's list of controls.\r\n     *\r\n     * This method does not update the value or validity of the control.\r\n     * Use {@link FormGroup#addControl addControl} instead.\r\n     *\r\n     * @param name The control name to register in the collection\r\n     * @param control Provides the control for the given name\r\n     */\r\n    registerControl(name: string, control: AbstractControl): AbstractControl;\r\n    /**\r\n     * Add a control to this group.\r\n     *\r\n     * If a control with a given name already exists, it would *not* be replaced with a new one.\r\n     * If you want to replace an existing control, use the {@link FormGroup#setControl setControl}\r\n     * method instead. This method also updates the value and validity of the control.\r\n     *\r\n     * @param name The control name to add to the collection\r\n     * @param control Provides the control for the given name\r\n     * @param options Specifies whether this FormGroup instance should emit events after a new\r\n     *     control is added.\r\n     * * `emitEvent`: When true or not supplied (the default), both the `statusChanges` and\r\n     * `valueChanges` observables emit events with the latest status and value when the control is\r\n     * added. When false, no events are emitted.\r\n     */\r\n    addControl(name: string, control: AbstractControl, options?: {\r\n        emitEvent?: boolean;\r\n    }): void;\r\n    /**\r\n     * Remove a control from this group.\r\n     *\r\n     * This method also updates the value and validity of the control.\r\n     *\r\n     * @param name The control name to remove from the collection\r\n     * @param options Specifies whether this FormGroup instance should emit events after a\r\n     *     control is removed.\r\n     * * `emitEvent`: When true or not supplied (the default), both the `statusChanges` and\r\n     * `valueChanges` observables emit events with the latest status and value when the control is\r\n     * removed. When false, no events are emitted.\r\n     */\r\n    removeControl(name: string, options?: {\r\n        emitEvent?: boolean;\r\n    }): void;\r\n    /**\r\n     * Replace an existing control.\r\n     *\r\n     * If a control with a given name does not exist in this `FormGroup`, it will be added.\r\n     *\r\n     * @param name The control name to replace in the collection\r\n     * @param control Provides the control for the given name\r\n     * @param options Specifies whether this FormGroup instance should emit events after an\r\n     *     existing control is replaced.\r\n     * * `emitEvent`: When true or not supplied (the default), both the `statusChanges` and\r\n     * `valueChanges` observables emit events with the latest status and value when the control is\r\n     * replaced with a new one. When false, no events are emitted.\r\n     */\r\n    setControl(name: string, control: AbstractControl, options?: {\r\n        emitEvent?: boolean;\r\n    }): void;\r\n    /**\r\n     * Check whether there is an enabled control with the given name in the group.\r\n     *\r\n     * Reports false for disabled controls. If you'd like to check for existence in the group\r\n     * only, use {@link AbstractControl#get get} instead.\r\n     *\r\n     * @param controlName The control name to check for existence in the collection\r\n     *\r\n     * @returns false for disabled controls, true otherwise.\r\n     */\r\n    contains(controlName: string): boolean;\r\n    /**\r\n     * Sets the value of the `FormGroup`. It accepts an object that matches\r\n     * the structure of the group, with control names as keys.\r\n     *\r\n     * @usageNotes\r\n     * ### Set the complete value for the form group\r\n     *\r\n     * ```\r\n     * const form = new FormGroup({\r\n     *   first: new FormControl(),\r\n     *   last: new FormControl()\r\n     * });\r\n     *\r\n     * console.log(form.value);   // {first: null, last: null}\r\n     *\r\n     * form.setValue({first: 'Nancy', last: 'Drew'});\r\n     * console.log(form.value);   // {first: 'Nancy', last: 'Drew'}\r\n     * ```\r\n     *\r\n     * @throws When strict checks fail, such as setting the value of a control\r\n     * that doesn't exist or if you exclude a value of a control that does exist.\r\n     *\r\n     * @param value The new value for the control that matches the structure of the group.\r\n     * @param options Configuration options that determine how the control propagates changes\r\n     * and emits events after the value changes.\r\n     * The configuration options are passed to the {@link AbstractControl#updateValueAndValidity\r\n     * updateValueAndValidity} method.\r\n     *\r\n     * * `onlySelf`: When true, each change only affects this control, and not its parent. Default is\r\n     * false.\r\n     * * `emitEvent`: When true or not supplied (the default), both the `statusChanges` and\r\n     * `valueChanges`\r\n     * observables emit events with the latest status and value when the control value is updated.\r\n     * When false, no events are emitted.\r\n     */\r\n    setValue(value: {\r\n        [key: string]: any;\r\n    }, options?: {\r\n        onlySelf?: boolean;\r\n        emitEvent?: boolean;\r\n    }): void;\r\n    /**\r\n     * Patches the value of the `FormGroup`. It accepts an object with control\r\n     * names as keys, and does its best to match the values to the correct controls\r\n     * in the group.\r\n     *\r\n     * It accepts both super-sets and sub-sets of the group without throwing an error.\r\n     *\r\n     * @usageNotes\r\n     * ### Patch the value for a form group\r\n     *\r\n     * ```\r\n     * const form = new FormGroup({\r\n     *    first: new FormControl(),\r\n     *    last: new FormControl()\r\n     * });\r\n     * console.log(form.value);   // {first: null, last: null}\r\n     *\r\n     * form.patchValue({first: 'Nancy'});\r\n     * console.log(form.value);   // {first: 'Nancy', last: null}\r\n     * ```\r\n     *\r\n     * @param value The object that matches the structure of the group.\r\n     * @param options Configuration options that determine how the control propagates changes and\r\n     * emits events after the value is patched.\r\n     * * `onlySelf`: When true, each change only affects this control and not its parent. Default is\r\n     * true.\r\n     * * `emitEvent`: When true or not supplied (the default), both the `statusChanges` and\r\n     * `valueChanges` observables emit events with the latest status and value when the control value\r\n     * is updated. When false, no events are emitted. The configuration options are passed to\r\n     * the {@link AbstractControl#updateValueAndValidity updateValueAndValidity} method.\r\n     */\r\n    patchValue(value: {\r\n        [key: string]: any;\r\n    }, options?: {\r\n        onlySelf?: boolean;\r\n        emitEvent?: boolean;\r\n    }): void;\r\n    /**\r\n     * Resets the `FormGroup`, marks all descendants `pristine` and `untouched` and sets\r\n     * the value of all descendants to null.\r\n     *\r\n     * You reset to a specific form state by passing in a map of states\r\n     * that matches the structure of your form, with control names as keys. The state\r\n     * is a standalone value or a form state object with both a value and a disabled\r\n     * status.\r\n     *\r\n     * @param value Resets the control with an initial value,\r\n     * or an object that defines the initial value and disabled state.\r\n     *\r\n     * @param options Configuration options that determine how the control propagates changes\r\n     * and emits events when the group is reset.\r\n     * * `onlySelf`: When true, each change only affects this control, and not its parent. Default is\r\n     * false.\r\n     * * `emitEvent`: When true or not supplied (the default), both the `statusChanges` and\r\n     * `valueChanges`\r\n     * observables emit events with the latest status and value when the control is reset.\r\n     * When false, no events are emitted.\r\n     * The configuration options are passed to the {@link AbstractControl#updateValueAndValidity\r\n     * updateValueAndValidity} method.\r\n     *\r\n     * @usageNotes\r\n     *\r\n     * ### Reset the form group values\r\n     *\r\n     * ```ts\r\n     * const form = new FormGroup({\r\n     *   first: new FormControl('first name'),\r\n     *   last: new FormControl('last name')\r\n     * });\r\n     *\r\n     * console.log(form.value);  // {first: 'first name', last: 'last name'}\r\n     *\r\n     * form.reset({ first: 'name', last: 'last name' });\r\n     *\r\n     * console.log(form.value);  // {first: 'name', last: 'last name'}\r\n     * ```\r\n     *\r\n     * ### Reset the form group values and disabled status\r\n     *\r\n     * ```\r\n     * const form = new FormGroup({\r\n     *   first: new FormControl('first name'),\r\n     *   last: new FormControl('last name')\r\n     * });\r\n     *\r\n     * form.reset({\r\n     *   first: {value: 'name', disabled: true},\r\n     *   last: 'last'\r\n     * });\r\n     *\r\n     * console.log(form.value);  // {last: 'last'}\r\n     * console.log(form.get('first').status);  // 'DISABLED'\r\n     * ```\r\n     */\r\n    reset(value?: any, options?: {\r\n        onlySelf?: boolean;\r\n        emitEvent?: boolean;\r\n    }): void;\r\n    /**\r\n     * The aggregate value of the `FormGroup`, including any disabled controls.\r\n     *\r\n     * Retrieves all values regardless of disabled status.\r\n     * The `value` property is the best way to get the value of the group, because\r\n     * it excludes disabled controls in the `FormGroup`.\r\n     */\r\n    getRawValue(): any;\r\n}\r\n\r\n/**\r\n * @description\r\n *\r\n * Binds an existing `FormGroup` to a DOM element.\r\n *\r\n * This directive accepts an existing `FormGroup` instance. It will then use this\r\n * `FormGroup` instance to match any child `FormControl`, `FormGroup`,\r\n * and `FormArray` instances to child `FormControlName`, `FormGroupName`,\r\n * and `FormArrayName` directives.\r\n *\r\n * @see [Reactive Forms Guide](guide/reactive-forms)\r\n * @see `AbstractControl`\r\n *\r\n * @usageNotes\r\n * ### Register Form Group\r\n *\r\n * The following example registers a `FormGroup` with first name and last name controls,\r\n * and listens for the *ngSubmit* event when the button is clicked.\r\n *\r\n * {@example forms/ts/simpleFormGroup/simple_form_group_example.ts region='Component'}\r\n *\r\n * @ngModule ReactiveFormsModule\r\n * @publicApi\r\n */\r\nexport declare class FormGroupDirective extends ControlContainer implements Form, OnChanges, OnDestroy {\r\n    private validators;\r\n    private asyncValidators;\r\n    /**\r\n     * @description\r\n     * Reports whether the form submission has been triggered.\r\n     */\r\n    readonly submitted: boolean;\r\n    /**\r\n     * Reference to an old form group input value, which is needed to cleanup old instance in case it\r\n     * was replaced with a new one.\r\n     */\r\n    private _oldForm;\r\n    /**\r\n     * Callback that should be invoked when controls in FormGroup or FormArray collection change\r\n     * (added or removed). This callback triggers corresponding DOM updates.\r\n     */\r\n    private readonly _onCollectionChange;\r\n    /**\r\n     * @description\r\n     * Tracks the list of added `FormControlName` instances\r\n     */\r\n    directives: FormControlName[];\r\n    /**\r\n     * @description\r\n     * Tracks the `FormGroup` bound to this directive.\r\n     */\r\n    form: FormGroup;\r\n    /**\r\n     * @description\r\n     * Emits an event when the form submission has been triggered.\r\n     */\r\n    ngSubmit: EventEmitter<any>;\r\n    constructor(validators: (Validator | ValidatorFn)[], asyncValidators: (AsyncValidator | AsyncValidatorFn)[]);\r\n    /** @nodoc */\r\n    ngOnChanges(changes: SimpleChanges): void;\r\n    /** @nodoc */\r\n    ngOnDestroy(): void;\r\n    /**\r\n     * @description\r\n     * Returns this directive's instance.\r\n     */\r\n    get formDirective(): Form;\r\n    /**\r\n     * @description\r\n     * Returns the `FormGroup` bound to this directive.\r\n     */\r\n    get control(): FormGroup;\r\n    /**\r\n     * @description\r\n     * Returns an array representing the path to this group. Because this directive\r\n     * always lives at the top level of a form, it always an empty array.\r\n     */\r\n    get path(): string[];\r\n    /**\r\n     * @description\r\n     * Method that sets up the control directive in this group, re-calculates its value\r\n     * and validity, and adds the instance to the internal list of directives.\r\n     *\r\n     * @param dir The `FormControlName` directive instance.\r\n     */\r\n    addControl(dir: FormControlName): FormControl;\r\n    /**\r\n     * @description\r\n     * Retrieves the `FormControl` instance from the provided `FormControlName` directive\r\n     *\r\n     * @param dir The `FormControlName` directive instance.\r\n     */\r\n    getControl(dir: FormControlName): FormControl;\r\n    /**\r\n     * @description\r\n     * Removes the `FormControlName` instance from the internal list of directives\r\n     *\r\n     * @param dir The `FormControlName` directive instance.\r\n     */\r\n    removeControl(dir: FormControlName): void;\r\n    /**\r\n     * Adds a new `FormGroupName` directive instance to the form.\r\n     *\r\n     * @param dir The `FormGroupName` directive instance.\r\n     */\r\n    addFormGroup(dir: FormGroupName): void;\r\n    /**\r\n     * Performs the necessary cleanup when a `FormGroupName` directive instance is removed from the\r\n     * view.\r\n     *\r\n     * @param dir The `FormGroupName` directive instance.\r\n     */\r\n    removeFormGroup(dir: FormGroupName): void;\r\n    /**\r\n     * @description\r\n     * Retrieves the `FormGroup` for a provided `FormGroupName` directive instance\r\n     *\r\n     * @param dir The `FormGroupName` directive instance.\r\n     */\r\n    getFormGroup(dir: FormGroupName): FormGroup;\r\n    /**\r\n     * Performs the necessary setup when a `FormArrayName` directive instance is added to the view.\r\n     *\r\n     * @param dir The `FormArrayName` directive instance.\r\n     */\r\n    addFormArray(dir: FormArrayName): void;\r\n    /**\r\n     * Performs the necessary cleanup when a `FormArrayName` directive instance is removed from the\r\n     * view.\r\n     *\r\n     * @param dir The `FormArrayName` directive instance.\r\n     */\r\n    removeFormArray(dir: FormArrayName): void;\r\n    /**\r\n     * @description\r\n     * Retrieves the `FormArray` for a provided `FormArrayName` directive instance.\r\n     *\r\n     * @param dir The `FormArrayName` directive instance.\r\n     */\r\n    getFormArray(dir: FormArrayName): FormArray;\r\n    /**\r\n     * Sets the new value for the provided `FormControlName` directive.\r\n     *\r\n     * @param dir The `FormControlName` directive instance.\r\n     * @param value The new value for the directive's control.\r\n     */\r\n    updateModel(dir: FormControlName, value: any): void;\r\n    /**\r\n     * @description\r\n     * Method called with the \"submit\" event is triggered on the form.\r\n     * Triggers the `ngSubmit` emitter to emit the \"submit\" event as its payload.\r\n     *\r\n     * @param $event The \"submit\" event object\r\n     */\r\n    onSubmit($event: Event): boolean;\r\n    /**\r\n     * @description\r\n     * Method called when the \"reset\" event is triggered on the form.\r\n     */\r\n    onReset(): void;\r\n    /**\r\n     * @description\r\n     * Resets the form to an initial value and resets its submitted status.\r\n     *\r\n     * @param value The new value for the form.\r\n     */\r\n    resetForm(value?: any): void;\r\n    private _setUpFormContainer;\r\n    private _cleanUpFormContainer;\r\n    private _updateRegistrations;\r\n    private _updateValidators;\r\n    private _checkFormPresent;\r\n}\r\n\r\n/**\r\n * @description\r\n *\r\n * Syncs a nested `FormGroup` to a DOM element.\r\n *\r\n * This directive can only be used with a parent `FormGroupDirective`.\r\n *\r\n * It accepts the string name of the nested `FormGroup` to link, and\r\n * looks for a `FormGroup` registered with that name in the parent\r\n * `FormGroup` instance you passed into `FormGroupDirective`.\r\n *\r\n * Use nested form groups to validate a sub-group of a\r\n * form separately from the rest or to group the values of certain\r\n * controls into their own nested object.\r\n *\r\n * @see [Reactive Forms Guide](guide/reactive-forms)\r\n *\r\n * @usageNotes\r\n *\r\n * ### Access the group by name\r\n *\r\n * The following example uses the {@link AbstractControl#get get} method to access the\r\n * associated `FormGroup`\r\n *\r\n * ```ts\r\n *   this.form.get('name');\r\n * ```\r\n *\r\n * ### Access individual controls in the group\r\n *\r\n * The following example uses the {@link AbstractControl#get get} method to access\r\n * individual controls within the group using dot syntax.\r\n *\r\n * ```ts\r\n *   this.form.get('name.first');\r\n * ```\r\n *\r\n * ### Register a nested `FormGroup`.\r\n *\r\n * The following example registers a nested *name* `FormGroup` within an existing `FormGroup`,\r\n * and provides methods to retrieve the nested `FormGroup` and individual controls.\r\n *\r\n * {@example forms/ts/nestedFormGroup/nested_form_group_example.ts region='Component'}\r\n *\r\n * @ngModule ReactiveFormsModule\r\n * @publicApi\r\n */\r\nexport declare class FormGroupName extends AbstractFormGroupDirective implements OnInit, OnDestroy {\r\n    /**\r\n     * @description\r\n     * Tracks the name of the `FormGroup` bound to the directive. The name corresponds\r\n     * to a key in the parent `FormGroup` or `FormArray`.\r\n     * Accepts a name as a string or a number.\r\n     * The name in the form of a string is useful for individual forms,\r\n     * while the numerical form allows for form groups to be bound\r\n     * to indices when iterating over groups in a `FormArray`.\r\n     */\r\n    name: string | number | null;\r\n    constructor(parent: ControlContainer, validators: (Validator | ValidatorFn)[], asyncValidators: (AsyncValidator | AsyncValidatorFn)[]);\r\n}\r\n\r\ndeclare type FormHooks = 'change' | 'blur' | 'submit';\r\n\r\n/**\r\n * Exports the required providers and directives for template-driven forms,\r\n * making them available for import by NgModules that import this module.\r\n *\r\n * Providers associated with this module:\r\n * * `RadioControlRegistry`\r\n *\r\n * @see [Forms Overview](/guide/forms-overview)\r\n * @see [Template-driven Forms Guide](/guide/forms)\r\n *\r\n * @publicApi\r\n */\r\nexport declare class FormsModule {\r\n}\r\n\r\n/**\r\n * A directive that adds max length validation to controls marked with the\r\n * `maxlength` attribute. The directive is provided with the `NG_VALIDATORS` multi-provider list.\r\n *\r\n * @see [Form Validation](guide/form-validation)\r\n *\r\n * @usageNotes\r\n *\r\n * ### Adding a maximum length validator\r\n *\r\n * The following example shows how to add a maximum length validator to an input attached to an\r\n * ngModel binding.\r\n *\r\n * ```html\r\n * <input name=\"firstName\" ngModel maxlength=\"25\">\r\n * ```\r\n *\r\n * @ngModule ReactiveFormsModule\r\n * @ngModule FormsModule\r\n * @publicApi\r\n */\r\nexport declare class MaxLengthValidator implements Validator, OnChanges {\r\n    private _validator;\r\n    private _onChange?;\r\n    /**\r\n     * @description\r\n     * Tracks changes to the maximum length bound to this directive.\r\n     */\r\n    maxlength: string | number | null;\r\n    /** @nodoc */\r\n    ngOnChanges(changes: SimpleChanges): void;\r\n    /**\r\n     * Method that validates whether the value exceeds the maximum length requirement.\r\n     * @nodoc\r\n     */\r\n    validate(control: AbstractControl): ValidationErrors | null;\r\n    /**\r\n     * Registers a callback function to call when the validator inputs change.\r\n     * @nodoc\r\n     */\r\n    registerOnValidatorChange(fn: () => void): void;\r\n    private _createValidator;\r\n    /** @nodoc */\r\n    enabled(): boolean;\r\n}\r\n\r\n/**\r\n * A directive which installs the {@link MaxValidator} for any `formControlName`,\r\n * `formControl`, or control with `ngModel` that also has a `max` attribute.\r\n *\r\n * @see [Form Validation](guide/form-validation)\r\n *\r\n * @usageNotes\r\n *\r\n * ### Adding a max validator\r\n *\r\n * The following example shows how to add a max validator to an input attached to an\r\n * ngModel binding.\r\n *\r\n * ```html\r\n * <input type=\"number\" ngModel max=\"4\">\r\n * ```\r\n *\r\n * @ngModule ReactiveFormsModule\r\n * @ngModule FormsModule\r\n * @publicApi\r\n */\r\nexport declare class MaxValidator extends AbstractValidatorDirective implements OnChanges {\r\n    /**\r\n     * @description\r\n     * Tracks changes to the max bound to this directive.\r\n     */\r\n    max: string | number;\r\n    /**\r\n     * Declare `ngOnChanges` lifecycle hook at the main directive level (vs keeping it in base class)\r\n     * to avoid differences in handling inheritance of lifecycle hooks between Ivy and ViewEngine in\r\n     * AOT mode. This could be refactored once ViewEngine is removed.\r\n     * @nodoc\r\n     */\r\n    ngOnChanges(changes: SimpleChanges): void;\r\n}\r\n\r\n/**\r\n * A directive that adds minimum length validation to controls marked with the\r\n * `minlength` attribute. The directive is provided with the `NG_VALIDATORS` multi-provider list.\r\n *\r\n * @see [Form Validation](guide/form-validation)\r\n *\r\n * @usageNotes\r\n *\r\n * ### Adding a minimum length validator\r\n *\r\n * The following example shows how to add a minimum length validator to an input attached to an\r\n * ngModel binding.\r\n *\r\n * ```html\r\n * <input name=\"firstName\" ngModel minlength=\"4\">\r\n * ```\r\n *\r\n * @ngModule ReactiveFormsModule\r\n * @ngModule FormsModule\r\n * @publicApi\r\n */\r\nexport declare class MinLengthValidator implements Validator, OnChanges {\r\n    private _validator;\r\n    private _onChange?;\r\n    /**\r\n     * @description\r\n     * Tracks changes to the minimum length bound to this directive.\r\n     */\r\n    minlength: string | number | null;\r\n    /** @nodoc */\r\n    ngOnChanges(changes: SimpleChanges): void;\r\n    /**\r\n     * Method that validates whether the value meets a minimum length requirement.\r\n     * Returns the validation result if enabled, otherwise null.\r\n     * @nodoc\r\n     */\r\n    validate(control: AbstractControl): ValidationErrors | null;\r\n    /**\r\n     * Registers a callback function to call when the validator inputs change.\r\n     * @nodoc\r\n     */\r\n    registerOnValidatorChange(fn: () => void): void;\r\n    private _createValidator;\r\n    /** @nodoc */\r\n    enabled(): boolean;\r\n}\r\n\r\n/**\r\n * A directive which installs the {@link MinValidator} for any `formControlName`,\r\n * `formControl`, or control with `ngModel` that also has a `min` attribute.\r\n *\r\n * @see [Form Validation](guide/form-validation)\r\n *\r\n * @usageNotes\r\n *\r\n * ### Adding a min validator\r\n *\r\n * The following example shows how to add a min validator to an input attached to an\r\n * ngModel binding.\r\n *\r\n * ```html\r\n * <input type=\"number\" ngModel min=\"4\">\r\n * ```\r\n *\r\n * @ngModule ReactiveFormsModule\r\n * @ngModule FormsModule\r\n * @publicApi\r\n */\r\nexport declare class MinValidator extends AbstractValidatorDirective implements OnChanges {\r\n    /**\r\n     * @description\r\n     * Tracks changes to the min bound to this directive.\r\n     */\r\n    min: string | number;\r\n    /**\r\n     * Declare `ngOnChanges` lifecycle hook at the main directive level (vs keeping it in base class)\r\n     * to avoid differences in handling inheritance of lifecycle hooks between Ivy and ViewEngine in\r\n     * AOT mode. This could be refactored once ViewEngine is removed.\r\n     * @nodoc\r\n     */\r\n    ngOnChanges(changes: SimpleChanges): void;\r\n}\r\n\r\n/**\r\n * @description\r\n * An `InjectionToken` for registering additional asynchronous validators used with\r\n * `AbstractControl`s.\r\n *\r\n * @see `NG_VALIDATORS`\r\n *\r\n * @publicApi\r\n */\r\nexport declare const NG_ASYNC_VALIDATORS: InjectionToken<(Function | Validator)[]>;\r\n\r\n/**\r\n * @description\r\n * An `InjectionToken` for registering additional synchronous validators used with\r\n * `AbstractControl`s.\r\n *\r\n * @see `NG_ASYNC_VALIDATORS`\r\n *\r\n * @usageNotes\r\n *\r\n * ### Providing a custom validator\r\n *\r\n * The following example registers a custom validator directive. Adding the validator to the\r\n * existing collection of validators requires the `multi: true` option.\r\n *\r\n * ```typescript\r\n * @Directive({\r\n *   selector: '[customValidator]',\r\n *   providers: [{provide: NG_VALIDATORS, useExisting: CustomValidatorDirective, multi: true}]\r\n * })\r\n * class CustomValidatorDirective implements Validator {\r\n *   validate(control: AbstractControl): ValidationErrors | null {\r\n *     return { 'custom': true };\r\n *   }\r\n * }\r\n * ```\r\n *\r\n * @publicApi\r\n */\r\nexport declare const NG_VALIDATORS: InjectionToken<(Function | Validator)[]>;\r\n\r\n/**\r\n * Used to provide a `ControlValueAccessor` for form controls.\r\n *\r\n * See `DefaultValueAccessor` for how to implement one.\r\n *\r\n * @publicApi\r\n */\r\nexport declare const NG_VALUE_ACCESSOR: InjectionToken<readonly ControlValueAccessor[]>;\r\n\r\n/**\r\n * @description\r\n * A base class that all `FormControl`-based directives extend. It binds a `FormControl`\r\n * object to a DOM element.\r\n *\r\n * @publicApi\r\n */\r\nexport declare abstract class NgControl extends AbstractControlDirective {\r\n    /**\r\n     * @description\r\n     * The name for the control\r\n     */\r\n    name: string | number | null;\r\n    /**\r\n     * @description\r\n     * The value accessor for the control\r\n     */\r\n    valueAccessor: ControlValueAccessor | null;\r\n    /**\r\n     * @description\r\n     * The callback method to update the model from the view when requested\r\n     *\r\n     * @param newValue The new value for the view\r\n     */\r\n    abstract viewToModelUpdate(newValue: any): void;\r\n}\r\n\r\n/**\r\n * @description\r\n * Directive automatically applied to Angular form controls that sets CSS classes\r\n * based on control status.\r\n *\r\n * @usageNotes\r\n *\r\n * ### CSS classes applied\r\n *\r\n * The following classes are applied as the properties become true:\r\n *\r\n * * ng-valid\r\n * * ng-invalid\r\n * * ng-pending\r\n * * ng-pristine\r\n * * ng-dirty\r\n * * ng-untouched\r\n * * ng-touched\r\n *\r\n * @ngModule ReactiveFormsModule\r\n * @ngModule FormsModule\r\n * @publicApi\r\n */\r\nexport declare class NgControlStatus extends ɵangular_packages_forms_forms_i {\r\n    constructor(cd: NgControl);\r\n}\r\n\r\n/**\r\n * @description\r\n * Directive automatically applied to Angular form groups that sets CSS classes\r\n * based on control status (valid/invalid/dirty/etc). On groups, this includes the additional\r\n * class ng-submitted.\r\n *\r\n * @see `NgControlStatus`\r\n *\r\n * @ngModule ReactiveFormsModule\r\n * @ngModule FormsModule\r\n * @publicApi\r\n */\r\nexport declare class NgControlStatusGroup extends ɵangular_packages_forms_forms_i {\r\n    constructor(cd: ControlContainer);\r\n}\r\n\r\n/**\r\n * @description\r\n * Creates a top-level `FormGroup` instance and binds it to a form\r\n * to track aggregate form value and validation status.\r\n *\r\n * As soon as you import the `FormsModule`, this directive becomes active by default on\r\n * all `<form>` tags.  You don't need to add a special selector.\r\n *\r\n * You optionally export the directive into a local template variable using `ngForm` as the key\r\n * (ex: `#myForm=\"ngForm\"`). This is optional, but useful.  Many properties from the underlying\r\n * `FormGroup` instance are duplicated on the directive itself, so a reference to it\r\n * gives you access to the aggregate value and validity status of the form, as well as\r\n * user interaction properties like `dirty` and `touched`.\r\n *\r\n * To register child controls with the form, use `NgModel` with a `name`\r\n * attribute. You may use `NgModelGroup` to create sub-groups within the form.\r\n *\r\n * If necessary, listen to the directive's `ngSubmit` event to be notified when the user has\r\n * triggered a form submission. The `ngSubmit` event emits the original form\r\n * submission event.\r\n *\r\n * In template driven forms, all `<form>` tags are automatically tagged as `NgForm`.\r\n * To import the `FormsModule` but skip its usage in some forms,\r\n * for example, to use native HTML5 validation, add the `ngNoForm` and the `<form>`\r\n * tags won't create an `NgForm` directive. In reactive forms, using `ngNoForm` is\r\n * unnecessary because the `<form>` tags are inert. In that case, you would\r\n * refrain from using the `formGroup` directive.\r\n *\r\n * @usageNotes\r\n *\r\n * ### Listening for form submission\r\n *\r\n * The following example shows how to capture the form values from the \"ngSubmit\" event.\r\n *\r\n * {@example forms/ts/simpleForm/simple_form_example.ts region='Component'}\r\n *\r\n * ### Setting the update options\r\n *\r\n * The following example shows you how to change the \"updateOn\" option from its default using\r\n * ngFormOptions.\r\n *\r\n * ```html\r\n * <form [ngFormOptions]=\"{updateOn: 'blur'}\">\r\n *    <input name=\"one\" ngModel>  <!-- this ngModel will update on blur -->\r\n * </form>\r\n * ```\r\n *\r\n * ### Native DOM validation UI\r\n *\r\n * In order to prevent the native DOM form validation UI from interfering with Angular's form\r\n * validation, Angular automatically adds the `novalidate` attribute on any `<form>` whenever\r\n * `FormModule` or `ReactiveFormModule` are imported into the application.\r\n * If you want to explicitly enable native DOM validation UI with Angular forms, you can add the\r\n * `ngNativeValidate` attribute to the `<form>` element:\r\n *\r\n * ```html\r\n * <form ngNativeValidate>\r\n *   ...\r\n * </form>\r\n * ```\r\n *\r\n * @ngModule FormsModule\r\n * @publicApi\r\n */\r\nexport declare class NgForm extends ControlContainer implements Form, AfterViewInit {\r\n    /**\r\n     * @description\r\n     * Returns whether the form submission has been triggered.\r\n     */\r\n    readonly submitted: boolean;\r\n    private _directives;\r\n    /**\r\n     * @description\r\n     * The `FormGroup` instance created for this form.\r\n     */\r\n    form: FormGroup;\r\n    /**\r\n     * @description\r\n     * Event emitter for the \"ngSubmit\" event\r\n     */\r\n    ngSubmit: EventEmitter<any>;\r\n    /**\r\n     * @description\r\n     * Tracks options for the `NgForm` instance.\r\n     *\r\n     * **updateOn**: Sets the default `updateOn` value for all child `NgModels` below it\r\n     * unless explicitly set by a child `NgModel` using `ngModelOptions`). Defaults to 'change'.\r\n     * Possible values: `'change'` | `'blur'` | `'submit'`.\r\n     *\r\n     */\r\n    options: {\r\n        updateOn?: FormHooks;\r\n    };\r\n    constructor(validators: (Validator | ValidatorFn)[], asyncValidators: (AsyncValidator | AsyncValidatorFn)[]);\r\n    /** @nodoc */\r\n    ngAfterViewInit(): void;\r\n    /**\r\n     * @description\r\n     * The directive instance.\r\n     */\r\n    get formDirective(): Form;\r\n    /**\r\n     * @description\r\n     * The internal `FormGroup` instance.\r\n     */\r\n    get control(): FormGroup;\r\n    /**\r\n     * @description\r\n     * Returns an array representing the path to this group. Because this directive\r\n     * always lives at the top level of a form, it is always an empty array.\r\n     */\r\n    get path(): string[];\r\n    /**\r\n     * @description\r\n     * Returns a map of the controls in this group.\r\n     */\r\n    get controls(): {\r\n        [key: string]: AbstractControl;\r\n    };\r\n    /**\r\n     * @description\r\n     * Method that sets up the control directive in this group, re-calculates its value\r\n     * and validity, and adds the instance to the internal list of directives.\r\n     *\r\n     * @param dir The `NgModel` directive instance.\r\n     */\r\n    addControl(dir: NgModel): void;\r\n    /**\r\n     * @description\r\n     * Retrieves the `FormControl` instance from the provided `NgModel` directive.\r\n     *\r\n     * @param dir The `NgModel` directive instance.\r\n     */\r\n    getControl(dir: NgModel): FormControl;\r\n    /**\r\n     * @description\r\n     * Removes the `NgModel` instance from the internal list of directives\r\n     *\r\n     * @param dir The `NgModel` directive instance.\r\n     */\r\n    removeControl(dir: NgModel): void;\r\n    /**\r\n     * @description\r\n     * Adds a new `NgModelGroup` directive instance to the form.\r\n     *\r\n     * @param dir The `NgModelGroup` directive instance.\r\n     */\r\n    addFormGroup(dir: NgModelGroup): void;\r\n    /**\r\n     * @description\r\n     * Removes the `NgModelGroup` directive instance from the form.\r\n     *\r\n     * @param dir The `NgModelGroup` directive instance.\r\n     */\r\n    removeFormGroup(dir: NgModelGroup): void;\r\n    /**\r\n     * @description\r\n     * Retrieves the `FormGroup` for a provided `NgModelGroup` directive instance\r\n     *\r\n     * @param dir The `NgModelGroup` directive instance.\r\n     */\r\n    getFormGroup(dir: NgModelGroup): FormGroup;\r\n    /**\r\n     * Sets the new value for the provided `NgControl` directive.\r\n     *\r\n     * @param dir The `NgControl` directive instance.\r\n     * @param value The new value for the directive's control.\r\n     */\r\n    updateModel(dir: NgControl, value: any): void;\r\n    /**\r\n     * @description\r\n     * Sets the value for this `FormGroup`.\r\n     *\r\n     * @param value The new value\r\n     */\r\n    setValue(value: {\r\n        [key: string]: any;\r\n    }): void;\r\n    /**\r\n     * @description\r\n     * Method called when the \"submit\" event is triggered on the form.\r\n     * Triggers the `ngSubmit` emitter to emit the \"submit\" event as its payload.\r\n     *\r\n     * @param $event The \"submit\" event object\r\n     */\r\n    onSubmit($event: Event): boolean;\r\n    /**\r\n     * @description\r\n     * Method called when the \"reset\" event is triggered on the form.\r\n     */\r\n    onReset(): void;\r\n    /**\r\n     * @description\r\n     * Resets the form to an initial value and resets its submitted status.\r\n     *\r\n     * @param value The new value for the form.\r\n     */\r\n    resetForm(value?: any): void;\r\n    private _setUpdateStrategy;\r\n}\r\n\r\n/**\r\n * @description\r\n * Creates a `FormControl` instance from a domain model and binds it\r\n * to a form control element.\r\n *\r\n * The `FormControl` instance tracks the value, user interaction, and\r\n * validation status of the control and keeps the view synced with the model. If used\r\n * within a parent form, the directive also registers itself with the form as a child\r\n * control.\r\n *\r\n * This directive is used by itself or as part of a larger form. Use the\r\n * `ngModel` selector to activate it.\r\n *\r\n * It accepts a domain model as an optional `Input`. If you have a one-way binding\r\n * to `ngModel` with `[]` syntax, changing the domain model's value in the component\r\n * class sets the value in the view. If you have a two-way binding with `[()]` syntax\r\n * (also known as 'banana-in-a-box syntax'), the value in the UI always syncs back to\r\n * the domain model in your class.\r\n *\r\n * To inspect the properties of the associated `FormControl` (like the validity state),\r\n * export the directive into a local template variable using `ngModel` as the key (ex:\r\n * `#myVar=\"ngModel\"`). You can then access the control using the directive's `control` property.\r\n * However, the most commonly used properties (like `valid` and `dirty`) also exist on the control\r\n * for direct access. See a full list of properties directly available in\r\n * `AbstractControlDirective`.\r\n *\r\n * @see `RadioControlValueAccessor`\r\n * @see `SelectControlValueAccessor`\r\n *\r\n * @usageNotes\r\n *\r\n * ### Using ngModel on a standalone control\r\n *\r\n * The following examples show a simple standalone control using `ngModel`:\r\n *\r\n * {@example forms/ts/simpleNgModel/simple_ng_model_example.ts region='Component'}\r\n *\r\n * When using the `ngModel` within `<form>` tags, you'll also need to supply a `name` attribute\r\n * so that the control can be registered with the parent form under that name.\r\n *\r\n * In the context of a parent form, it's often unnecessary to include one-way or two-way binding,\r\n * as the parent form syncs the value for you. You access its properties by exporting it into a\r\n * local template variable using `ngForm` such as (`#f=\"ngForm\"`). Use the variable where\r\n * needed on form submission.\r\n *\r\n * If you do need to populate initial values into your form, using a one-way binding for\r\n * `ngModel` tends to be sufficient as long as you use the exported form's value rather\r\n * than the domain model's value on submit.\r\n *\r\n * ### Using ngModel within a form\r\n *\r\n * The following example shows controls using `ngModel` within a form:\r\n *\r\n * {@example forms/ts/simpleForm/simple_form_example.ts region='Component'}\r\n *\r\n * ### Using a standalone ngModel within a group\r\n *\r\n * The following example shows you how to use a standalone ngModel control\r\n * within a form. This controls the display of the form, but doesn't contain form data.\r\n *\r\n * ```html\r\n * <form>\r\n *   <input name=\"login\" ngModel placeholder=\"Login\">\r\n *   <input type=\"checkbox\" ngModel [ngModelOptions]=\"{standalone: true}\"> Show more options?\r\n * </form>\r\n * <!-- form value: {login: ''} -->\r\n * ```\r\n *\r\n * ### Setting the ngModel `name` attribute through options\r\n *\r\n * The following example shows you an alternate way to set the name attribute. Here,\r\n * an attribute identified as name is used within a custom form control component. To still be able\r\n * to specify the NgModel's name, you must specify it using the `ngModelOptions` input instead.\r\n *\r\n * ```html\r\n * <form>\r\n *   <my-custom-form-control name=\"Nancy\" ngModel [ngModelOptions]=\"{name: 'user'}\">\r\n *   </my-custom-form-control>\r\n * </form>\r\n * <!-- form value: {user: ''} -->\r\n * ```\r\n *\r\n * @ngModule FormsModule\r\n * @publicApi\r\n */\r\nexport declare class NgModel extends NgControl implements OnChanges, OnDestroy {\r\n    readonly control: FormControl;\r\n    /** @nodoc */\r\n    static ngAcceptInputType_isDisabled: boolean | string;\r\n    /**\r\n     * Internal reference to the view model value.\r\n     * @nodoc\r\n     */\r\n    viewModel: any;\r\n    /**\r\n     * @description\r\n     * Tracks the name bound to the directive. If a parent form exists, it\r\n     * uses this name as a key to retrieve this control's value.\r\n     */\r\n    name: string;\r\n    /**\r\n     * @description\r\n     * Tracks whether the control is disabled.\r\n     */\r\n    isDisabled: boolean;\r\n    /**\r\n     * @description\r\n     * Tracks the value bound to this directive.\r\n     */\r\n    model: any;\r\n    /**\r\n     * @description\r\n     * Tracks the configuration options for this `ngModel` instance.\r\n     *\r\n     * **name**: An alternative to setting the name attribute on the form control element. See\r\n     * the [example](api/forms/NgModel#using-ngmodel-on-a-standalone-control) for using `NgModel`\r\n     * as a standalone control.\r\n     *\r\n     * **standalone**: When set to true, the `ngModel` will not register itself with its parent form,\r\n     * and acts as if it's not in the form. Defaults to false. If no parent form exists, this option\r\n     * has no effect.\r\n     *\r\n     * **updateOn**: Defines the event upon which the form control value and validity update.\r\n     * Defaults to 'change'. Possible values: `'change'` | `'blur'` | `'submit'`.\r\n     *\r\n     */\r\n    options: {\r\n        name?: string;\r\n        standalone?: boolean;\r\n        updateOn?: FormHooks;\r\n    };\r\n    /**\r\n     * @description\r\n     * Event emitter for producing the `ngModelChange` event after\r\n     * the view model updates.\r\n     */\r\n    update: EventEmitter<any>;\r\n    constructor(parent: ControlContainer, validators: (Validator | ValidatorFn)[], asyncValidators: (AsyncValidator | AsyncValidatorFn)[], valueAccessors: ControlValueAccessor[]);\r\n    /** @nodoc */\r\n    ngOnChanges(changes: SimpleChanges): void;\r\n    /** @nodoc */\r\n    ngOnDestroy(): void;\r\n    /**\r\n     * @description\r\n     * Returns an array that represents the path from the top-level form to this control.\r\n     * Each index is the string name of the control on that level.\r\n     */\r\n    get path(): string[];\r\n    /**\r\n     * @description\r\n     * The top-level directive for this control if present, otherwise null.\r\n     */\r\n    get formDirective(): any;\r\n    /**\r\n     * @description\r\n     * Sets the new value for the view model and emits an `ngModelChange` event.\r\n     *\r\n     * @param newValue The new value emitted by `ngModelChange`.\r\n     */\r\n    viewToModelUpdate(newValue: any): void;\r\n    private _setUpControl;\r\n    private _setUpdateStrategy;\r\n    private _isStandalone;\r\n    private _setUpStandalone;\r\n    private _checkForErrors;\r\n    private _checkParentType;\r\n    private _checkName;\r\n    private _updateValue;\r\n    private _updateDisabled;\r\n}\r\n\r\n/**\r\n * @description\r\n * Creates and binds a `FormGroup` instance to a DOM element.\r\n *\r\n * This directive can only be used as a child of `NgForm` (within `<form>` tags).\r\n *\r\n * Use this directive to validate a sub-group of your form separately from the\r\n * rest of your form, or if some values in your domain model make more sense\r\n * to consume together in a nested object.\r\n *\r\n * Provide a name for the sub-group and it will become the key\r\n * for the sub-group in the form's full value. If you need direct access, export the directive into\r\n * a local template variable using `ngModelGroup` (ex: `#myGroup=\"ngModelGroup\"`).\r\n *\r\n * @usageNotes\r\n *\r\n * ### Consuming controls in a grouping\r\n *\r\n * The following example shows you how to combine controls together in a sub-group\r\n * of the form.\r\n *\r\n * {@example forms/ts/ngModelGroup/ng_model_group_example.ts region='Component'}\r\n *\r\n * @ngModule FormsModule\r\n * @publicApi\r\n */\r\nexport declare class NgModelGroup extends AbstractFormGroupDirective implements OnInit, OnDestroy {\r\n    /**\r\n     * @description\r\n     * Tracks the name of the `NgModelGroup` bound to the directive. The name corresponds\r\n     * to a key in the parent `NgForm`.\r\n     */\r\n    name: string;\r\n    constructor(parent: ControlContainer, validators: (Validator | ValidatorFn)[], asyncValidators: (AsyncValidator | AsyncValidatorFn)[]);\r\n}\r\n\r\n/**\r\n * @description\r\n * Marks `<option>` as dynamic, so Angular can be notified when options change.\r\n *\r\n * @see `SelectControlValueAccessor`\r\n *\r\n * @ngModule ReactiveFormsModule\r\n * @ngModule FormsModule\r\n * @publicApi\r\n */\r\nexport declare class NgSelectOption implements OnDestroy {\r\n    private _element;\r\n    private _renderer;\r\n    private _select;\r\n    /**\r\n     * @description\r\n     * ID of the option element\r\n     */\r\n    id: string;\r\n    constructor(_element: ElementRef, _renderer: Renderer2, _select: SelectControlValueAccessor);\r\n    /**\r\n     * @description\r\n     * Tracks the value bound to the option element. Unlike the value binding,\r\n     * ngValue supports binding to objects.\r\n     */\r\n    set ngValue(value: any);\r\n    /**\r\n     * @description\r\n     * Tracks simple string values bound to the option element.\r\n     * For objects, use the `ngValue` input binding.\r\n     */\r\n    set value(value: any);\r\n    /** @nodoc */\r\n    ngOnDestroy(): void;\r\n}\r\n\r\n/**\r\n * @description\r\n * The `ControlValueAccessor` for writing a number value and listening to number input changes.\r\n * The value accessor is used by the `FormControlDirective`, `FormControlName`, and `NgModel`\r\n * directives.\r\n *\r\n * @usageNotes\r\n *\r\n * ### Using a number input with a reactive form.\r\n *\r\n * The following example shows how to use a number input with a reactive form.\r\n *\r\n * ```ts\r\n * const totalCountControl = new FormControl();\r\n * ```\r\n *\r\n * ```\r\n * <input type=\"number\" [formControl]=\"totalCountControl\">\r\n * ```\r\n *\r\n * @ngModule ReactiveFormsModule\r\n * @ngModule FormsModule\r\n * @publicApi\r\n */\r\nexport declare class NumberValueAccessor extends ɵangular_packages_forms_forms_g implements ControlValueAccessor {\r\n    /**\r\n     * Sets the \"value\" property on the input element.\r\n     * @nodoc\r\n     */\r\n    writeValue(value: number): void;\r\n    /**\r\n     * Registers a function called when the control value changes.\r\n     * @nodoc\r\n     */\r\n    registerOnChange(fn: (_: number | null) => void): void;\r\n}\r\n\r\n/**\r\n * @description\r\n * A directive that adds regex pattern validation to controls marked with the\r\n * `pattern` attribute. The regex must match the entire control value.\r\n * The directive is provided with the `NG_VALIDATORS` multi-provider list.\r\n *\r\n * @see [Form Validation](guide/form-validation)\r\n *\r\n * @usageNotes\r\n *\r\n * ### Adding a pattern validator\r\n *\r\n * The following example shows how to add a pattern validator to an input attached to an\r\n * ngModel binding.\r\n *\r\n * ```html\r\n * <input name=\"firstName\" ngModel pattern=\"[a-zA-Z ]*\">\r\n * ```\r\n *\r\n * @ngModule ReactiveFormsModule\r\n * @ngModule FormsModule\r\n * @publicApi\r\n */\r\nexport declare class PatternValidator implements Validator, OnChanges {\r\n    private _validator;\r\n    private _onChange?;\r\n    /**\r\n     * @description\r\n     * Tracks changes to the pattern bound to this directive.\r\n     */\r\n    pattern: string | RegExp;\r\n    /** @nodoc */\r\n    ngOnChanges(changes: SimpleChanges): void;\r\n    /**\r\n     * Method that validates whether the value matches the pattern requirement.\r\n     * @nodoc\r\n     */\r\n    validate(control: AbstractControl): ValidationErrors | null;\r\n    /**\r\n     * Registers a callback function to call when the validator inputs change.\r\n     * @nodoc\r\n     */\r\n    registerOnValidatorChange(fn: () => void): void;\r\n    private _createValidator;\r\n}\r\n\r\n/**\r\n * @description\r\n * The `ControlValueAccessor` for writing radio control values and listening to radio control\r\n * changes. The value accessor is used by the `FormControlDirective`, `FormControlName`, and\r\n * `NgModel` directives.\r\n *\r\n * @usageNotes\r\n *\r\n * ### Using radio buttons with reactive form directives\r\n *\r\n * The follow example shows how to use radio buttons in a reactive form. When using radio buttons in\r\n * a reactive form, radio buttons in the same group should have the same `formControlName`.\r\n * Providing a `name` attribute is optional.\r\n *\r\n * {@example forms/ts/reactiveRadioButtons/reactive_radio_button_example.ts region='Reactive'}\r\n *\r\n * @ngModule ReactiveFormsModule\r\n * @ngModule FormsModule\r\n * @publicApi\r\n */\r\nexport declare class RadioControlValueAccessor extends ɵangular_packages_forms_forms_g implements ControlValueAccessor, OnDestroy, OnInit {\r\n    private _registry;\r\n    private _injector;\r\n    /**\r\n     * The registered callback function called when a change event occurs on the input element.\r\n     * Note: we declare `onChange` here (also used as host listener) as a function with no arguments\r\n     * to override the `onChange` function (which expects 1 argument) in the parent\r\n     * `BaseControlValueAccessor` class.\r\n     * @nodoc\r\n     */\r\n    onChange: () => void;\r\n    /**\r\n     * @description\r\n     * Tracks the name of the radio input element.\r\n     */\r\n    name: string;\r\n    /**\r\n     * @description\r\n     * Tracks the name of the `FormControl` bound to the directive. The name corresponds\r\n     * to a key in the parent `FormGroup` or `FormArray`.\r\n     */\r\n    formControlName: string;\r\n    /**\r\n     * @description\r\n     * Tracks the value of the radio input element\r\n     */\r\n    value: any;\r\n    constructor(renderer: Renderer2, elementRef: ElementRef, _registry: ɵangular_packages_forms_forms_r, _injector: Injector);\r\n    /** @nodoc */\r\n    ngOnInit(): void;\r\n    /** @nodoc */\r\n    ngOnDestroy(): void;\r\n    /**\r\n     * Sets the \"checked\" property value on the radio input element.\r\n     * @nodoc\r\n     */\r\n    writeValue(value: any): void;\r\n    /**\r\n     * Registers a function called when the control value changes.\r\n     * @nodoc\r\n     */\r\n    registerOnChange(fn: (_: any) => {}): void;\r\n    /**\r\n     * Sets the \"value\" on the radio input element and unchecks it.\r\n     *\r\n     * @param value\r\n     */\r\n    fireUncheck(value: any): void;\r\n    private _checkName;\r\n}\r\n\r\n/**\r\n * @description\r\n * The `ControlValueAccessor` for writing a range value and listening to range input changes.\r\n * The value accessor is used by the `FormControlDirective`, `FormControlName`, and  `NgModel`\r\n * directives.\r\n *\r\n * @usageNotes\r\n *\r\n * ### Using a range input with a reactive form\r\n *\r\n * The following example shows how to use a range input with a reactive form.\r\n *\r\n * ```ts\r\n * const ageControl = new FormControl();\r\n * ```\r\n *\r\n * ```\r\n * <input type=\"range\" [formControl]=\"ageControl\">\r\n * ```\r\n *\r\n * @ngModule ReactiveFormsModule\r\n * @ngModule FormsModule\r\n * @publicApi\r\n */\r\nexport declare class RangeValueAccessor extends ɵangular_packages_forms_forms_g implements ControlValueAccessor {\r\n    /**\r\n     * Sets the \"value\" property on the input element.\r\n     * @nodoc\r\n     */\r\n    writeValue(value: any): void;\r\n    /**\r\n     * Registers a function called when the control value changes.\r\n     * @nodoc\r\n     */\r\n    registerOnChange(fn: (_: number | null) => void): void;\r\n}\r\n\r\n/**\r\n * Exports the required infrastructure and directives for reactive forms,\r\n * making them available for import by NgModules that import this module.\r\n *\r\n * Providers associated with this module:\r\n * * `FormBuilder`\r\n * * `RadioControlRegistry`\r\n *\r\n * @see [Forms Overview](guide/forms-overview)\r\n * @see [Reactive Forms Guide](guide/reactive-forms)\r\n *\r\n * @publicApi\r\n */\r\nexport declare class ReactiveFormsModule {\r\n    /**\r\n     * @description\r\n     * Provides options for configuring the reactive forms module.\r\n     *\r\n     * @param opts An object of configuration options\r\n     * * `warnOnNgModelWithFormControl` Configures when to emit a warning when an `ngModel`\r\n     * binding is used with reactive form directives.\r\n     */\r\n    static withConfig(opts: {\r\n        /** @deprecated as of v6 */ warnOnNgModelWithFormControl: 'never' | 'once' | 'always';\r\n    }): ModuleWithProviders<ReactiveFormsModule>;\r\n}\r\n\r\n/**\r\n * @description\r\n * A directive that adds the `required` validator to any controls marked with the\r\n * `required` attribute. The directive is provided with the `NG_VALIDATORS` multi-provider list.\r\n *\r\n * @see [Form Validation](guide/form-validation)\r\n *\r\n * @usageNotes\r\n *\r\n * ### Adding a required validator using template-driven forms\r\n *\r\n * ```\r\n * <input name=\"fullName\" ngModel required>\r\n * ```\r\n *\r\n * @ngModule FormsModule\r\n * @ngModule ReactiveFormsModule\r\n * @publicApi\r\n */\r\nexport declare class RequiredValidator implements Validator {\r\n    private _required;\r\n    private _onChange?;\r\n    /**\r\n     * @description\r\n     * Tracks changes to the required attribute bound to this directive.\r\n     */\r\n    get required(): boolean | string;\r\n    set required(value: boolean | string);\r\n    /**\r\n     * Method that validates whether the control is empty.\r\n     * Returns the validation result if enabled, otherwise null.\r\n     * @nodoc\r\n     */\r\n    validate(control: AbstractControl): ValidationErrors | null;\r\n    /**\r\n     * Registers a callback function to call when the validator inputs change.\r\n     * @nodoc\r\n     */\r\n    registerOnValidatorChange(fn: () => void): void;\r\n}\r\n\r\n/**\r\n * @description\r\n * The `ControlValueAccessor` for writing select control values and listening to select control\r\n * changes. The value accessor is used by the `FormControlDirective`, `FormControlName`, and\r\n * `NgModel` directives.\r\n *\r\n * @usageNotes\r\n *\r\n * ### Using select controls in a reactive form\r\n *\r\n * The following examples show how to use a select control in a reactive form.\r\n *\r\n * {@example forms/ts/reactiveSelectControl/reactive_select_control_example.ts region='Component'}\r\n *\r\n * ### Using select controls in a template-driven form\r\n *\r\n * To use a select in a template-driven form, simply add an `ngModel` and a `name`\r\n * attribute to the main `<select>` tag.\r\n *\r\n * {@example forms/ts/selectControl/select_control_example.ts region='Component'}\r\n *\r\n * ### Customizing option selection\r\n *\r\n * Angular uses object identity to select option. It's possible for the identities of items\r\n * to change while the data does not. This can happen, for example, if the items are produced\r\n * from an RPC to the server, and that RPC is re-run. Even if the data hasn't changed, the\r\n * second response will produce objects with different identities.\r\n *\r\n * To customize the default option comparison algorithm, `<select>` supports `compareWith` input.\r\n * `compareWith` takes a **function** which has two arguments: `option1` and `option2`.\r\n * If `compareWith` is given, Angular selects option by the return value of the function.\r\n *\r\n * ```ts\r\n * const selectedCountriesControl = new FormControl();\r\n * ```\r\n *\r\n * ```\r\n * <select [compareWith]=\"compareFn\"  [formControl]=\"selectedCountriesControl\">\r\n *     <option *ngFor=\"let country of countries\" [ngValue]=\"country\">\r\n *         {{country.name}}\r\n *     </option>\r\n * </select>\r\n *\r\n * compareFn(c1: Country, c2: Country): boolean {\r\n *     return c1 && c2 ? c1.id === c2.id : c1 === c2;\r\n * }\r\n * ```\r\n *\r\n * **Note:** We listen to the 'change' event because 'input' events aren't fired\r\n * for selects in IE, see:\r\n * https://developer.mozilla.org/en-US/docs/Web/API/HTMLElement/input_event#browser_compatibility\r\n *\r\n * @ngModule ReactiveFormsModule\r\n * @ngModule FormsModule\r\n * @publicApi\r\n */\r\nexport declare class SelectControlValueAccessor extends ɵangular_packages_forms_forms_g implements ControlValueAccessor {\r\n    /** @nodoc */\r\n    value: any;\r\n    /**\r\n     * @description\r\n     * Tracks the option comparison algorithm for tracking identities when\r\n     * checking for changes.\r\n     */\r\n    set compareWith(fn: (o1: any, o2: any) => boolean);\r\n    private _compareWith;\r\n    /**\r\n     * Sets the \"value\" property on the input element. The \"selectedIndex\"\r\n     * property is also set if an ID is provided on the option element.\r\n     * @nodoc\r\n     */\r\n    writeValue(value: any): void;\r\n    /**\r\n     * Registers a function called when the control value changes.\r\n     * @nodoc\r\n     */\r\n    registerOnChange(fn: (value: any) => any): void;\r\n}\r\n\r\n/**\r\n * @description\r\n * The `ControlValueAccessor` for writing multi-select control values and listening to multi-select\r\n * control changes. The value accessor is used by the `FormControlDirective`, `FormControlName`, and\r\n * `NgModel` directives.\r\n *\r\n * @see `SelectControlValueAccessor`\r\n *\r\n * @usageNotes\r\n *\r\n * ### Using a multi-select control\r\n *\r\n * The follow example shows you how to use a multi-select control with a reactive form.\r\n *\r\n * ```ts\r\n * const countryControl = new FormControl();\r\n * ```\r\n *\r\n * ```\r\n * <select multiple name=\"countries\" [formControl]=\"countryControl\">\r\n *   <option *ngFor=\"let country of countries\" [ngValue]=\"country\">\r\n *     {{ country.name }}\r\n *   </option>\r\n * </select>\r\n * ```\r\n *\r\n * ### Customizing option selection\r\n *\r\n * To customize the default option comparison algorithm, `<select>` supports `compareWith` input.\r\n * See the `SelectControlValueAccessor` for usage.\r\n *\r\n * @ngModule ReactiveFormsModule\r\n * @ngModule FormsModule\r\n * @publicApi\r\n */\r\nexport declare class SelectMultipleControlValueAccessor extends ɵangular_packages_forms_forms_g implements ControlValueAccessor {\r\n    /**\r\n     * The current value.\r\n     * @nodoc\r\n     */\r\n    value: any;\r\n    /**\r\n     * @description\r\n     * Tracks the option comparison algorithm for tracking identities when\r\n     * checking for changes.\r\n     */\r\n    set compareWith(fn: (o1: any, o2: any) => boolean);\r\n    private _compareWith;\r\n    /**\r\n     * Sets the \"value\" property on one or of more of the select's options.\r\n     * @nodoc\r\n     */\r\n    writeValue(value: any): void;\r\n    /**\r\n     * Registers a function called when the control value changes\r\n     * and writes an array of the selected options.\r\n     * @nodoc\r\n     */\r\n    registerOnChange(fn: (value: any) => any): void;\r\n}\r\n\r\n/**\r\n * @description\r\n * Defines the map of errors returned from failed validation checks.\r\n *\r\n * @publicApi\r\n */\r\nexport declare type ValidationErrors = {\r\n    [key: string]: any;\r\n};\r\n\r\n/**\r\n * @description\r\n * An interface implemented by classes that perform synchronous validation.\r\n *\r\n * @usageNotes\r\n *\r\n * ### Provide a custom validator\r\n *\r\n * The following example implements the `Validator` interface to create a\r\n * validator directive with a custom error key.\r\n *\r\n * ```typescript\r\n * @Directive({\r\n *   selector: '[customValidator]',\r\n *   providers: [{provide: NG_VALIDATORS, useExisting: CustomValidatorDirective, multi: true}]\r\n * })\r\n * class CustomValidatorDirective implements Validator {\r\n *   validate(control: AbstractControl): ValidationErrors|null {\r\n *     return {'custom': true};\r\n *   }\r\n * }\r\n * ```\r\n *\r\n * @publicApi\r\n */\r\nexport declare interface Validator {\r\n    /**\r\n     * @description\r\n     * Method that performs synchronous validation against the provided control.\r\n     *\r\n     * @param control The control to validate against.\r\n     *\r\n     * @returns A map of validation errors if validation fails,\r\n     * otherwise null.\r\n     */\r\n    validate(control: AbstractControl): ValidationErrors | null;\r\n    /**\r\n     * @description\r\n     * Registers a callback function to call when the validator inputs change.\r\n     *\r\n     * @param fn The callback function\r\n     */\r\n    registerOnValidatorChange?(fn: () => void): void;\r\n}\r\n\r\n/**\r\n * @description\r\n * A function that receives a control and synchronously returns a map of\r\n * validation errors if present, otherwise null.\r\n *\r\n * @publicApi\r\n */\r\nexport declare interface ValidatorFn {\r\n    (control: AbstractControl): ValidationErrors | null;\r\n}\r\n\r\n/**\r\n * @description\r\n * Provides a set of built-in validators that can be used by form controls.\r\n *\r\n * A validator is a function that processes a `FormControl` or collection of\r\n * controls and returns an error map or null. A null map means that validation has passed.\r\n *\r\n * @see [Form Validation](/guide/form-validation)\r\n *\r\n * @publicApi\r\n */\r\nexport declare class Validators {\r\n    /**\r\n     * @description\r\n     * Validator that requires the control's value to be greater than or equal to the provided number.\r\n     *\r\n     * @usageNotes\r\n     *\r\n     * ### Validate against a minimum of 3\r\n     *\r\n     * ```typescript\r\n     * const control = new FormControl(2, Validators.min(3));\r\n     *\r\n     * console.log(control.errors); // {min: {min: 3, actual: 2}}\r\n     * ```\r\n     *\r\n     * @returns A validator function that returns an error map with the\r\n     * `min` property if the validation check fails, otherwise `null`.\r\n     *\r\n     * @see `updateValueAndValidity()`\r\n     *\r\n     */\r\n    static min(min: number): ValidatorFn;\r\n    /**\r\n     * @description\r\n     * Validator that requires the control's value to be less than or equal to the provided number.\r\n     *\r\n     * @usageNotes\r\n     *\r\n     * ### Validate against a maximum of 15\r\n     *\r\n     * ```typescript\r\n     * const control = new FormControl(16, Validators.max(15));\r\n     *\r\n     * console.log(control.errors); // {max: {max: 15, actual: 16}}\r\n     * ```\r\n     *\r\n     * @returns A validator function that returns an error map with the\r\n     * `max` property if the validation check fails, otherwise `null`.\r\n     *\r\n     * @see `updateValueAndValidity()`\r\n     *\r\n     */\r\n    static max(max: number): ValidatorFn;\r\n    /**\r\n     * @description\r\n     * Validator that requires the control have a non-empty value.\r\n     *\r\n     * @usageNotes\r\n     *\r\n     * ### Validate that the field is non-empty\r\n     *\r\n     * ```typescript\r\n     * const control = new FormControl('', Validators.required);\r\n     *\r\n     * console.log(control.errors); // {required: true}\r\n     * ```\r\n     *\r\n     * @returns An error map with the `required` property\r\n     * if the validation check fails, otherwise `null`.\r\n     *\r\n     * @see `updateValueAndValidity()`\r\n     *\r\n     */\r\n    static required(control: AbstractControl): ValidationErrors | null;\r\n    /**\r\n     * @description\r\n     * Validator that requires the control's value be true. This validator is commonly\r\n     * used for required checkboxes.\r\n     *\r\n     * @usageNotes\r\n     *\r\n     * ### Validate that the field value is true\r\n     *\r\n     * ```typescript\r\n     * const control = new FormControl('', Validators.requiredTrue);\r\n     *\r\n     * console.log(control.errors); // {required: true}\r\n     * ```\r\n     *\r\n     * @returns An error map that contains the `required` property\r\n     * set to `true` if the validation check fails, otherwise `null`.\r\n     *\r\n     * @see `updateValueAndValidity()`\r\n     *\r\n     */\r\n    static requiredTrue(control: AbstractControl): ValidationErrors | null;\r\n    /**\r\n     * @description\r\n     * Validator that requires the control's value pass an email validation test.\r\n     *\r\n     * Tests the value using a [regular\r\n     * expression](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Regular_Expressions)\r\n     * pattern suitable for common usecases. The pattern is based on the definition of a valid email\r\n     * address in the [WHATWG HTML\r\n     * specification](https://html.spec.whatwg.org/multipage/input.html#valid-e-mail-address) with\r\n     * some enhancements to incorporate more RFC rules (such as rules related to domain names and the\r\n     * lengths of different parts of the address).\r\n     *\r\n     * The differences from the WHATWG version include:\r\n     * - Disallow `local-part` (the part before the `@` symbol) to begin or end with a period (`.`).\r\n     * - Disallow `local-part` to be longer than 64 characters.\r\n     * - Disallow the whole address to be longer than 254 characters.\r\n     *\r\n     * If this pattern does not satisfy your business needs, you can use `Validators.pattern()` to\r\n     * validate the value against a different pattern.\r\n     *\r\n     * @usageNotes\r\n     *\r\n     * ### Validate that the field matches a valid email pattern\r\n     *\r\n     * ```typescript\r\n     * const control = new FormControl('bad@', Validators.email);\r\n     *\r\n     * console.log(control.errors); // {email: true}\r\n     * ```\r\n     *\r\n     * @returns An error map with the `email` property\r\n     * if the validation check fails, otherwise `null`.\r\n     *\r\n     * @see `updateValueAndValidity()`\r\n     *\r\n     */\r\n    static email(control: AbstractControl): ValidationErrors | null;\r\n    /**\r\n     * @description\r\n     * Validator that requires the length of the control's value to be greater than or equal\r\n     * to the provided minimum length. This validator is also provided by default if you use the\r\n     * the HTML5 `minlength` attribute. Note that the `minLength` validator is intended to be used\r\n     * only for types that have a numeric `length` property, such as strings or arrays. The\r\n     * `minLength` validator logic is also not invoked for values when their `length` property is 0\r\n     * (for example in case of an empty string or an empty array), to support optional controls. You\r\n     * can use the standard `required` validator if empty values should not be considered valid.\r\n     *\r\n     * @usageNotes\r\n     *\r\n     * ### Validate that the field has a minimum of 3 characters\r\n     *\r\n     * ```typescript\r\n     * const control = new FormControl('ng', Validators.minLength(3));\r\n     *\r\n     * console.log(control.errors); // {minlength: {requiredLength: 3, actualLength: 2}}\r\n     * ```\r\n     *\r\n     * ```html\r\n     * <input minlength=\"5\">\r\n     * ```\r\n     *\r\n     * @returns A validator function that returns an error map with the\r\n     * `minlength` property if the validation check fails, otherwise `null`.\r\n     *\r\n     * @see `updateValueAndValidity()`\r\n     *\r\n     */\r\n    static minLength(minLength: number): ValidatorFn;\r\n    /**\r\n     * @description\r\n     * Validator that requires the length of the control's value to be less than or equal\r\n     * to the provided maximum length. This validator is also provided by default if you use the\r\n     * the HTML5 `maxlength` attribute. Note that the `maxLength` validator is intended to be used\r\n     * only for types that have a numeric `length` property, such as strings or arrays.\r\n     *\r\n     * @usageNotes\r\n     *\r\n     * ### Validate that the field has maximum of 5 characters\r\n     *\r\n     * ```typescript\r\n     * const control = new FormControl('Angular', Validators.maxLength(5));\r\n     *\r\n     * console.log(control.errors); // {maxlength: {requiredLength: 5, actualLength: 7}}\r\n     * ```\r\n     *\r\n     * ```html\r\n     * <input maxlength=\"5\">\r\n     * ```\r\n     *\r\n     * @returns A validator function that returns an error map with the\r\n     * `maxlength` property if the validation check fails, otherwise `null`.\r\n     *\r\n     * @see `updateValueAndValidity()`\r\n     *\r\n     */\r\n    static maxLength(maxLength: number): ValidatorFn;\r\n    /**\r\n     * @description\r\n     * Validator that requires the control's value to match a regex pattern. This validator is also\r\n     * provided by default if you use the HTML5 `pattern` attribute.\r\n     *\r\n     * @usageNotes\r\n     *\r\n     * ### Validate that the field only contains letters or spaces\r\n     *\r\n     * ```typescript\r\n     * const control = new FormControl('1', Validators.pattern('[a-zA-Z ]*'));\r\n     *\r\n     * console.log(control.errors); // {pattern: {requiredPattern: '^[a-zA-Z ]*$', actualValue: '1'}}\r\n     * ```\r\n     *\r\n     * ```html\r\n     * <input pattern=\"[a-zA-Z ]*\">\r\n     * ```\r\n     *\r\n     * ### Pattern matching with the global or sticky flag\r\n     *\r\n     * `RegExp` objects created with the `g` or `y` flags that are passed into `Validators.pattern`\r\n     * can produce different results on the same input when validations are run consecutively. This is\r\n     * due to how the behavior of `RegExp.prototype.test` is\r\n     * specified in [ECMA-262](https://tc39.es/ecma262/#sec-regexpbuiltinexec)\r\n     * (`RegExp` preserves the index of the last match when the global or sticky flag is used).\r\n     * Due to this behavior, it is recommended that when using\r\n     * `Validators.pattern` you **do not** pass in a `RegExp` object with either the global or sticky\r\n     * flag enabled.\r\n     *\r\n     * ```typescript\r\n     * // Not recommended (since the `g` flag is used)\r\n     * const controlOne = new FormControl('1', Validators.pattern(/foo/g));\r\n     *\r\n     * // Good\r\n     * const controlTwo = new FormControl('1', Validators.pattern(/foo/));\r\n     * ```\r\n     *\r\n     * @param pattern A regular expression to be used as is to test the values, or a string.\r\n     * If a string is passed, the `^` character is prepended and the `$` character is\r\n     * appended to the provided string (if not already present), and the resulting regular\r\n     * expression is used to test the values.\r\n     *\r\n     * @returns A validator function that returns an error map with the\r\n     * `pattern` property if the validation check fails, otherwise `null`.\r\n     *\r\n     * @see `updateValueAndValidity()`\r\n     *\r\n     */\r\n    static pattern(pattern: string | RegExp): ValidatorFn;\r\n    /**\r\n     * @description\r\n     * Validator that performs no operation.\r\n     *\r\n     * @see `updateValueAndValidity()`\r\n     *\r\n     */\r\n    static nullValidator(control: AbstractControl): ValidationErrors | null;\r\n    /**\r\n     * @description\r\n     * Compose multiple validators into a single function that returns the union\r\n     * of the individual error maps for the provided control.\r\n     *\r\n     * @returns A validator function that returns an error map with the\r\n     * merged error maps of the validators if the validation check fails, otherwise `null`.\r\n     *\r\n     * @see `updateValueAndValidity()`\r\n     *\r\n     */\r\n    static compose(validators: null): null;\r\n    static compose(validators: (ValidatorFn | null | undefined)[]): ValidatorFn | null;\r\n    /**\r\n     * @description\r\n     * Compose multiple async validators into a single function that returns the union\r\n     * of the individual error objects for the provided control.\r\n     *\r\n     * @returns A validator function that returns an error map with the\r\n     * merged error objects of the async validators if the validation check fails, otherwise `null`.\r\n     *\r\n     * @see `updateValueAndValidity()`\r\n     *\r\n     */\r\n    static composeAsync(validators: (AsyncValidatorFn | null)[]): AsyncValidatorFn | null;\r\n}\r\n\r\n/**\r\n * @publicApi\r\n */\r\nexport declare const VERSION: Version;\r\n\r\nexport declare const ɵangular_packages_forms_forms_a: Type<any>[];\r\n\r\nexport declare const ɵangular_packages_forms_forms_b: Type<any>[];\r\n\r\nexport declare const ɵangular_packages_forms_forms_ba: StaticProvider;\r\n\r\n/**\r\n * @description\r\n * Provider which adds `MaxValidator` to the `NG_VALIDATORS` multi-provider list.\r\n */\r\nexport declare const ɵangular_packages_forms_forms_bd: StaticProvider;\r\n\r\n/**\r\n * @description\r\n * Provider which adds `MinValidator` to the `NG_VALIDATORS` multi-provider list.\r\n */\r\nexport declare const ɵangular_packages_forms_forms_be: StaticProvider;\r\n\r\n/**\r\n * @description\r\n * Provider which adds `RequiredValidator` to the `NG_VALIDATORS` multi-provider list.\r\n */\r\nexport declare const ɵangular_packages_forms_forms_bf: StaticProvider;\r\n\r\n/**\r\n * @description\r\n * Provider which adds `CheckboxRequiredValidator` to the `NG_VALIDATORS` multi-provider list.\r\n */\r\nexport declare const ɵangular_packages_forms_forms_bg: StaticProvider;\r\n\r\n/**\r\n * @description\r\n * Provider which adds `EmailValidator` to the `NG_VALIDATORS` multi-provider list.\r\n */\r\nexport declare const ɵangular_packages_forms_forms_bh: any;\r\n\r\n/**\r\n * @description\r\n * Provider which adds `MinLengthValidator` to the `NG_VALIDATORS` multi-provider list.\r\n */\r\nexport declare const ɵangular_packages_forms_forms_bi: any;\r\n\r\n/**\r\n * @description\r\n * Provider which adds `MaxLengthValidator` to the `NG_VALIDATORS` multi-provider list.\r\n */\r\nexport declare const ɵangular_packages_forms_forms_bj: any;\r\n\r\n/**\r\n * @description\r\n * Provider which adds `PatternValidator` to the `NG_VALIDATORS` multi-provider list.\r\n */\r\nexport declare const ɵangular_packages_forms_forms_bk: any;\r\n\r\n/**\r\n * Validator that requires the control's value to be greater than or equal to the provided number.\r\n * See `Validators.min` for additional information.\r\n */\r\nexport declare function ɵangular_packages_forms_forms_bl(min: number): ValidatorFn;\r\n\r\n/**\r\n * Validator that requires the control's value to be less than or equal to the provided number.\r\n * See `Validators.max` for additional information.\r\n */\r\nexport declare function ɵangular_packages_forms_forms_bm(max: number): ValidatorFn;\r\n\r\n/**\r\n * Validator that requires the control have a non-empty value.\r\n * See `Validators.required` for additional information.\r\n */\r\nexport declare function ɵangular_packages_forms_forms_bn(control: AbstractControl): ValidationErrors | null;\r\n\r\n/**\r\n * Validator that requires the control's value be true. This validator is commonly\r\n * used for required checkboxes.\r\n * See `Validators.requiredTrue` for additional information.\r\n */\r\nexport declare function ɵangular_packages_forms_forms_bo(control: AbstractControl): ValidationErrors | null;\r\n\r\n/**\r\n * Validator that requires the control's value pass an email validation test.\r\n * See `Validators.email` for additional information.\r\n */\r\nexport declare function ɵangular_packages_forms_forms_bp(control: AbstractControl): ValidationErrors | null;\r\n\r\n/**\r\n * Validator that requires the length of the control's value to be greater than or equal\r\n * to the provided minimum length. See `Validators.minLength` for additional information.\r\n */\r\nexport declare function ɵangular_packages_forms_forms_bq(minLength: number): ValidatorFn;\r\n\r\n/**\r\n * Validator that requires the length of the control's value to be less than or equal\r\n * to the provided maximum length. See `Validators.maxLength` for additional information.\r\n */\r\nexport declare function ɵangular_packages_forms_forms_br(maxLength: number): ValidatorFn;\r\n\r\n/**\r\n * Validator that requires the control's value to match a regex pattern.\r\n * See `Validators.pattern` for additional information.\r\n */\r\nexport declare function ɵangular_packages_forms_forms_bs(pattern: string | RegExp): ValidatorFn;\r\n\r\n/**\r\n * Function that has `ValidatorFn` shape, but performs no operation.\r\n */\r\nexport declare function ɵangular_packages_forms_forms_bt(control: AbstractControl): ValidationErrors | null;\r\n\r\nexport declare const ɵangular_packages_forms_forms_c: Type<any>[];\r\n\r\nexport declare const ɵangular_packages_forms_forms_e: any;\r\n\r\n/**\r\n * Base class for all ControlValueAccessor classes defined in Forms package.\r\n * Contains common logic and utility functions.\r\n *\r\n * Note: this is an *internal-only* class and should not be extended or used directly in\r\n * applications code.\r\n */\r\nexport declare class ɵangular_packages_forms_forms_f {\r\n    private _renderer;\r\n    private _elementRef;\r\n    /**\r\n     * The registered callback function called when a change or input event occurs on the input\r\n     * element.\r\n     * @nodoc\r\n     */\r\n    onChange: (_: any) => void;\r\n    /**\r\n     * The registered callback function called when a blur event occurs on the input element.\r\n     * @nodoc\r\n     */\r\n    onTouched: () => void;\r\n    constructor(_renderer: Renderer2, _elementRef: ElementRef);\r\n    /**\r\n     * Helper method that sets a property on a target element using the current Renderer\r\n     * implementation.\r\n     * @nodoc\r\n     */\r\n    protected setProperty(key: string, value: any): void;\r\n    /**\r\n     * Registers a function called when the control is touched.\r\n     * @nodoc\r\n     */\r\n    registerOnTouched(fn: () => void): void;\r\n    /**\r\n     * Registers a function called when the control value changes.\r\n     * @nodoc\r\n     */\r\n    registerOnChange(fn: (_: any) => {}): void;\r\n    /**\r\n     * Sets the \"disabled\" property on the range input element.\r\n     * @nodoc\r\n     */\r\n    setDisabledState(isDisabled: boolean): void;\r\n}\r\n\r\n/**\r\n * Base class for all built-in ControlValueAccessor classes (except DefaultValueAccessor, which is\r\n * used in case no other CVAs can be found). We use this class to distinguish between default CVA,\r\n * built-in CVAs and custom CVAs, so that Forms logic can recognize built-in CVAs and treat custom\r\n * ones with higher priority (when both built-in and custom CVAs are present).\r\n *\r\n * Note: this is an *internal-only* class and should not be extended or used directly in\r\n * applications code.\r\n */\r\nexport declare class ɵangular_packages_forms_forms_g extends ɵangular_packages_forms_forms_f {\r\n}\r\n\r\nexport declare const ɵangular_packages_forms_forms_h: any;\r\n\r\nexport declare class ɵangular_packages_forms_forms_i {\r\n    private _cd;\r\n    constructor(cd: AbstractControlDirective | null);\r\n    is(status: AnyControlStatus): boolean;\r\n}\r\n\r\nexport declare const ɵangular_packages_forms_forms_j: {\r\n    '[class.ng-untouched]': string;\r\n    '[class.ng-touched]': string;\r\n    '[class.ng-pristine]': string;\r\n    '[class.ng-dirty]': string;\r\n    '[class.ng-valid]': string;\r\n    '[class.ng-invalid]': string;\r\n    '[class.ng-pending]': string;\r\n};\r\n\r\nexport declare const ɵangular_packages_forms_forms_k: {\r\n    '[class.ng-untouched]': string;\r\n    '[class.ng-touched]': string;\r\n    '[class.ng-pristine]': string;\r\n    '[class.ng-dirty]': string;\r\n    '[class.ng-valid]': string;\r\n    '[class.ng-invalid]': string;\r\n    '[class.ng-pending]': string;\r\n    '[class.ng-submitted]': string;\r\n};\r\n\r\nexport declare const ɵangular_packages_forms_forms_l: any;\r\n\r\nexport declare const ɵangular_packages_forms_forms_m: any;\r\n\r\nexport declare const ɵangular_packages_forms_forms_n: any;\r\n\r\nexport declare const ɵangular_packages_forms_forms_o: any;\r\n\r\nexport declare const ɵangular_packages_forms_forms_p: any;\r\n\r\n/**\r\n * Internal-only NgModule that works as a host for the `RadioControlRegistry` tree-shakable\r\n * provider. Note: the `InternalFormsSharedModule` can not be used here directly, since it's\r\n * declared *after* the `RadioControlRegistry` class and the `providedIn` doesn't support\r\n * `forwardRef` logic.\r\n */\r\nexport declare class ɵangular_packages_forms_forms_q {\r\n}\r\n\r\n/**\r\n * @description\r\n * Class used by Angular to track radio buttons. For internal use only.\r\n */\r\nexport declare class ɵangular_packages_forms_forms_r {\r\n    private _accessors;\r\n    /**\r\n     * @description\r\n     * Adds a control to the internal registry. For internal use only.\r\n     */\r\n    add(control: NgControl, accessor: RadioControlValueAccessor): void;\r\n    /**\r\n     * @description\r\n     * Removes a control from the internal registry. For internal use only.\r\n     */\r\n    remove(accessor: RadioControlValueAccessor): void;\r\n    /**\r\n     * @description\r\n     * Selects a radio button. For internal use only.\r\n     */\r\n    select(accessor: RadioControlValueAccessor): void;\r\n    private _isSameGroup;\r\n}\r\n\r\nexport declare const ɵangular_packages_forms_forms_s: StaticProvider;\r\n\r\n/**\r\n * Token to provide to turn off the ngModel warning on formControl and formControlName.\r\n */\r\nexport declare const ɵangular_packages_forms_forms_t: InjectionToken<unknown>;\r\n\r\nexport declare const ɵangular_packages_forms_forms_u: any;\r\n\r\nexport declare const ɵangular_packages_forms_forms_v: any;\r\n\r\nexport declare const ɵangular_packages_forms_forms_w: any;\r\n\r\nexport declare const ɵangular_packages_forms_forms_x: any;\r\n\r\nexport declare const ɵangular_packages_forms_forms_y: any;\r\n\r\nexport declare const ɵangular_packages_forms_forms_z: StaticProvider;\r\n\r\n/**\r\n * Internal module used for sharing directives between FormsModule and ReactiveFormsModule\r\n */\r\ndeclare class ɵInternalFormsSharedModule {\r\n}\r\nexport { ɵInternalFormsSharedModule }\r\nexport { ɵInternalFormsSharedModule as ɵangular_packages_forms_forms_d }\r\n\r\n\r\n/**\r\n * @description\r\n *\r\n * Adds `novalidate` attribute to all forms by default.\r\n *\r\n * `novalidate` is used to disable browser's native form validation.\r\n *\r\n * If you want to use native validation with Angular forms, just add `ngNativeValidate` attribute:\r\n *\r\n * ```\r\n * <form ngNativeValidate></form>\r\n * ```\r\n *\r\n * @publicApi\r\n * @ngModule ReactiveFormsModule\r\n * @ngModule FormsModule\r\n */\r\ndeclare class ɵNgNoValidate {\r\n}\r\nexport { ɵNgNoValidate }\r\nexport { ɵNgNoValidate as ɵangular_packages_forms_forms_bc }\r\n\r\n/**\r\n * @description\r\n * Marks `<option>` as dynamic, so Angular can be notified when options change.\r\n *\r\n * @see `SelectMultipleControlValueAccessor`\r\n *\r\n * @ngModule ReactiveFormsModule\r\n * @ngModule FormsModule\r\n * @publicApi\r\n */\r\ndeclare class ɵNgSelectMultipleOption implements OnDestroy {\r\n    private _element;\r\n    private _renderer;\r\n    private _select;\r\n    id: string;\r\n    constructor(_element: ElementRef, _renderer: Renderer2, _select: SelectMultipleControlValueAccessor);\r\n    /**\r\n     * @description\r\n     * Tracks the value bound to the option element. Unlike the value binding,\r\n     * ngValue supports binding to objects.\r\n     */\r\n    set ngValue(value: any);\r\n    /**\r\n     * @description\r\n     * Tracks simple string values bound to the option element.\r\n     * For objects, use the `ngValue` input binding.\r\n     */\r\n    set value(value: any);\r\n    /** @nodoc */\r\n    ngOnDestroy(): void;\r\n}\r\nexport { ɵNgSelectMultipleOption }\r\nexport { ɵNgSelectMultipleOption as ɵangular_packages_forms_forms_bb }\r\n\r\nexport { }\r\n"]}
=======
{"version":3,"file":"forms.d.ts","sources":["forms.d.ts"],"names":[],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA;AACA;AACA;AACA;AACA","sourcesContent":["/**\n * @license Angular v12.2.10\n * (c) 2010-2021 Google LLC. https://angular.io/\n * License: MIT\n */\n\nimport { AfterViewInit } from '@angular/core';\nimport { ElementRef } from '@angular/core';\nimport { EventEmitter } from '@angular/core';\nimport { InjectionToken } from '@angular/core';\nimport { Injector } from '@angular/core';\nimport { ModuleWithProviders } from '@angular/core';\nimport { Observable } from 'rxjs';\nimport { OnChanges } from '@angular/core';\nimport { OnDestroy } from '@angular/core';\nimport { OnInit } from '@angular/core';\nimport { Renderer2 } from '@angular/core';\nimport { SimpleChanges } from '@angular/core';\nimport { StaticProvider } from '@angular/core';\nimport { Type } from '@angular/core';\nimport { Version } from '@angular/core';\n\n/**\n * This is the base class for `FormControl`, `FormGroup`, and `FormArray`.\n *\n * It provides some of the shared behavior that all controls and groups of controls have, like\n * running validators, calculating status, and resetting state. It also defines the properties\n * that are shared between all sub-classes, like `value`, `valid`, and `dirty`. It shouldn't be\n * instantiated directly.\n *\n * @see [Forms Guide](/guide/forms)\n * @see [Reactive Forms Guide](/guide/reactive-forms)\n * @see [Dynamic Forms Guide](/guide/dynamic-form)\n *\n * @publicApi\n */\nexport declare abstract class AbstractControl {\n    private _parent;\n    private _asyncValidationSubscription;\n    /**\n     * The current value of the control.\n     *\n     * * For a `FormControl`, the current value.\n     * * For an enabled `FormGroup`, the values of enabled controls as an object\n     * with a key-value pair for each member of the group.\n     * * For a disabled `FormGroup`, the values of all controls as an object\n     * with a key-value pair for each member of the group.\n     * * For a `FormArray`, the values of enabled controls as an array.\n     *\n     */\n    readonly value: any;\n    /**\n     * Initialize the AbstractControl instance.\n     *\n     * @param validators The function or array of functions that is used to determine the validity of\n     *     this control synchronously.\n     * @param asyncValidators The function or array of functions that is used to determine validity of\n     *     this control asynchronously.\n     */\n    constructor(validators: ValidatorFn | ValidatorFn[] | null, asyncValidators: AsyncValidatorFn | AsyncValidatorFn[] | null);\n    /**\n     * Returns the function that is used to determine the validity of this control synchronously.\n     * If multiple validators have been added, this will be a single composed function.\n     * See `Validators.compose()` for additional information.\n     */\n    get validator(): ValidatorFn | null;\n    set validator(validatorFn: ValidatorFn | null);\n    /**\n     * Returns the function that is used to determine the validity of this control asynchronously.\n     * If multiple validators have been added, this will be a single composed function.\n     * See `Validators.compose()` for additional information.\n     */\n    get asyncValidator(): AsyncValidatorFn | null;\n    set asyncValidator(asyncValidatorFn: AsyncValidatorFn | null);\n    /**\n     * The parent control.\n     */\n    get parent(): FormGroup | FormArray | null;\n    /**\n     * The validation status of the control. There are four possible\n     * validation status values:\n     *\n     * * **VALID**: This control has passed all validation checks.\n     * * **INVALID**: This control has failed at least one validation check.\n     * * **PENDING**: This control is in the midst of conducting a validation check.\n     * * **DISABLED**: This control is exempt from validation checks.\n     *\n     * These status values are mutually exclusive, so a control cannot be\n     * both valid AND invalid or invalid AND disabled.\n     */\n    readonly status: string;\n    /**\n     * A control is `valid` when its `status` is `VALID`.\n     *\n     * @see {@link AbstractControl.status}\n     *\n     * @returns True if the control has passed all of its validation tests,\n     * false otherwise.\n     */\n    get valid(): boolean;\n    /**\n     * A control is `invalid` when its `status` is `INVALID`.\n     *\n     * @see {@link AbstractControl.status}\n     *\n     * @returns True if this control has failed one or more of its validation checks,\n     * false otherwise.\n     */\n    get invalid(): boolean;\n    /**\n     * A control is `pending` when its `status` is `PENDING`.\n     *\n     * @see {@link AbstractControl.status}\n     *\n     * @returns True if this control is in the process of conducting a validation check,\n     * false otherwise.\n     */\n    get pending(): boolean;\n    /**\n     * A control is `disabled` when its `status` is `DISABLED`.\n     *\n     * Disabled controls are exempt from validation checks and\n     * are not included in the aggregate value of their ancestor\n     * controls.\n     *\n     * @see {@link AbstractControl.status}\n     *\n     * @returns True if the control is disabled, false otherwise.\n     */\n    get disabled(): boolean;\n    /**\n     * A control is `enabled` as long as its `status` is not `DISABLED`.\n     *\n     * @returns True if the control has any status other than 'DISABLED',\n     * false if the status is 'DISABLED'.\n     *\n     * @see {@link AbstractControl.status}\n     *\n     */\n    get enabled(): boolean;\n    /**\n     * An object containing any errors generated by failing validation,\n     * or null if there are no errors.\n     */\n    readonly errors: ValidationErrors | null;\n    /**\n     * A control is `pristine` if the user has not yet changed\n     * the value in the UI.\n     *\n     * @returns True if the user has not yet changed the value in the UI; compare `dirty`.\n     * Programmatic changes to a control's value do not mark it dirty.\n     */\n    readonly pristine: boolean;\n    /**\n     * A control is `dirty` if the user has changed the value\n     * in the UI.\n     *\n     * @returns True if the user has changed the value of this control in the UI; compare `pristine`.\n     * Programmatic changes to a control's value do not mark it dirty.\n     */\n    get dirty(): boolean;\n    /**\n     * True if the control is marked as `touched`.\n     *\n     * A control is marked `touched` once the user has triggered\n     * a `blur` event on it.\n     */\n    readonly touched: boolean;\n    /**\n     * True if the control has not been marked as touched\n     *\n     * A control is `untouched` if the user has not yet triggered\n     * a `blur` event on it.\n     */\n    get untouched(): boolean;\n    /**\n     * A multicasting observable that emits an event every time the value of the control changes, in\n     * the UI or programmatically. It also emits an event each time you call enable() or disable()\n     * without passing along {emitEvent: false} as a function argument.\n     */\n    readonly valueChanges: Observable<any>;\n    /**\n     * A multicasting observable that emits an event every time the validation `status` of the control\n     * recalculates.\n     *\n     * @see {@link AbstractControl.status}\n     *\n     */\n    readonly statusChanges: Observable<any>;\n    /**\n     * Reports the update strategy of the `AbstractControl` (meaning\n     * the event on which the control updates itself).\n     * Possible values: `'change'` | `'blur'` | `'submit'`\n     * Default value: `'change'`\n     */\n    get updateOn(): FormHooks;\n    /**\n     * Sets the synchronous validators that are active on this control.  Calling\n     * this overwrites any existing synchronous validators.\n     *\n     * When you add or remove a validator at run time, you must call\n     * `updateValueAndValidity()` for the new validation to take effect.\n     *\n     * If you want to add a new validator without affecting existing ones, consider\n     * using `addValidators()` method instead.\n     */\n    setValidators(validators: ValidatorFn | ValidatorFn[] | null): void;\n    /**\n     * Sets the asynchronous validators that are active on this control. Calling this\n     * overwrites any existing asynchronous validators.\n     *\n     * When you add or remove a validator at run time, you must call\n     * `updateValueAndValidity()` for the new validation to take effect.\n     *\n     * If you want to add a new validator without affecting existing ones, consider\n     * using `addAsyncValidators()` method instead.\n     */\n    setAsyncValidators(validators: AsyncValidatorFn | AsyncValidatorFn[] | null): void;\n    /**\n     * Add a synchronous validator or validators to this control, without affecting other validators.\n     *\n     * When you add or remove a validator at run time, you must call\n     * `updateValueAndValidity()` for the new validation to take effect.\n     *\n     * Adding a validator that already exists will have no effect. If duplicate validator functions\n     * are present in the `validators` array, only the first instance would be added to a form\n     * control.\n     *\n     * @param validators The new validator function or functions to add to this control.\n     */\n    addValidators(validators: ValidatorFn | ValidatorFn[]): void;\n    /**\n     * Add an asynchronous validator or validators to this control, without affecting other\n     * validators.\n     *\n     * When you add or remove a validator at run time, you must call\n     * `updateValueAndValidity()` for the new validation to take effect.\n     *\n     * Adding a validator that already exists will have no effect.\n     *\n     * @param validators The new asynchronous validator function or functions to add to this control.\n     */\n    addAsyncValidators(validators: AsyncValidatorFn | AsyncValidatorFn[]): void;\n    /**\n     * Remove a synchronous validator from this control, without affecting other validators.\n     * Validators are compared by function reference; you must pass a reference to the exact same\n     * validator function as the one that was originally set. If a provided validator is not found,\n     * it is ignored.\n     *\n     * When you add or remove a validator at run time, you must call\n     * `updateValueAndValidity()` for the new validation to take effect.\n     *\n     * @param validators The validator or validators to remove.\n     */\n    removeValidators(validators: ValidatorFn | ValidatorFn[]): void;\n    /**\n     * Remove an asynchronous validator from this control, without affecting other validators.\n     * Validators are compared by function reference; you must pass a reference to the exact same\n     * validator function as the one that was originally set. If a provided validator is not found, it\n     * is ignored.\n     *\n     * When you add or remove a validator at run time, you must call\n     * `updateValueAndValidity()` for the new validation to take effect.\n     *\n     * @param validators The asynchronous validator or validators to remove.\n     */\n    removeAsyncValidators(validators: AsyncValidatorFn | AsyncValidatorFn[]): void;\n    /**\n     * Check whether a synchronous validator function is present on this control. The provided\n     * validator must be a reference to the exact same function that was provided.\n     *\n     * @param validator The validator to check for presence. Compared by function reference.\n     * @returns Whether the provided validator was found on this control.\n     */\n    hasValidator(validator: ValidatorFn): boolean;\n    /**\n     * Check whether an asynchronous validator function is present on this control. The provided\n     * validator must be a reference to the exact same function that was provided.\n     *\n     * @param validator The asynchronous validator to check for presence. Compared by function\n     *     reference.\n     * @returns Whether the provided asynchronous validator was found on this control.\n     */\n    hasAsyncValidator(validator: AsyncValidatorFn): boolean;\n    /**\n     * Empties out the synchronous validator list.\n     *\n     * When you add or remove a validator at run time, you must call\n     * `updateValueAndValidity()` for the new validation to take effect.\n     *\n     */\n    clearValidators(): void;\n    /**\n     * Empties out the async validator list.\n     *\n     * When you add or remove a validator at run time, you must call\n     * `updateValueAndValidity()` for the new validation to take effect.\n     *\n     */\n    clearAsyncValidators(): void;\n    /**\n     * Marks the control as `touched`. A control is touched by focus and\n     * blur events that do not change the value.\n     *\n     * @see `markAsUntouched()`\n     * @see `markAsDirty()`\n     * @see `markAsPristine()`\n     *\n     * @param opts Configuration options that determine how the control propagates changes\n     * and emits events after marking is applied.\n     * * `onlySelf`: When true, mark only this control. When false or not supplied,\n     * marks all direct ancestors. Default is false.\n     */\n    markAsTouched(opts?: {\n        onlySelf?: boolean;\n    }): void;\n    /**\n     * Marks the control and all its descendant controls as `touched`.\n     * @see `markAsTouched()`\n     */\n    markAllAsTouched(): void;\n    /**\n     * Marks the control as `untouched`.\n     *\n     * If the control has any children, also marks all children as `untouched`\n     * and recalculates the `touched` status of all parent controls.\n     *\n     * @see `markAsTouched()`\n     * @see `markAsDirty()`\n     * @see `markAsPristine()`\n     *\n     * @param opts Configuration options that determine how the control propagates changes\n     * and emits events after the marking is applied.\n     * * `onlySelf`: When true, mark only this control. When false or not supplied,\n     * marks all direct ancestors. Default is false.\n     */\n    markAsUntouched(opts?: {\n        onlySelf?: boolean;\n    }): void;\n    /**\n     * Marks the control as `dirty`. A control becomes dirty when\n     * the control's value is changed through the UI; compare `markAsTouched`.\n     *\n     * @see `markAsTouched()`\n     * @see `markAsUntouched()`\n     * @see `markAsPristine()`\n     *\n     * @param opts Configuration options that determine how the control propagates changes\n     * and emits events after marking is applied.\n     * * `onlySelf`: When true, mark only this control. When false or not supplied,\n     * marks all direct ancestors. Default is false.\n     */\n    markAsDirty(opts?: {\n        onlySelf?: boolean;\n    }): void;\n    /**\n     * Marks the control as `pristine`.\n     *\n     * If the control has any children, marks all children as `pristine`,\n     * and recalculates the `pristine` status of all parent\n     * controls.\n     *\n     * @see `markAsTouched()`\n     * @see `markAsUntouched()`\n     * @see `markAsDirty()`\n     *\n     * @param opts Configuration options that determine how the control emits events after\n     * marking is applied.\n     * * `onlySelf`: When true, mark only this control. When false or not supplied,\n     * marks all direct ancestors. Default is false.\n     */\n    markAsPristine(opts?: {\n        onlySelf?: boolean;\n    }): void;\n    /**\n     * Marks the control as `pending`.\n     *\n     * A control is pending while the control performs async validation.\n     *\n     * @see {@link AbstractControl.status}\n     *\n     * @param opts Configuration options that determine how the control propagates changes and\n     * emits events after marking is applied.\n     * * `onlySelf`: When true, mark only this control. When false or not supplied,\n     * marks all direct ancestors. Default is false.\n     * * `emitEvent`: When true or not supplied (the default), the `statusChanges`\n     * observable emits an event with the latest status the control is marked pending.\n     * When false, no events are emitted.\n     *\n     */\n    markAsPending(opts?: {\n        onlySelf?: boolean;\n        emitEvent?: boolean;\n    }): void;\n    /**\n     * Disables the control. This means the control is exempt from validation checks and\n     * excluded from the aggregate value of any parent. Its status is `DISABLED`.\n     *\n     * If the control has children, all children are also disabled.\n     *\n     * @see {@link AbstractControl.status}\n     *\n     * @param opts Configuration options that determine how the control propagates\n     * changes and emits events after the control is disabled.\n     * * `onlySelf`: When true, mark only this control. When false or not supplied,\n     * marks all direct ancestors. Default is false.\n     * * `emitEvent`: When true or not supplied (the default), both the `statusChanges` and\n     * `valueChanges`\n     * observables emit events with the latest status and value when the control is disabled.\n     * When false, no events are emitted.\n     */\n    disable(opts?: {\n        onlySelf?: boolean;\n        emitEvent?: boolean;\n    }): void;\n    /**\n     * Enables the control. This means the control is included in validation checks and\n     * the aggregate value of its parent. Its status recalculates based on its value and\n     * its validators.\n     *\n     * By default, if the control has children, all children are enabled.\n     *\n     * @see {@link AbstractControl.status}\n     *\n     * @param opts Configure options that control how the control propagates changes and\n     * emits events when marked as untouched\n     * * `onlySelf`: When true, mark only this control. When false or not supplied,\n     * marks all direct ancestors. Default is false.\n     * * `emitEvent`: When true or not supplied (the default), both the `statusChanges` and\n     * `valueChanges`\n     * observables emit events with the latest status and value when the control is enabled.\n     * When false, no events are emitted.\n     */\n    enable(opts?: {\n        onlySelf?: boolean;\n        emitEvent?: boolean;\n    }): void;\n    private _updateAncestors;\n    /**\n     * @param parent Sets the parent of the control\n     */\n    setParent(parent: FormGroup | FormArray): void;\n    /**\n     * Sets the value of the control. Abstract method (implemented in sub-classes).\n     */\n    abstract setValue(value: any, options?: Object): void;\n    /**\n     * Patches the value of the control. Abstract method (implemented in sub-classes).\n     */\n    abstract patchValue(value: any, options?: Object): void;\n    /**\n     * Resets the control. Abstract method (implemented in sub-classes).\n     */\n    abstract reset(value?: any, options?: Object): void;\n    /**\n     * Recalculates the value and validation status of the control.\n     *\n     * By default, it also updates the value and validity of its ancestors.\n     *\n     * @param opts Configuration options determine how the control propagates changes and emits events\n     * after updates and validity checks are applied.\n     * * `onlySelf`: When true, only update this control. When false or not supplied,\n     * update all direct ancestors. Default is false.\n     * * `emitEvent`: When true or not supplied (the default), both the `statusChanges` and\n     * `valueChanges`\n     * observables emit events with the latest status and value when the control is updated.\n     * When false, no events are emitted.\n     */\n    updateValueAndValidity(opts?: {\n        onlySelf?: boolean;\n        emitEvent?: boolean;\n    }): void;\n    private _setInitialStatus;\n    private _runValidator;\n    private _runAsyncValidator;\n    private _cancelExistingSubscription;\n    /**\n     * Sets errors on a form control when running validations manually, rather than automatically.\n     *\n     * Calling `setErrors` also updates the validity of the parent control.\n     *\n     * @usageNotes\n     *\n     * ### Manually set the errors for a control\n     *\n     * ```\n     * const login = new FormControl('someLogin');\n     * login.setErrors({\n     *   notUnique: true\n     * });\n     *\n     * expect(login.valid).toEqual(false);\n     * expect(login.errors).toEqual({ notUnique: true });\n     *\n     * login.setValue('someOtherLogin');\n     *\n     * expect(login.valid).toEqual(true);\n     * ```\n     */\n    setErrors(errors: ValidationErrors | null, opts?: {\n        emitEvent?: boolean;\n    }): void;\n    /**\n     * Retrieves a child control given the control's name or path.\n     *\n     * @param path A dot-delimited string or array of string/number values that define the path to the\n     * control.\n     *\n     * @usageNotes\n     * ### Retrieve a nested control\n     *\n     * For example, to get a `name` control nested within a `person` sub-group:\n     *\n     * * `this.form.get('person.name');`\n     *\n     * -OR-\n     *\n     * * `this.form.get(['person', 'name']);`\n     *\n     * ### Retrieve a control in a FormArray\n     *\n     * When accessing an element inside a FormArray, you can use an element index.\n     * For example, to get a `price` control from the first element in an `items` array you can use:\n     *\n     * * `this.form.get('items.0.price');`\n     *\n     * -OR-\n     *\n     * * `this.form.get(['items', 0, 'price']);`\n     */\n    get(path: Array<string | number> | string): AbstractControl | null;\n    /**\n     * @description\n     * Reports error data for the control with the given path.\n     *\n     * @param errorCode The code of the error to check\n     * @param path A list of control names that designates how to move from the current control\n     * to the control that should be queried for errors.\n     *\n     * @usageNotes\n     * For example, for the following `FormGroup`:\n     *\n     * ```\n     * form = new FormGroup({\n     *   address: new FormGroup({ street: new FormControl() })\n     * });\n     * ```\n     *\n     * The path to the 'street' control from the root form would be 'address' -> 'street'.\n     *\n     * It can be provided to this method in one of two formats:\n     *\n     * 1. An array of string control names, e.g. `['address', 'street']`\n     * 1. A period-delimited list of control names in one string, e.g. `'address.street'`\n     *\n     * @returns error data for that particular error. If the control or error is not present,\n     * null is returned.\n     */\n    getError(errorCode: string, path?: Array<string | number> | string): any;\n    /**\n     * @description\n     * Reports whether the control with the given path has the error specified.\n     *\n     * @param errorCode The code of the error to check\n     * @param path A list of control names that designates how to move from the current control\n     * to the control that should be queried for errors.\n     *\n     * @usageNotes\n     * For example, for the following `FormGroup`:\n     *\n     * ```\n     * form = new FormGroup({\n     *   address: new FormGroup({ street: new FormControl() })\n     * });\n     * ```\n     *\n     * The path to the 'street' control from the root form would be 'address' -> 'street'.\n     *\n     * It can be provided to this method in one of two formats:\n     *\n     * 1. An array of string control names, e.g. `['address', 'street']`\n     * 1. A period-delimited list of control names in one string, e.g. `'address.street'`\n     *\n     * If no path is given, this method checks for the error on the current control.\n     *\n     * @returns whether the given error is present in the control at the given path.\n     *\n     * If the control is not present, false is returned.\n     */\n    hasError(errorCode: string, path?: Array<string | number> | string): boolean;\n    /**\n     * Retrieves the top-level ancestor of this control.\n     */\n    get root(): AbstractControl;\n    private _calculateStatus;\n}\n\n/**\n * @description\n * Base class for control directives.\n *\n * This class is only used internally in the `ReactiveFormsModule` and the `FormsModule`.\n *\n * @publicApi\n */\nexport declare abstract class AbstractControlDirective {\n    /**\n     * @description\n     * A reference to the underlying control.\n     *\n     * @returns the control that backs this directive. Most properties fall through to that instance.\n     */\n    abstract get control(): AbstractControl | null;\n    /**\n     * @description\n     * Reports the value of the control if it is present, otherwise null.\n     */\n    get value(): any;\n    /**\n     * @description\n     * Reports whether the control is valid. A control is considered valid if no\n     * validation errors exist with the current value.\n     * If the control is not present, null is returned.\n     */\n    get valid(): boolean | null;\n    /**\n     * @description\n     * Reports whether the control is invalid, meaning that an error exists in the input value.\n     * If the control is not present, null is returned.\n     */\n    get invalid(): boolean | null;\n    /**\n     * @description\n     * Reports whether a control is pending, meaning that that async validation is occurring and\n     * errors are not yet available for the input value. If the control is not present, null is\n     * returned.\n     */\n    get pending(): boolean | null;\n    /**\n     * @description\n     * Reports whether the control is disabled, meaning that the control is disabled\n     * in the UI and is exempt from validation checks and excluded from aggregate\n     * values of ancestor controls. If the control is not present, null is returned.\n     */\n    get disabled(): boolean | null;\n    /**\n     * @description\n     * Reports whether the control is enabled, meaning that the control is included in ancestor\n     * calculations of validity or value. If the control is not present, null is returned.\n     */\n    get enabled(): boolean | null;\n    /**\n     * @description\n     * Reports the control's validation errors. If the control is not present, null is returned.\n     */\n    get errors(): ValidationErrors | null;\n    /**\n     * @description\n     * Reports whether the control is pristine, meaning that the user has not yet changed\n     * the value in the UI. If the control is not present, null is returned.\n     */\n    get pristine(): boolean | null;\n    /**\n     * @description\n     * Reports whether the control is dirty, meaning that the user has changed\n     * the value in the UI. If the control is not present, null is returned.\n     */\n    get dirty(): boolean | null;\n    /**\n     * @description\n     * Reports whether the control is touched, meaning that the user has triggered\n     * a `blur` event on it. If the control is not present, null is returned.\n     */\n    get touched(): boolean | null;\n    /**\n     * @description\n     * Reports the validation status of the control. Possible values include:\n     * 'VALID', 'INVALID', 'DISABLED', and 'PENDING'.\n     * If the control is not present, null is returned.\n     */\n    get status(): string | null;\n    /**\n     * @description\n     * Reports whether the control is untouched, meaning that the user has not yet triggered\n     * a `blur` event on it. If the control is not present, null is returned.\n     */\n    get untouched(): boolean | null;\n    /**\n     * @description\n     * Returns a multicasting observable that emits a validation status whenever it is\n     * calculated for the control. If the control is not present, null is returned.\n     */\n    get statusChanges(): Observable<any> | null;\n    /**\n     * @description\n     * Returns a multicasting observable of value changes for the control that emits every time the\n     * value of the control changes in the UI or programmatically.\n     * If the control is not present, null is returned.\n     */\n    get valueChanges(): Observable<any> | null;\n    /**\n     * @description\n     * Returns an array that represents the path from the top-level form to this control.\n     * Each index is the string name of the control on that level.\n     */\n    get path(): string[] | null;\n    /**\n     * Contains the result of merging synchronous validators into a single validator function\n     * (combined using `Validators.compose`).\n     */\n    private _composedValidatorFn;\n    /**\n     * Contains the result of merging asynchronous validators into a single validator function\n     * (combined using `Validators.composeAsync`).\n     */\n    private _composedAsyncValidatorFn;\n    /**\n     * @description\n     * Synchronous validator function composed of all the synchronous validators registered with this\n     * directive.\n     */\n    get validator(): ValidatorFn | null;\n    /**\n     * @description\n     * Asynchronous validator function composed of all the asynchronous validators registered with\n     * this directive.\n     */\n    get asyncValidator(): AsyncValidatorFn | null;\n    private _onDestroyCallbacks;\n    /**\n     * @description\n     * Resets the control with the provided value if the control is present.\n     */\n    reset(value?: any): void;\n    /**\n     * @description\n     * Reports whether the control with the given path has the error specified.\n     *\n     * @param errorCode The code of the error to check\n     * @param path A list of control names that designates how to move from the current control\n     * to the control that should be queried for errors.\n     *\n     * @usageNotes\n     * For example, for the following `FormGroup`:\n     *\n     * ```\n     * form = new FormGroup({\n     *   address: new FormGroup({ street: new FormControl() })\n     * });\n     * ```\n     *\n     * The path to the 'street' control from the root form would be 'address' -> 'street'.\n     *\n     * It can be provided to this method in one of two formats:\n     *\n     * 1. An array of string control names, e.g. `['address', 'street']`\n     * 1. A period-delimited list of control names in one string, e.g. `'address.street'`\n     *\n     * If no path is given, this method checks for the error on the current control.\n     *\n     * @returns whether the given error is present in the control at the given path.\n     *\n     * If the control is not present, false is returned.\n     */\n    hasError(errorCode: string, path?: Array<string | number> | string): boolean;\n    /**\n     * @description\n     * Reports error data for the control with the given path.\n     *\n     * @param errorCode The code of the error to check\n     * @param path A list of control names that designates how to move from the current control\n     * to the control that should be queried for errors.\n     *\n     * @usageNotes\n     * For example, for the following `FormGroup`:\n     *\n     * ```\n     * form = new FormGroup({\n     *   address: new FormGroup({ street: new FormControl() })\n     * });\n     * ```\n     *\n     * The path to the 'street' control from the root form would be 'address' -> 'street'.\n     *\n     * It can be provided to this method in one of two formats:\n     *\n     * 1. An array of string control names, e.g. `['address', 'street']`\n     * 1. A period-delimited list of control names in one string, e.g. `'address.street'`\n     *\n     * @returns error data for that particular error. If the control or error is not present,\n     * null is returned.\n     */\n    getError(errorCode: string, path?: Array<string | number> | string): any;\n}\n\n/**\n * Interface for options provided to an `AbstractControl`.\n *\n * @publicApi\n */\nexport declare interface AbstractControlOptions {\n    /**\n     * @description\n     * The list of validators applied to a control.\n     */\n    validators?: ValidatorFn | ValidatorFn[] | null;\n    /**\n     * @description\n     * The list of async validators applied to control.\n     */\n    asyncValidators?: AsyncValidatorFn | AsyncValidatorFn[] | null;\n    /**\n     * @description\n     * The event name for control to update upon.\n     */\n    updateOn?: 'change' | 'blur' | 'submit';\n}\n\n/**\n * @description\n * A base class for code shared between the `NgModelGroup` and `FormGroupName` directives.\n *\n * @publicApi\n */\nexport declare class AbstractFormGroupDirective extends ControlContainer implements OnInit, OnDestroy {\n    /** @nodoc */\n    ngOnInit(): void;\n    /** @nodoc */\n    ngOnDestroy(): void;\n    /**\n     * @description\n     * The `FormGroup` bound to this directive.\n     */\n    get control(): FormGroup;\n    /**\n     * @description\n     * The path to this group from the top-level directive.\n     */\n    get path(): string[];\n    /**\n     * @description\n     * The top-level directive for this group if present, otherwise null.\n     */\n    get formDirective(): Form | null;\n}\n\n/**\n * A base class for Validator-based Directives. The class contains common logic shared across such\n * Directives.\n *\n * For internal use only, this class is not intended for use outside of the Forms package.\n */\ndeclare abstract class AbstractValidatorDirective implements Validator {\n    private _validator;\n    private _onChange;\n    /**\n     * Helper function invoked from child classes to process changes (from `ngOnChanges` hook).\n     * @nodoc\n     */\n    handleChanges(changes: SimpleChanges): void;\n    /** @nodoc */\n    validate(control: AbstractControl): ValidationErrors | null;\n    /** @nodoc */\n    registerOnValidatorChange(fn: () => void): void;\n}\n\ndeclare type AnyControlStatus = 'untouched' | 'touched' | 'pristine' | 'dirty' | 'valid' | 'invalid' | 'pending' | 'submitted';\n\n/**\n * @description\n * An interface implemented by classes that perform asynchronous validation.\n *\n * @usageNotes\n *\n * ### Provide a custom async validator directive\n *\n * The following example implements the `AsyncValidator` interface to create an\n * async validator directive with a custom error key.\n *\n * ```typescript\n * import { of } from 'rxjs';\n *\n * @Directive({\n *   selector: '[customAsyncValidator]',\n *   providers: [{provide: NG_ASYNC_VALIDATORS, useExisting: CustomAsyncValidatorDirective, multi:\n * true}]\n * })\n * class CustomAsyncValidatorDirective implements AsyncValidator {\n *   validate(control: AbstractControl): Observable<ValidationErrors|null> {\n *     return of({'custom': true});\n *   }\n * }\n * ```\n *\n * @publicApi\n */\nexport declare interface AsyncValidator extends Validator {\n    /**\n     * @description\n     * Method that performs async validation against the provided control.\n     *\n     * @param control The control to validate against.\n     *\n     * @returns A promise or observable that resolves a map of validation errors\n     * if validation fails, otherwise null.\n     */\n    validate(control: AbstractControl): Promise<ValidationErrors | null> | Observable<ValidationErrors | null>;\n}\n\n/**\n * @description\n * A function that receives a control and returns a Promise or observable\n * that emits validation errors if present, otherwise null.\n *\n * @publicApi\n */\nexport declare interface AsyncValidatorFn {\n    (control: AbstractControl): Promise<ValidationErrors | null> | Observable<ValidationErrors | null>;\n}\n\n/**\n * @description\n * A `ControlValueAccessor` for writing a value and listening to changes on a checkbox input\n * element.\n *\n * @usageNotes\n *\n * ### Using a checkbox with a reactive form.\n *\n * The following example shows how to use a checkbox with a reactive form.\n *\n * ```ts\n * const rememberLoginControl = new FormControl();\n * ```\n *\n * ```\n * <input type=\"checkbox\" [formControl]=\"rememberLoginControl\">\n * ```\n *\n * @ngModule ReactiveFormsModule\n * @ngModule FormsModule\n * @publicApi\n */\nexport declare class CheckboxControlValueAccessor extends ɵangular_packages_forms_forms_g implements ControlValueAccessor {\n    /**\n     * Sets the \"checked\" property on the input element.\n     * @nodoc\n     */\n    writeValue(value: any): void;\n}\n\n/**\n * A Directive that adds the `required` validator to checkbox controls marked with the\n * `required` attribute. The directive is provided with the `NG_VALIDATORS` multi-provider list.\n *\n * @see [Form Validation](guide/form-validation)\n *\n * @usageNotes\n *\n * ### Adding a required checkbox validator using template-driven forms\n *\n * The following example shows how to add a checkbox required validator to an input attached to an\n * ngModel binding.\n *\n * ```\n * <input type=\"checkbox\" name=\"active\" ngModel required>\n * ```\n *\n * @publicApi\n * @ngModule FormsModule\n * @ngModule ReactiveFormsModule\n */\nexport declare class CheckboxRequiredValidator extends RequiredValidator {\n    /**\n     * Method that validates whether or not the checkbox has been checked.\n     * Returns the validation result if enabled, otherwise null.\n     * @nodoc\n     */\n    validate(control: AbstractControl): ValidationErrors | null;\n}\n\n/**\n * @description\n * Provide this token to control if form directives buffer IME input until\n * the \"compositionend\" event occurs.\n * @publicApi\n */\nexport declare const COMPOSITION_BUFFER_MODE: InjectionToken<boolean>;\n\n/**\n * @description\n * A base class for directives that contain multiple registered instances of `NgControl`.\n * Only used by the forms module.\n *\n * @publicApi\n */\nexport declare abstract class ControlContainer extends AbstractControlDirective {\n    /**\n     * @description\n     * The name for the control\n     */\n    name: string | number | null;\n    /**\n     * @description\n     * The top-level form directive for the control.\n     */\n    get formDirective(): Form | null;\n    /**\n     * @description\n     * The path to this group.\n     */\n    get path(): string[] | null;\n}\n\n/**\n * @description\n * Defines an interface that acts as a bridge between the Angular forms API and a\n * native element in the DOM.\n *\n * Implement this interface to create a custom form control directive\n * that integrates with Angular forms.\n *\n * @see DefaultValueAccessor\n *\n * @publicApi\n */\nexport declare interface ControlValueAccessor {\n    /**\n     * @description\n     * Writes a new value to the element.\n     *\n     * This method is called by the forms API to write to the view when programmatic\n     * changes from model to view are requested.\n     *\n     * @usageNotes\n     * ### Write a value to the element\n     *\n     * The following example writes a value to the native DOM element.\n     *\n     * ```ts\n     * writeValue(value: any): void {\n     *   this._renderer.setProperty(this._elementRef.nativeElement, 'value', value);\n     * }\n     * ```\n     *\n     * @param obj The new value for the element\n     */\n    writeValue(obj: any): void;\n    /**\n     * @description\n     * Registers a callback function that is called when the control's value\n     * changes in the UI.\n     *\n     * This method is called by the forms API on initialization to update the form\n     * model when values propagate from the view to the model.\n     *\n     * When implementing the `registerOnChange` method in your own value accessor,\n     * save the given function so your class calls it at the appropriate time.\n     *\n     * @usageNotes\n     * ### Store the change function\n     *\n     * The following example stores the provided function as an internal method.\n     *\n     * ```ts\n     * registerOnChange(fn: (_: any) => void): void {\n     *   this._onChange = fn;\n     * }\n     * ```\n     *\n     * When the value changes in the UI, call the registered\n     * function to allow the forms API to update itself:\n     *\n     * ```ts\n     * host: {\n     *    '(change)': '_onChange($event.target.value)'\n     * }\n     * ```\n     *\n     * @param fn The callback function to register\n     */\n    registerOnChange(fn: any): void;\n    /**\n     * @description\n     * Registers a callback function that is called by the forms API on initialization\n     * to update the form model on blur.\n     *\n     * When implementing `registerOnTouched` in your own value accessor, save the given\n     * function so your class calls it when the control should be considered\n     * blurred or \"touched\".\n     *\n     * @usageNotes\n     * ### Store the callback function\n     *\n     * The following example stores the provided function as an internal method.\n     *\n     * ```ts\n     * registerOnTouched(fn: any): void {\n     *   this._onTouched = fn;\n     * }\n     * ```\n     *\n     * On blur (or equivalent), your class should call the registered function to allow\n     * the forms API to update itself:\n     *\n     * ```ts\n     * host: {\n     *    '(blur)': '_onTouched()'\n     * }\n     * ```\n     *\n     * @param fn The callback function to register\n     */\n    registerOnTouched(fn: any): void;\n    /**\n     * @description\n     * Function that is called by the forms API when the control status changes to\n     * or from 'DISABLED'. Depending on the status, it enables or disables the\n     * appropriate DOM element.\n     *\n     * @usageNotes\n     * The following is an example of writing the disabled property to a native DOM element:\n     *\n     * ```ts\n     * setDisabledState(isDisabled: boolean): void {\n     *   this._renderer.setProperty(this._elementRef.nativeElement, 'disabled', isDisabled);\n     * }\n     * ```\n     *\n     * @param isDisabled The disabled status to set on the element\n     */\n    setDisabledState?(isDisabled: boolean): void;\n}\n\n/**\n * The default `ControlValueAccessor` for writing a value and listening to changes on input\n * elements. The accessor is used by the `FormControlDirective`, `FormControlName`, and\n * `NgModel` directives.\n *\n * {@searchKeywords ngDefaultControl}\n *\n * @usageNotes\n *\n * ### Using the default value accessor\n *\n * The following example shows how to use an input element that activates the default value accessor\n * (in this case, a text field).\n *\n * ```ts\n * const firstNameControl = new FormControl();\n * ```\n *\n * ```\n * <input type=\"text\" [formControl]=\"firstNameControl\">\n * ```\n *\n * This value accessor is used by default for `<input type=\"text\">` and `<textarea>` elements, but\n * you could also use it for custom components that have similar behavior and do not require special\n * processing. In order to attach the default value accessor to a custom element, add the\n * `ngDefaultControl` attribute as shown below.\n *\n * ```\n * <custom-input-component ngDefaultControl [(ngModel)]=\"value\"></custom-input-component>\n * ```\n *\n * @ngModule ReactiveFormsModule\n * @ngModule FormsModule\n * @publicApi\n */\nexport declare class DefaultValueAccessor extends ɵangular_packages_forms_forms_f implements ControlValueAccessor {\n    private _compositionMode;\n    /** Whether the user is creating a composition string (IME events). */\n    private _composing;\n    constructor(renderer: Renderer2, elementRef: ElementRef, _compositionMode: boolean);\n    /**\n     * Sets the \"value\" property on the input element.\n     * @nodoc\n     */\n    writeValue(value: any): void;\n}\n\n/**\n * A directive that adds the `email` validator to controls marked with the\n * `email` attribute. The directive is provided with the `NG_VALIDATORS` multi-provider list.\n *\n * @see [Form Validation](guide/form-validation)\n *\n * @usageNotes\n *\n * ### Adding an email validator\n *\n * The following example shows how to add an email validator to an input attached to an ngModel\n * binding.\n *\n * ```\n * <input type=\"email\" name=\"email\" ngModel email>\n * <input type=\"email\" name=\"email\" ngModel email=\"true\">\n * <input type=\"email\" name=\"email\" ngModel [email]=\"true\">\n * ```\n *\n * @publicApi\n * @ngModule FormsModule\n * @ngModule ReactiveFormsModule\n */\nexport declare class EmailValidator implements Validator {\n    private _enabled;\n    private _onChange?;\n    /**\n     * @description\n     * Tracks changes to the email attribute bound to this directive.\n     */\n    set email(value: boolean | string);\n    /**\n     * Method that validates whether an email address is valid.\n     * Returns the validation result if enabled, otherwise null.\n     * @nodoc\n     */\n    validate(control: AbstractControl): ValidationErrors | null;\n    /**\n     * Registers a callback function to call when the validator inputs change.\n     * @nodoc\n     */\n    registerOnValidatorChange(fn: () => void): void;\n}\n\n/**\n * @description\n * An interface implemented by `FormGroupDirective` and `NgForm` directives.\n *\n * Only used by the `ReactiveFormsModule` and `FormsModule`.\n *\n * @publicApi\n */\nexport declare interface Form {\n    /**\n     * @description\n     * Add a control to this form.\n     *\n     * @param dir The control directive to add to the form.\n     */\n    addControl(dir: NgControl): void;\n    /**\n     * @description\n     * Remove a control from this form.\n     *\n     * @param dir: The control directive to remove from the form.\n     */\n    removeControl(dir: NgControl): void;\n    /**\n     * @description\n     * The control directive from which to get the `FormControl`.\n     *\n     * @param dir: The control directive.\n     */\n    getControl(dir: NgControl): FormControl;\n    /**\n     * @description\n     * Add a group of controls to this form.\n     *\n     * @param dir: The control group directive to add.\n     */\n    addFormGroup(dir: AbstractFormGroupDirective): void;\n    /**\n     * @description\n     * Remove a group of controls to this form.\n     *\n     * @param dir: The control group directive to remove.\n     */\n    removeFormGroup(dir: AbstractFormGroupDirective): void;\n    /**\n     * @description\n     * The `FormGroup` associated with a particular `AbstractFormGroupDirective`.\n     *\n     * @param dir: The form group directive from which to get the `FormGroup`.\n     */\n    getFormGroup(dir: AbstractFormGroupDirective): FormGroup;\n    /**\n     * @description\n     * Update the model for a particular control with a new value.\n     *\n     * @param dir: The control directive to update.\n     * @param value: The new value for the control.\n     */\n    updateModel(dir: NgControl, value: any): void;\n}\n\n/**\n * Tracks the value and validity state of an array of `FormControl`,\n * `FormGroup` or `FormArray` instances.\n *\n * A `FormArray` aggregates the values of each child `FormControl` into an array.\n * It calculates its status by reducing the status values of its children. For example, if one of\n * the controls in a `FormArray` is invalid, the entire array becomes invalid.\n *\n * `FormArray` is one of the three fundamental building blocks used to define forms in Angular,\n * along with `FormControl` and `FormGroup`.\n *\n * @usageNotes\n *\n * ### Create an array of form controls\n *\n * ```\n * const arr = new FormArray([\n *   new FormControl('Nancy', Validators.minLength(2)),\n *   new FormControl('Drew'),\n * ]);\n *\n * console.log(arr.value);   // ['Nancy', 'Drew']\n * console.log(arr.status);  // 'VALID'\n * ```\n *\n * ### Create a form array with array-level validators\n *\n * You include array-level validators and async validators. These come in handy\n * when you want to perform validation that considers the value of more than one child\n * control.\n *\n * The two types of validators are passed in separately as the second and third arg\n * respectively, or together as part of an options object.\n *\n * ```\n * const arr = new FormArray([\n *   new FormControl('Nancy'),\n *   new FormControl('Drew')\n * ], {validators: myValidator, asyncValidators: myAsyncValidator});\n * ```\n *\n * ### Set the updateOn property for all controls in a form array\n *\n * The options object is used to set a default value for each child\n * control's `updateOn` property. If you set `updateOn` to `'blur'` at the\n * array level, all child controls default to 'blur', unless the child\n * has explicitly specified a different `updateOn` value.\n *\n * ```ts\n * const arr = new FormArray([\n *    new FormControl()\n * ], {updateOn: 'blur'});\n * ```\n *\n * ### Adding or removing controls from a form array\n *\n * To change the controls in the array, use the `push`, `insert`, `removeAt` or `clear` methods\n * in `FormArray` itself. These methods ensure the controls are properly tracked in the\n * form's hierarchy. Do not modify the array of `AbstractControl`s used to instantiate\n * the `FormArray` directly, as that result in strange and unexpected behavior such\n * as broken change detection.\n *\n * @publicApi\n */\nexport declare class FormArray extends AbstractControl {\n    controls: AbstractControl[];\n    /**\n     * Creates a new `FormArray` instance.\n     *\n     * @param controls An array of child controls. Each child control is given an index\n     * where it is registered.\n     *\n     * @param validatorOrOpts A synchronous validator function, or an array of\n     * such functions, or an `AbstractControlOptions` object that contains validation functions\n     * and a validation trigger.\n     *\n     * @param asyncValidator A single async validator or array of async validator functions\n     *\n     */\n    constructor(controls: AbstractControl[], validatorOrOpts?: ValidatorFn | ValidatorFn[] | AbstractControlOptions | null, asyncValidator?: AsyncValidatorFn | AsyncValidatorFn[] | null);\n    /**\n     * Get the `AbstractControl` at the given `index` in the array.\n     *\n     * @param index Index in the array to retrieve the control\n     */\n    at(index: number): AbstractControl;\n    /**\n     * Insert a new `AbstractControl` at the end of the array.\n     *\n     * @param control Form control to be inserted\n     * @param options Specifies whether this FormArray instance should emit events after a new\n     *     control is added.\n     * * `emitEvent`: When true or not supplied (the default), both the `statusChanges` and\n     * `valueChanges` observables emit events with the latest status and value when the control is\n     * inserted. When false, no events are emitted.\n     */\n    push(control: AbstractControl, options?: {\n        emitEvent?: boolean;\n    }): void;\n    /**\n     * Insert a new `AbstractControl` at the given `index` in the array.\n     *\n     * @param index Index in the array to insert the control\n     * @param control Form control to be inserted\n     * @param options Specifies whether this FormArray instance should emit events after a new\n     *     control is inserted.\n     * * `emitEvent`: When true or not supplied (the default), both the `statusChanges` and\n     * `valueChanges` observables emit events with the latest status and value when the control is\n     * inserted. When false, no events are emitted.\n     */\n    insert(index: number, control: AbstractControl, options?: {\n        emitEvent?: boolean;\n    }): void;\n    /**\n     * Remove the control at the given `index` in the array.\n     *\n     * @param index Index in the array to remove the control\n     * @param options Specifies whether this FormArray instance should emit events after a\n     *     control is removed.\n     * * `emitEvent`: When true or not supplied (the default), both the `statusChanges` and\n     * `valueChanges` observables emit events with the latest status and value when the control is\n     * removed. When false, no events are emitted.\n     */\n    removeAt(index: number, options?: {\n        emitEvent?: boolean;\n    }): void;\n    /**\n     * Replace an existing control.\n     *\n     * @param index Index in the array to replace the control\n     * @param control The `AbstractControl` control to replace the existing control\n     * @param options Specifies whether this FormArray instance should emit events after an\n     *     existing control is replaced with a new one.\n     * * `emitEvent`: When true or not supplied (the default), both the `statusChanges` and\n     * `valueChanges` observables emit events with the latest status and value when the control is\n     * replaced with a new one. When false, no events are emitted.\n     */\n    setControl(index: number, control: AbstractControl, options?: {\n        emitEvent?: boolean;\n    }): void;\n    /**\n     * Length of the control array.\n     */\n    get length(): number;\n    /**\n     * Sets the value of the `FormArray`. It accepts an array that matches\n     * the structure of the control.\n     *\n     * This method performs strict checks, and throws an error if you try\n     * to set the value of a control that doesn't exist or if you exclude the\n     * value of a control.\n     *\n     * @usageNotes\n     * ### Set the values for the controls in the form array\n     *\n     * ```\n     * const arr = new FormArray([\n     *   new FormControl(),\n     *   new FormControl()\n     * ]);\n     * console.log(arr.value);   // [null, null]\n     *\n     * arr.setValue(['Nancy', 'Drew']);\n     * console.log(arr.value);   // ['Nancy', 'Drew']\n     * ```\n     *\n     * @param value Array of values for the controls\n     * @param options Configure options that determine how the control propagates changes and\n     * emits events after the value changes\n     *\n     * * `onlySelf`: When true, each change only affects this control, and not its parent. Default\n     * is false.\n     * * `emitEvent`: When true or not supplied (the default), both the `statusChanges` and\n     * `valueChanges`\n     * observables emit events with the latest status and value when the control value is updated.\n     * When false, no events are emitted.\n     * The configuration options are passed to the {@link AbstractControl#updateValueAndValidity\n     * updateValueAndValidity} method.\n     */\n    setValue(value: any[], options?: {\n        onlySelf?: boolean;\n        emitEvent?: boolean;\n    }): void;\n    /**\n     * Patches the value of the `FormArray`. It accepts an array that matches the\n     * structure of the control, and does its best to match the values to the correct\n     * controls in the group.\n     *\n     * It accepts both super-sets and sub-sets of the array without throwing an error.\n     *\n     * @usageNotes\n     * ### Patch the values for controls in a form array\n     *\n     * ```\n     * const arr = new FormArray([\n     *    new FormControl(),\n     *    new FormControl()\n     * ]);\n     * console.log(arr.value);   // [null, null]\n     *\n     * arr.patchValue(['Nancy']);\n     * console.log(arr.value);   // ['Nancy', null]\n     * ```\n     *\n     * @param value Array of latest values for the controls\n     * @param options Configure options that determine how the control propagates changes and\n     * emits events after the value changes\n     *\n     * * `onlySelf`: When true, each change only affects this control, and not its parent. Default\n     * is false.\n     * * `emitEvent`: When true or not supplied (the default), both the `statusChanges` and\n     * `valueChanges` observables emit events with the latest status and value when the control value\n     * is updated. When false, no events are emitted. The configuration options are passed to\n     * the {@link AbstractControl#updateValueAndValidity updateValueAndValidity} method.\n     */\n    patchValue(value: any[], options?: {\n        onlySelf?: boolean;\n        emitEvent?: boolean;\n    }): void;\n    /**\n     * Resets the `FormArray` and all descendants are marked `pristine` and `untouched`, and the\n     * value of all descendants to null or null maps.\n     *\n     * You reset to a specific form state by passing in an array of states\n     * that matches the structure of the control. The state is a standalone value\n     * or a form state object with both a value and a disabled status.\n     *\n     * @usageNotes\n     * ### Reset the values in a form array\n     *\n     * ```ts\n     * const arr = new FormArray([\n     *    new FormControl(),\n     *    new FormControl()\n     * ]);\n     * arr.reset(['name', 'last name']);\n     *\n     * console.log(arr.value);  // ['name', 'last name']\n     * ```\n     *\n     * ### Reset the values in a form array and the disabled status for the first control\n     *\n     * ```\n     * arr.reset([\n     *   {value: 'name', disabled: true},\n     *   'last'\n     * ]);\n     *\n     * console.log(arr.value);  // ['last']\n     * console.log(arr.at(0).status);  // 'DISABLED'\n     * ```\n     *\n     * @param value Array of values for the controls\n     * @param options Configure options that determine how the control propagates changes and\n     * emits events after the value changes\n     *\n     * * `onlySelf`: When true, each change only affects this control, and not its parent. Default\n     * is false.\n     * * `emitEvent`: When true or not supplied (the default), both the `statusChanges` and\n     * `valueChanges`\n     * observables emit events with the latest status and value when the control is reset.\n     * When false, no events are emitted.\n     * The configuration options are passed to the {@link AbstractControl#updateValueAndValidity\n     * updateValueAndValidity} method.\n     */\n    reset(value?: any, options?: {\n        onlySelf?: boolean;\n        emitEvent?: boolean;\n    }): void;\n    /**\n     * The aggregate value of the array, including any disabled controls.\n     *\n     * Reports all values regardless of disabled status.\n     * For enabled controls only, the `value` property is the best way to get the value of the array.\n     */\n    getRawValue(): any[];\n    /**\n     * Remove all controls in the `FormArray`.\n     *\n     * @param options Specifies whether this FormArray instance should emit events after all\n     *     controls are removed.\n     * * `emitEvent`: When true or not supplied (the default), both the `statusChanges` and\n     * `valueChanges` observables emit events with the latest status and value when all controls\n     * in this FormArray instance are removed. When false, no events are emitted.\n     *\n     * @usageNotes\n     * ### Remove all elements from a FormArray\n     *\n     * ```ts\n     * const arr = new FormArray([\n     *    new FormControl(),\n     *    new FormControl()\n     * ]);\n     * console.log(arr.length);  // 2\n     *\n     * arr.clear();\n     * console.log(arr.length);  // 0\n     * ```\n     *\n     * It's a simpler and more efficient alternative to removing all elements one by one:\n     *\n     * ```ts\n     * const arr = new FormArray([\n     *    new FormControl(),\n     *    new FormControl()\n     * ]);\n     *\n     * while (arr.length) {\n     *    arr.removeAt(0);\n     * }\n     * ```\n     */\n    clear(options?: {\n        emitEvent?: boolean;\n    }): void;\n    private _registerControl;\n}\n\n/**\n * @description\n *\n * Syncs a nested `FormArray` to a DOM element.\n *\n * This directive is designed to be used with a parent `FormGroupDirective` (selector:\n * `[formGroup]`).\n *\n * It accepts the string name of the nested `FormArray` you want to link, and\n * will look for a `FormArray` registered with that name in the parent\n * `FormGroup` instance you passed into `FormGroupDirective`.\n *\n * @see [Reactive Forms Guide](guide/reactive-forms)\n * @see `AbstractControl`\n *\n * @usageNotes\n *\n * ### Example\n *\n * {@example forms/ts/nestedFormArray/nested_form_array_example.ts region='Component'}\n *\n * @ngModule ReactiveFormsModule\n * @publicApi\n */\nexport declare class FormArrayName extends ControlContainer implements OnInit, OnDestroy {\n    /**\n     * @description\n     * Tracks the name of the `FormArray` bound to the directive. The name corresponds\n     * to a key in the parent `FormGroup` or `FormArray`.\n     * Accepts a name as a string or a number.\n     * The name in the form of a string is useful for individual forms,\n     * while the numerical form allows for form arrays to be bound\n     * to indices when iterating over arrays in a `FormArray`.\n     */\n    name: string | number | null;\n    constructor(parent: ControlContainer, validators: (Validator | ValidatorFn)[], asyncValidators: (AsyncValidator | AsyncValidatorFn)[]);\n    /**\n     * A lifecycle method called when the directive's inputs are initialized. For internal use only.\n     * @throws If the directive does not have a valid parent.\n     * @nodoc\n     */\n    ngOnInit(): void;\n    /**\n     * A lifecycle method called before the directive's instance is destroyed. For internal use only.\n     * @nodoc\n     */\n    ngOnDestroy(): void;\n    /**\n     * @description\n     * The `FormArray` bound to this directive.\n     */\n    get control(): FormArray;\n    /**\n     * @description\n     * The top-level directive for this group if present, otherwise null.\n     */\n    get formDirective(): FormGroupDirective | null;\n    /**\n     * @description\n     * Returns an array that represents the path from the top-level form to this control.\n     * Each index is the string name of the control on that level.\n     */\n    get path(): string[];\n    private _checkParentType;\n}\n\n/**\n * @description\n * Creates an `AbstractControl` from a user-specified configuration.\n *\n * The `FormBuilder` provides syntactic sugar that shortens creating instances of a `FormControl`,\n * `FormGroup`, or `FormArray`. It reduces the amount of boilerplate needed to build complex\n * forms.\n *\n * @see [Reactive Forms Guide](/guide/reactive-forms)\n *\n * @publicApi\n */\nexport declare class FormBuilder {\n    /**\n     * @description\n     * Construct a new `FormGroup` instance.\n     *\n     * @param controlsConfig A collection of child controls. The key for each child is the name\n     * under which it is registered.\n     *\n     * @param options Configuration options object for the `FormGroup`. The object should have the\n     * the `AbstractControlOptions` type and might contain the following fields:\n     * * `validators`: A synchronous validator function, or an array of validator functions\n     * * `asyncValidators`: A single async validator or array of async validator functions\n     * * `updateOn`: The event upon which the control should be updated (options: 'change' | 'blur' |\n     * submit')\n     */\n    group(controlsConfig: {\n        [key: string]: any;\n    }, options?: AbstractControlOptions | null): FormGroup;\n    /**\n     * @description\n     * Construct a new `FormGroup` instance.\n     *\n     * @deprecated This API is not typesafe and can result in issues with Closure Compiler renaming.\n     * Use the `FormBuilder#group` overload with `AbstractControlOptions` instead.\n     * Note that `AbstractControlOptions` expects `validators` and `asyncValidators` to be valid\n     * validators. If you have custom validators, make sure their validation function parameter is\n     * `AbstractControl` and not a sub-class, such as `FormGroup`. These functions will be called with\n     * an object of type `AbstractControl` and that cannot be automatically downcast to a subclass, so\n     * TypeScript sees this as an error. For example, change the `(group: FormGroup) =>\n     * ValidationErrors|null` signature to be `(group: AbstractControl) => ValidationErrors|null`.\n     *\n     * @param controlsConfig A collection of child controls. The key for each child is the name\n     * under which it is registered.\n     *\n     * @param options Configuration options object for the `FormGroup`. The legacy configuration\n     * object consists of:\n     * * `validator`: A synchronous validator function, or an array of validator functions\n     * * `asyncValidator`: A single async validator or array of async validator functions\n     * Note: the legacy format is deprecated and might be removed in one of the next major versions\n     * of Angular.\n     */\n    group(controlsConfig: {\n        [key: string]: any;\n    }, options: {\n        [key: string]: any;\n    }): FormGroup;\n    /**\n     * @description\n     * Construct a new `FormControl` with the given state, validators and options.\n     *\n     * @param formState Initializes the control with an initial state value, or\n     * with an object that contains both a value and a disabled status.\n     *\n     * @param validatorOrOpts A synchronous validator function, or an array of\n     * such functions, or an `AbstractControlOptions` object that contains\n     * validation functions and a validation trigger.\n     *\n     * @param asyncValidator A single async validator or array of async validator\n     * functions.\n     *\n     * @usageNotes\n     *\n     * ### Initialize a control as disabled\n     *\n     * The following example returns a control with an initial value in a disabled state.\n     *\n     * <code-example path=\"forms/ts/formBuilder/form_builder_example.ts\" region=\"disabled-control\">\n     * </code-example>\n     */\n    control(formState: any, validatorOrOpts?: ValidatorFn | ValidatorFn[] | AbstractControlOptions | null, asyncValidator?: AsyncValidatorFn | AsyncValidatorFn[] | null): FormControl;\n    /**\n     * Constructs a new `FormArray` from the given array of configurations,\n     * validators and options.\n     *\n     * @param controlsConfig An array of child controls or control configs. Each\n     * child control is given an index when it is registered.\n     *\n     * @param validatorOrOpts A synchronous validator function, or an array of\n     * such functions, or an `AbstractControlOptions` object that contains\n     * validation functions and a validation trigger.\n     *\n     * @param asyncValidator A single async validator or array of async validator\n     * functions.\n     */\n    array(controlsConfig: any[], validatorOrOpts?: ValidatorFn | ValidatorFn[] | AbstractControlOptions | null, asyncValidator?: AsyncValidatorFn | AsyncValidatorFn[] | null): FormArray;\n}\n\n/**\n * Tracks the value and validation status of an individual form control.\n *\n * This is one of the three fundamental building blocks of Angular forms, along with\n * `FormGroup` and `FormArray`. It extends the `AbstractControl` class that\n * implements most of the base functionality for accessing the value, validation status,\n * user interactions and events. See [usage examples below](#usage-notes).\n *\n * @see `AbstractControl`\n * @see [Reactive Forms Guide](guide/reactive-forms)\n * @see [Usage Notes](#usage-notes)\n *\n * @usageNotes\n *\n * ### Initializing Form Controls\n *\n * Instantiate a `FormControl`, with an initial value.\n *\n * ```ts\n * const control = new FormControl('some value');\n * console.log(control.value);     // 'some value'\n *```\n *\n * The following example initializes the control with a form state object. The `value`\n * and `disabled` keys are required in this case.\n *\n * ```ts\n * const control = new FormControl({ value: 'n/a', disabled: true });\n * console.log(control.value);     // 'n/a'\n * console.log(control.status);    // 'DISABLED'\n * ```\n *\n * The following example initializes the control with a synchronous validator.\n *\n * ```ts\n * const control = new FormControl('', Validators.required);\n * console.log(control.value);      // ''\n * console.log(control.status);     // 'INVALID'\n * ```\n *\n * The following example initializes the control using an options object.\n *\n * ```ts\n * const control = new FormControl('', {\n *    validators: Validators.required,\n *    asyncValidators: myAsyncValidator\n * });\n * ```\n *\n * ### Configure the control to update on a blur event\n *\n * Set the `updateOn` option to `'blur'` to update on the blur `event`.\n *\n * ```ts\n * const control = new FormControl('', { updateOn: 'blur' });\n * ```\n *\n * ### Configure the control to update on a submit event\n *\n * Set the `updateOn` option to `'submit'` to update on a submit `event`.\n *\n * ```ts\n * const control = new FormControl('', { updateOn: 'submit' });\n * ```\n *\n * ### Reset the control back to an initial value\n *\n * You reset to a specific form state by passing through a standalone\n * value or a form state object that contains both a value and a disabled state\n * (these are the only two properties that cannot be calculated).\n *\n * ```ts\n * const control = new FormControl('Nancy');\n *\n * console.log(control.value); // 'Nancy'\n *\n * control.reset('Drew');\n *\n * console.log(control.value); // 'Drew'\n * ```\n *\n * ### Reset the control back to an initial value and disabled\n *\n * ```\n * const control = new FormControl('Nancy');\n *\n * console.log(control.value); // 'Nancy'\n * console.log(control.status); // 'VALID'\n *\n * control.reset({ value: 'Drew', disabled: true });\n *\n * console.log(control.value); // 'Drew'\n * console.log(control.status); // 'DISABLED'\n * ```\n *\n * @publicApi\n */\nexport declare class FormControl extends AbstractControl {\n    /**\n     * Creates a new `FormControl` instance.\n     *\n     * @param formState Initializes the control with an initial value,\n     * or an object that defines the initial value and disabled state.\n     *\n     * @param validatorOrOpts A synchronous validator function, or an array of\n     * such functions, or an `AbstractControlOptions` object that contains validation functions\n     * and a validation trigger.\n     *\n     * @param asyncValidator A single async validator or array of async validator functions\n     *\n     */\n    constructor(formState?: any, validatorOrOpts?: ValidatorFn | ValidatorFn[] | AbstractControlOptions | null, asyncValidator?: AsyncValidatorFn | AsyncValidatorFn[] | null);\n    /**\n     * Sets a new value for the form control.\n     *\n     * @param value The new value for the control.\n     * @param options Configuration options that determine how the control propagates changes\n     * and emits events when the value changes.\n     * The configuration options are passed to the {@link AbstractControl#updateValueAndValidity\n     * updateValueAndValidity} method.\n     *\n     * * `onlySelf`: When true, each change only affects this control, and not its parent. Default is\n     * false.\n     * * `emitEvent`: When true or not supplied (the default), both the `statusChanges` and\n     * `valueChanges`\n     * observables emit events with the latest status and value when the control value is updated.\n     * When false, no events are emitted.\n     * * `emitModelToViewChange`: When true or not supplied  (the default), each change triggers an\n     * `onChange` event to\n     * update the view.\n     * * `emitViewToModelChange`: When true or not supplied (the default), each change triggers an\n     * `ngModelChange`\n     * event to update the model.\n     *\n     */\n    setValue(value: any, options?: {\n        onlySelf?: boolean;\n        emitEvent?: boolean;\n        emitModelToViewChange?: boolean;\n        emitViewToModelChange?: boolean;\n    }): void;\n    /**\n     * Patches the value of a control.\n     *\n     * This function is functionally the same as {@link FormControl#setValue setValue} at this level.\n     * It exists for symmetry with {@link FormGroup#patchValue patchValue} on `FormGroups` and\n     * `FormArrays`, where it does behave differently.\n     *\n     * @see `setValue` for options\n     */\n    patchValue(value: any, options?: {\n        onlySelf?: boolean;\n        emitEvent?: boolean;\n        emitModelToViewChange?: boolean;\n        emitViewToModelChange?: boolean;\n    }): void;\n    /**\n     * Resets the form control, marking it `pristine` and `untouched`, and setting\n     * the value to null.\n     *\n     * @param formState Resets the control with an initial value,\n     * or an object that defines the initial value and disabled state.\n     *\n     * @param options Configuration options that determine how the control propagates changes\n     * and emits events after the value changes.\n     *\n     * * `onlySelf`: When true, each change only affects this control, and not its parent. Default is\n     * false.\n     * * `emitEvent`: When true or not supplied (the default), both the `statusChanges` and\n     * `valueChanges`\n     * observables emit events with the latest status and value when the control is reset.\n     * When false, no events are emitted.\n     *\n     */\n    reset(formState?: any, options?: {\n        onlySelf?: boolean;\n        emitEvent?: boolean;\n    }): void;\n    /**\n     * Register a listener for change events.\n     *\n     * @param fn The method that is called when the value changes\n     */\n    registerOnChange(fn: Function): void;\n    /**\n     * Register a listener for disabled events.\n     *\n     * @param fn The method that is called when the disabled status changes.\n     */\n    registerOnDisabledChange(fn: (isDisabled: boolean) => void): void;\n    private _applyFormState;\n}\n\n/**\n * @description\n * Synchronizes a standalone `FormControl` instance to a form control element.\n *\n * Note that support for using the `ngModel` input property and `ngModelChange` event with reactive\n * form directives was deprecated in Angular v6 and is scheduled for removal in\n * a future version of Angular.\n * For details, see [Deprecated features](guide/deprecations#ngmodel-with-reactive-forms).\n *\n * @see [Reactive Forms Guide](guide/reactive-forms)\n * @see `FormControl`\n * @see `AbstractControl`\n *\n * @usageNotes\n *\n * The following example shows how to register a standalone control and set its value.\n *\n * {@example forms/ts/simpleFormControl/simple_form_control_example.ts region='Component'}\n *\n * @ngModule ReactiveFormsModule\n * @publicApi\n */\nexport declare class FormControlDirective extends NgControl implements OnChanges, OnDestroy {\n    private _ngModelWarningConfig;\n    /**\n     * Internal reference to the view model value.\n     * @nodoc\n     */\n    viewModel: any;\n    /**\n     * @description\n     * Tracks the `FormControl` instance bound to the directive.\n     */\n    form: FormControl;\n    /**\n     * @description\n     * Triggers a warning in dev mode that this input should not be used with reactive forms.\n     */\n    set isDisabled(isDisabled: boolean);\n    /** @deprecated as of v6 */\n    model: any;\n    /** @deprecated as of v6 */\n    update: EventEmitter<any>;\n    constructor(validators: (Validator | ValidatorFn)[], asyncValidators: (AsyncValidator | AsyncValidatorFn)[], valueAccessors: ControlValueAccessor[], _ngModelWarningConfig: string | null);\n    /** @nodoc */\n    ngOnChanges(changes: SimpleChanges): void;\n    /** @nodoc */\n    ngOnDestroy(): void;\n    /**\n     * @description\n     * Returns an array that represents the path from the top-level form to this control.\n     * Each index is the string name of the control on that level.\n     */\n    get path(): string[];\n    /**\n     * @description\n     * The `FormControl` bound to this directive.\n     */\n    get control(): FormControl;\n    /**\n     * @description\n     * Sets the new value for the view model and emits an `ngModelChange` event.\n     *\n     * @param newValue The new value for the view model.\n     */\n    viewToModelUpdate(newValue: any): void;\n    private _isControlChanged;\n}\n\n/**\n * @description\n * Syncs a `FormControl` in an existing `FormGroup` to a form control\n * element by name.\n *\n * @see [Reactive Forms Guide](guide/reactive-forms)\n * @see `FormControl`\n * @see `AbstractControl`\n *\n * @usageNotes\n *\n * ### Register `FormControl` within a group\n *\n * The following example shows how to register multiple form controls within a form group\n * and set their value.\n *\n * {@example forms/ts/simpleFormGroup/simple_form_group_example.ts region='Component'}\n *\n * To see `formControlName` examples with different form control types, see:\n *\n * * Radio buttons: `RadioControlValueAccessor`\n * * Selects: `SelectControlValueAccessor`\n *\n * ### Use with ngModel is deprecated\n *\n * Support for using the `ngModel` input property and `ngModelChange` event with reactive\n * form directives has been deprecated in Angular v6 and is scheduled for removal in\n * a future version of Angular.\n *\n * For details, see [Deprecated features](guide/deprecations#ngmodel-with-reactive-forms).\n *\n * @ngModule ReactiveFormsModule\n * @publicApi\n */\nexport declare class FormControlName extends NgControl implements OnChanges, OnDestroy {\n    private _ngModelWarningConfig;\n    private _added;\n    /**\n     * @description\n     * Tracks the `FormControl` instance bound to the directive.\n     */\n    readonly control: FormControl;\n    /**\n     * @description\n     * Tracks the name of the `FormControl` bound to the directive. The name corresponds\n     * to a key in the parent `FormGroup` or `FormArray`.\n     * Accepts a name as a string or a number.\n     * The name in the form of a string is useful for individual forms,\n     * while the numerical form allows for form controls to be bound\n     * to indices when iterating over controls in a `FormArray`.\n     */\n    name: string | number | null;\n    /**\n     * @description\n     * Triggers a warning in dev mode that this input should not be used with reactive forms.\n     */\n    set isDisabled(isDisabled: boolean);\n    /** @deprecated as of v6 */\n    model: any;\n    /** @deprecated as of v6 */\n    update: EventEmitter<any>;\n    constructor(parent: ControlContainer, validators: (Validator | ValidatorFn)[], asyncValidators: (AsyncValidator | AsyncValidatorFn)[], valueAccessors: ControlValueAccessor[], _ngModelWarningConfig: string | null);\n    /** @nodoc */\n    ngOnChanges(changes: SimpleChanges): void;\n    /** @nodoc */\n    ngOnDestroy(): void;\n    /**\n     * @description\n     * Sets the new value for the view model and emits an `ngModelChange` event.\n     *\n     * @param newValue The new value for the view model.\n     */\n    viewToModelUpdate(newValue: any): void;\n    /**\n     * @description\n     * Returns an array that represents the path from the top-level form to this control.\n     * Each index is the string name of the control on that level.\n     */\n    get path(): string[];\n    /**\n     * @description\n     * The top-level directive for this group if present, otherwise null.\n     */\n    get formDirective(): any;\n    private _checkParentType;\n    private _setUpControl;\n}\n\n/**\n * Tracks the value and validity state of a group of `FormControl` instances.\n *\n * A `FormGroup` aggregates the values of each child `FormControl` into one object,\n * with each control name as the key.  It calculates its status by reducing the status values\n * of its children. For example, if one of the controls in a group is invalid, the entire\n * group becomes invalid.\n *\n * `FormGroup` is one of the three fundamental building blocks used to define forms in Angular,\n * along with `FormControl` and `FormArray`.\n *\n * When instantiating a `FormGroup`, pass in a collection of child controls as the first\n * argument. The key for each child registers the name for the control.\n *\n * @usageNotes\n *\n * ### Create a form group with 2 controls\n *\n * ```\n * const form = new FormGroup({\n *   first: new FormControl('Nancy', Validators.minLength(2)),\n *   last: new FormControl('Drew'),\n * });\n *\n * console.log(form.value);   // {first: 'Nancy', last; 'Drew'}\n * console.log(form.status);  // 'VALID'\n * ```\n *\n * ### Create a form group with a group-level validator\n *\n * You include group-level validators as the second arg, or group-level async\n * validators as the third arg. These come in handy when you want to perform validation\n * that considers the value of more than one child control.\n *\n * ```\n * const form = new FormGroup({\n *   password: new FormControl('', Validators.minLength(2)),\n *   passwordConfirm: new FormControl('', Validators.minLength(2)),\n * }, passwordMatchValidator);\n *\n *\n * function passwordMatchValidator(g: FormGroup) {\n *    return g.get('password').value === g.get('passwordConfirm').value\n *       ? null : {'mismatch': true};\n * }\n * ```\n *\n * Like `FormControl` instances, you choose to pass in\n * validators and async validators as part of an options object.\n *\n * ```\n * const form = new FormGroup({\n *   password: new FormControl('')\n *   passwordConfirm: new FormControl('')\n * }, { validators: passwordMatchValidator, asyncValidators: otherValidator });\n * ```\n *\n * ### Set the updateOn property for all controls in a form group\n *\n * The options object is used to set a default value for each child\n * control's `updateOn` property. If you set `updateOn` to `'blur'` at the\n * group level, all child controls default to 'blur', unless the child\n * has explicitly specified a different `updateOn` value.\n *\n * ```ts\n * const c = new FormGroup({\n *   one: new FormControl()\n * }, { updateOn: 'blur' });\n * ```\n *\n * @publicApi\n */\nexport declare class FormGroup extends AbstractControl {\n    controls: {\n        [key: string]: AbstractControl;\n    };\n    /**\n     * Creates a new `FormGroup` instance.\n     *\n     * @param controls A collection of child controls. The key for each child is the name\n     * under which it is registered.\n     *\n     * @param validatorOrOpts A synchronous validator function, or an array of\n     * such functions, or an `AbstractControlOptions` object that contains validation functions\n     * and a validation trigger.\n     *\n     * @param asyncValidator A single async validator or array of async validator functions\n     *\n     */\n    constructor(controls: {\n        [key: string]: AbstractControl;\n    }, validatorOrOpts?: ValidatorFn | ValidatorFn[] | AbstractControlOptions | null, asyncValidator?: AsyncValidatorFn | AsyncValidatorFn[] | null);\n    /**\n     * Registers a control with the group's list of controls.\n     *\n     * This method does not update the value or validity of the control.\n     * Use {@link FormGroup#addControl addControl} instead.\n     *\n     * @param name The control name to register in the collection\n     * @param control Provides the control for the given name\n     */\n    registerControl(name: string, control: AbstractControl): AbstractControl;\n    /**\n     * Add a control to this group.\n     *\n     * If a control with a given name already exists, it would *not* be replaced with a new one.\n     * If you want to replace an existing control, use the {@link FormGroup#setControl setControl}\n     * method instead. This method also updates the value and validity of the control.\n     *\n     * @param name The control name to add to the collection\n     * @param control Provides the control for the given name\n     * @param options Specifies whether this FormGroup instance should emit events after a new\n     *     control is added.\n     * * `emitEvent`: When true or not supplied (the default), both the `statusChanges` and\n     * `valueChanges` observables emit events with the latest status and value when the control is\n     * added. When false, no events are emitted.\n     */\n    addControl(name: string, control: AbstractControl, options?: {\n        emitEvent?: boolean;\n    }): void;\n    /**\n     * Remove a control from this group.\n     *\n     * This method also updates the value and validity of the control.\n     *\n     * @param name The control name to remove from the collection\n     * @param options Specifies whether this FormGroup instance should emit events after a\n     *     control is removed.\n     * * `emitEvent`: When true or not supplied (the default), both the `statusChanges` and\n     * `valueChanges` observables emit events with the latest status and value when the control is\n     * removed. When false, no events are emitted.\n     */\n    removeControl(name: string, options?: {\n        emitEvent?: boolean;\n    }): void;\n    /**\n     * Replace an existing control.\n     *\n     * If a control with a given name does not exist in this `FormGroup`, it will be added.\n     *\n     * @param name The control name to replace in the collection\n     * @param control Provides the control for the given name\n     * @param options Specifies whether this FormGroup instance should emit events after an\n     *     existing control is replaced.\n     * * `emitEvent`: When true or not supplied (the default), both the `statusChanges` and\n     * `valueChanges` observables emit events with the latest status and value when the control is\n     * replaced with a new one. When false, no events are emitted.\n     */\n    setControl(name: string, control: AbstractControl, options?: {\n        emitEvent?: boolean;\n    }): void;\n    /**\n     * Check whether there is an enabled control with the given name in the group.\n     *\n     * Reports false for disabled controls. If you'd like to check for existence in the group\n     * only, use {@link AbstractControl#get get} instead.\n     *\n     * @param controlName The control name to check for existence in the collection\n     *\n     * @returns false for disabled controls, true otherwise.\n     */\n    contains(controlName: string): boolean;\n    /**\n     * Sets the value of the `FormGroup`. It accepts an object that matches\n     * the structure of the group, with control names as keys.\n     *\n     * @usageNotes\n     * ### Set the complete value for the form group\n     *\n     * ```\n     * const form = new FormGroup({\n     *   first: new FormControl(),\n     *   last: new FormControl()\n     * });\n     *\n     * console.log(form.value);   // {first: null, last: null}\n     *\n     * form.setValue({first: 'Nancy', last: 'Drew'});\n     * console.log(form.value);   // {first: 'Nancy', last: 'Drew'}\n     * ```\n     *\n     * @throws When strict checks fail, such as setting the value of a control\n     * that doesn't exist or if you exclude a value of a control that does exist.\n     *\n     * @param value The new value for the control that matches the structure of the group.\n     * @param options Configuration options that determine how the control propagates changes\n     * and emits events after the value changes.\n     * The configuration options are passed to the {@link AbstractControl#updateValueAndValidity\n     * updateValueAndValidity} method.\n     *\n     * * `onlySelf`: When true, each change only affects this control, and not its parent. Default is\n     * false.\n     * * `emitEvent`: When true or not supplied (the default), both the `statusChanges` and\n     * `valueChanges`\n     * observables emit events with the latest status and value when the control value is updated.\n     * When false, no events are emitted.\n     */\n    setValue(value: {\n        [key: string]: any;\n    }, options?: {\n        onlySelf?: boolean;\n        emitEvent?: boolean;\n    }): void;\n    /**\n     * Patches the value of the `FormGroup`. It accepts an object with control\n     * names as keys, and does its best to match the values to the correct controls\n     * in the group.\n     *\n     * It accepts both super-sets and sub-sets of the group without throwing an error.\n     *\n     * @usageNotes\n     * ### Patch the value for a form group\n     *\n     * ```\n     * const form = new FormGroup({\n     *    first: new FormControl(),\n     *    last: new FormControl()\n     * });\n     * console.log(form.value);   // {first: null, last: null}\n     *\n     * form.patchValue({first: 'Nancy'});\n     * console.log(form.value);   // {first: 'Nancy', last: null}\n     * ```\n     *\n     * @param value The object that matches the structure of the group.\n     * @param options Configuration options that determine how the control propagates changes and\n     * emits events after the value is patched.\n     * * `onlySelf`: When true, each change only affects this control and not its parent. Default is\n     * true.\n     * * `emitEvent`: When true or not supplied (the default), both the `statusChanges` and\n     * `valueChanges` observables emit events with the latest status and value when the control value\n     * is updated. When false, no events are emitted. The configuration options are passed to\n     * the {@link AbstractControl#updateValueAndValidity updateValueAndValidity} method.\n     */\n    patchValue(value: {\n        [key: string]: any;\n    }, options?: {\n        onlySelf?: boolean;\n        emitEvent?: boolean;\n    }): void;\n    /**\n     * Resets the `FormGroup`, marks all descendants `pristine` and `untouched` and sets\n     * the value of all descendants to null.\n     *\n     * You reset to a specific form state by passing in a map of states\n     * that matches the structure of your form, with control names as keys. The state\n     * is a standalone value or a form state object with both a value and a disabled\n     * status.\n     *\n     * @param value Resets the control with an initial value,\n     * or an object that defines the initial value and disabled state.\n     *\n     * @param options Configuration options that determine how the control propagates changes\n     * and emits events when the group is reset.\n     * * `onlySelf`: When true, each change only affects this control, and not its parent. Default is\n     * false.\n     * * `emitEvent`: When true or not supplied (the default), both the `statusChanges` and\n     * `valueChanges`\n     * observables emit events with the latest status and value when the control is reset.\n     * When false, no events are emitted.\n     * The configuration options are passed to the {@link AbstractControl#updateValueAndValidity\n     * updateValueAndValidity} method.\n     *\n     * @usageNotes\n     *\n     * ### Reset the form group values\n     *\n     * ```ts\n     * const form = new FormGroup({\n     *   first: new FormControl('first name'),\n     *   last: new FormControl('last name')\n     * });\n     *\n     * console.log(form.value);  // {first: 'first name', last: 'last name'}\n     *\n     * form.reset({ first: 'name', last: 'last name' });\n     *\n     * console.log(form.value);  // {first: 'name', last: 'last name'}\n     * ```\n     *\n     * ### Reset the form group values and disabled status\n     *\n     * ```\n     * const form = new FormGroup({\n     *   first: new FormControl('first name'),\n     *   last: new FormControl('last name')\n     * });\n     *\n     * form.reset({\n     *   first: {value: 'name', disabled: true},\n     *   last: 'last'\n     * });\n     *\n     * console.log(form.value);  // {last: 'last'}\n     * console.log(form.get('first').status);  // 'DISABLED'\n     * ```\n     */\n    reset(value?: any, options?: {\n        onlySelf?: boolean;\n        emitEvent?: boolean;\n    }): void;\n    /**\n     * The aggregate value of the `FormGroup`, including any disabled controls.\n     *\n     * Retrieves all values regardless of disabled status.\n     * The `value` property is the best way to get the value of the group, because\n     * it excludes disabled controls in the `FormGroup`.\n     */\n    getRawValue(): any;\n}\n\n/**\n * @description\n *\n * Binds an existing `FormGroup` to a DOM element.\n *\n * This directive accepts an existing `FormGroup` instance. It will then use this\n * `FormGroup` instance to match any child `FormControl`, `FormGroup`,\n * and `FormArray` instances to child `FormControlName`, `FormGroupName`,\n * and `FormArrayName` directives.\n *\n * @see [Reactive Forms Guide](guide/reactive-forms)\n * @see `AbstractControl`\n *\n * @usageNotes\n * ### Register Form Group\n *\n * The following example registers a `FormGroup` with first name and last name controls,\n * and listens for the *ngSubmit* event when the button is clicked.\n *\n * {@example forms/ts/simpleFormGroup/simple_form_group_example.ts region='Component'}\n *\n * @ngModule ReactiveFormsModule\n * @publicApi\n */\nexport declare class FormGroupDirective extends ControlContainer implements Form, OnChanges, OnDestroy {\n    private validators;\n    private asyncValidators;\n    /**\n     * @description\n     * Reports whether the form submission has been triggered.\n     */\n    readonly submitted: boolean;\n    /**\n     * Reference to an old form group input value, which is needed to cleanup old instance in case it\n     * was replaced with a new one.\n     */\n    private _oldForm;\n    /**\n     * Callback that should be invoked when controls in FormGroup or FormArray collection change\n     * (added or removed). This callback triggers corresponding DOM updates.\n     */\n    private readonly _onCollectionChange;\n    /**\n     * @description\n     * Tracks the list of added `FormControlName` instances\n     */\n    directives: FormControlName[];\n    /**\n     * @description\n     * Tracks the `FormGroup` bound to this directive.\n     */\n    form: FormGroup;\n    /**\n     * @description\n     * Emits an event when the form submission has been triggered.\n     */\n    ngSubmit: EventEmitter<any>;\n    constructor(validators: (Validator | ValidatorFn)[], asyncValidators: (AsyncValidator | AsyncValidatorFn)[]);\n    /** @nodoc */\n    ngOnChanges(changes: SimpleChanges): void;\n    /** @nodoc */\n    ngOnDestroy(): void;\n    /**\n     * @description\n     * Returns this directive's instance.\n     */\n    get formDirective(): Form;\n    /**\n     * @description\n     * Returns the `FormGroup` bound to this directive.\n     */\n    get control(): FormGroup;\n    /**\n     * @description\n     * Returns an array representing the path to this group. Because this directive\n     * always lives at the top level of a form, it always an empty array.\n     */\n    get path(): string[];\n    /**\n     * @description\n     * Method that sets up the control directive in this group, re-calculates its value\n     * and validity, and adds the instance to the internal list of directives.\n     *\n     * @param dir The `FormControlName` directive instance.\n     */\n    addControl(dir: FormControlName): FormControl;\n    /**\n     * @description\n     * Retrieves the `FormControl` instance from the provided `FormControlName` directive\n     *\n     * @param dir The `FormControlName` directive instance.\n     */\n    getControl(dir: FormControlName): FormControl;\n    /**\n     * @description\n     * Removes the `FormControlName` instance from the internal list of directives\n     *\n     * @param dir The `FormControlName` directive instance.\n     */\n    removeControl(dir: FormControlName): void;\n    /**\n     * Adds a new `FormGroupName` directive instance to the form.\n     *\n     * @param dir The `FormGroupName` directive instance.\n     */\n    addFormGroup(dir: FormGroupName): void;\n    /**\n     * Performs the necessary cleanup when a `FormGroupName` directive instance is removed from the\n     * view.\n     *\n     * @param dir The `FormGroupName` directive instance.\n     */\n    removeFormGroup(dir: FormGroupName): void;\n    /**\n     * @description\n     * Retrieves the `FormGroup` for a provided `FormGroupName` directive instance\n     *\n     * @param dir The `FormGroupName` directive instance.\n     */\n    getFormGroup(dir: FormGroupName): FormGroup;\n    /**\n     * Performs the necessary setup when a `FormArrayName` directive instance is added to the view.\n     *\n     * @param dir The `FormArrayName` directive instance.\n     */\n    addFormArray(dir: FormArrayName): void;\n    /**\n     * Performs the necessary cleanup when a `FormArrayName` directive instance is removed from the\n     * view.\n     *\n     * @param dir The `FormArrayName` directive instance.\n     */\n    removeFormArray(dir: FormArrayName): void;\n    /**\n     * @description\n     * Retrieves the `FormArray` for a provided `FormArrayName` directive instance.\n     *\n     * @param dir The `FormArrayName` directive instance.\n     */\n    getFormArray(dir: FormArrayName): FormArray;\n    /**\n     * Sets the new value for the provided `FormControlName` directive.\n     *\n     * @param dir The `FormControlName` directive instance.\n     * @param value The new value for the directive's control.\n     */\n    updateModel(dir: FormControlName, value: any): void;\n    /**\n     * @description\n     * Method called with the \"submit\" event is triggered on the form.\n     * Triggers the `ngSubmit` emitter to emit the \"submit\" event as its payload.\n     *\n     * @param $event The \"submit\" event object\n     */\n    onSubmit($event: Event): boolean;\n    /**\n     * @description\n     * Method called when the \"reset\" event is triggered on the form.\n     */\n    onReset(): void;\n    /**\n     * @description\n     * Resets the form to an initial value and resets its submitted status.\n     *\n     * @param value The new value for the form.\n     */\n    resetForm(value?: any): void;\n    private _setUpFormContainer;\n    private _cleanUpFormContainer;\n    private _updateRegistrations;\n    private _updateValidators;\n    private _checkFormPresent;\n}\n\n/**\n * @description\n *\n * Syncs a nested `FormGroup` to a DOM element.\n *\n * This directive can only be used with a parent `FormGroupDirective`.\n *\n * It accepts the string name of the nested `FormGroup` to link, and\n * looks for a `FormGroup` registered with that name in the parent\n * `FormGroup` instance you passed into `FormGroupDirective`.\n *\n * Use nested form groups to validate a sub-group of a\n * form separately from the rest or to group the values of certain\n * controls into their own nested object.\n *\n * @see [Reactive Forms Guide](guide/reactive-forms)\n *\n * @usageNotes\n *\n * ### Access the group by name\n *\n * The following example uses the {@link AbstractControl#get get} method to access the\n * associated `FormGroup`\n *\n * ```ts\n *   this.form.get('name');\n * ```\n *\n * ### Access individual controls in the group\n *\n * The following example uses the {@link AbstractControl#get get} method to access\n * individual controls within the group using dot syntax.\n *\n * ```ts\n *   this.form.get('name.first');\n * ```\n *\n * ### Register a nested `FormGroup`.\n *\n * The following example registers a nested *name* `FormGroup` within an existing `FormGroup`,\n * and provides methods to retrieve the nested `FormGroup` and individual controls.\n *\n * {@example forms/ts/nestedFormGroup/nested_form_group_example.ts region='Component'}\n *\n * @ngModule ReactiveFormsModule\n * @publicApi\n */\nexport declare class FormGroupName extends AbstractFormGroupDirective implements OnInit, OnDestroy {\n    /**\n     * @description\n     * Tracks the name of the `FormGroup` bound to the directive. The name corresponds\n     * to a key in the parent `FormGroup` or `FormArray`.\n     * Accepts a name as a string or a number.\n     * The name in the form of a string is useful for individual forms,\n     * while the numerical form allows for form groups to be bound\n     * to indices when iterating over groups in a `FormArray`.\n     */\n    name: string | number | null;\n    constructor(parent: ControlContainer, validators: (Validator | ValidatorFn)[], asyncValidators: (AsyncValidator | AsyncValidatorFn)[]);\n}\n\ndeclare type FormHooks = 'change' | 'blur' | 'submit';\n\n/**\n * Exports the required providers and directives for template-driven forms,\n * making them available for import by NgModules that import this module.\n *\n * Providers associated with this module:\n * * `RadioControlRegistry`\n *\n * @see [Forms Overview](/guide/forms-overview)\n * @see [Template-driven Forms Guide](/guide/forms)\n *\n * @publicApi\n */\nexport declare class FormsModule {\n}\n\n/**\n * A directive that adds max length validation to controls marked with the\n * `maxlength` attribute. The directive is provided with the `NG_VALIDATORS` multi-provider list.\n *\n * @see [Form Validation](guide/form-validation)\n *\n * @usageNotes\n *\n * ### Adding a maximum length validator\n *\n * The following example shows how to add a maximum length validator to an input attached to an\n * ngModel binding.\n *\n * ```html\n * <input name=\"firstName\" ngModel maxlength=\"25\">\n * ```\n *\n * @ngModule ReactiveFormsModule\n * @ngModule FormsModule\n * @publicApi\n */\nexport declare class MaxLengthValidator implements Validator, OnChanges {\n    private _validator;\n    private _onChange?;\n    /**\n     * @description\n     * Tracks changes to the maximum length bound to this directive.\n     */\n    maxlength: string | number | null;\n    /** @nodoc */\n    ngOnChanges(changes: SimpleChanges): void;\n    /**\n     * Method that validates whether the value exceeds the maximum length requirement.\n     * @nodoc\n     */\n    validate(control: AbstractControl): ValidationErrors | null;\n    /**\n     * Registers a callback function to call when the validator inputs change.\n     * @nodoc\n     */\n    registerOnValidatorChange(fn: () => void): void;\n    private _createValidator;\n    /** @nodoc */\n    enabled(): boolean;\n}\n\n/**\n * A directive which installs the {@link MaxValidator} for any `formControlName`,\n * `formControl`, or control with `ngModel` that also has a `max` attribute.\n *\n * @see [Form Validation](guide/form-validation)\n *\n * @usageNotes\n *\n * ### Adding a max validator\n *\n * The following example shows how to add a max validator to an input attached to an\n * ngModel binding.\n *\n * ```html\n * <input type=\"number\" ngModel max=\"4\">\n * ```\n *\n * @ngModule ReactiveFormsModule\n * @ngModule FormsModule\n * @publicApi\n */\nexport declare class MaxValidator extends AbstractValidatorDirective implements OnChanges {\n    /**\n     * @description\n     * Tracks changes to the max bound to this directive.\n     */\n    max: string | number;\n    /**\n     * Declare `ngOnChanges` lifecycle hook at the main directive level (vs keeping it in base class)\n     * to avoid differences in handling inheritance of lifecycle hooks between Ivy and ViewEngine in\n     * AOT mode. This could be refactored once ViewEngine is removed.\n     * @nodoc\n     */\n    ngOnChanges(changes: SimpleChanges): void;\n}\n\n/**\n * A directive that adds minimum length validation to controls marked with the\n * `minlength` attribute. The directive is provided with the `NG_VALIDATORS` multi-provider list.\n *\n * @see [Form Validation](guide/form-validation)\n *\n * @usageNotes\n *\n * ### Adding a minimum length validator\n *\n * The following example shows how to add a minimum length validator to an input attached to an\n * ngModel binding.\n *\n * ```html\n * <input name=\"firstName\" ngModel minlength=\"4\">\n * ```\n *\n * @ngModule ReactiveFormsModule\n * @ngModule FormsModule\n * @publicApi\n */\nexport declare class MinLengthValidator implements Validator, OnChanges {\n    private _validator;\n    private _onChange?;\n    /**\n     * @description\n     * Tracks changes to the minimum length bound to this directive.\n     */\n    minlength: string | number | null;\n    /** @nodoc */\n    ngOnChanges(changes: SimpleChanges): void;\n    /**\n     * Method that validates whether the value meets a minimum length requirement.\n     * Returns the validation result if enabled, otherwise null.\n     * @nodoc\n     */\n    validate(control: AbstractControl): ValidationErrors | null;\n    /**\n     * Registers a callback function to call when the validator inputs change.\n     * @nodoc\n     */\n    registerOnValidatorChange(fn: () => void): void;\n    private _createValidator;\n    /** @nodoc */\n    enabled(): boolean;\n}\n\n/**\n * A directive which installs the {@link MinValidator} for any `formControlName`,\n * `formControl`, or control with `ngModel` that also has a `min` attribute.\n *\n * @see [Form Validation](guide/form-validation)\n *\n * @usageNotes\n *\n * ### Adding a min validator\n *\n * The following example shows how to add a min validator to an input attached to an\n * ngModel binding.\n *\n * ```html\n * <input type=\"number\" ngModel min=\"4\">\n * ```\n *\n * @ngModule ReactiveFormsModule\n * @ngModule FormsModule\n * @publicApi\n */\nexport declare class MinValidator extends AbstractValidatorDirective implements OnChanges {\n    /**\n     * @description\n     * Tracks changes to the min bound to this directive.\n     */\n    min: string | number;\n    /**\n     * Declare `ngOnChanges` lifecycle hook at the main directive level (vs keeping it in base class)\n     * to avoid differences in handling inheritance of lifecycle hooks between Ivy and ViewEngine in\n     * AOT mode. This could be refactored once ViewEngine is removed.\n     * @nodoc\n     */\n    ngOnChanges(changes: SimpleChanges): void;\n}\n\n/**\n * @description\n * An `InjectionToken` for registering additional asynchronous validators used with\n * `AbstractControl`s.\n *\n * @see `NG_VALIDATORS`\n *\n * @publicApi\n */\nexport declare const NG_ASYNC_VALIDATORS: InjectionToken<(Function | Validator)[]>;\n\n/**\n * @description\n * An `InjectionToken` for registering additional synchronous validators used with\n * `AbstractControl`s.\n *\n * @see `NG_ASYNC_VALIDATORS`\n *\n * @usageNotes\n *\n * ### Providing a custom validator\n *\n * The following example registers a custom validator directive. Adding the validator to the\n * existing collection of validators requires the `multi: true` option.\n *\n * ```typescript\n * @Directive({\n *   selector: '[customValidator]',\n *   providers: [{provide: NG_VALIDATORS, useExisting: CustomValidatorDirective, multi: true}]\n * })\n * class CustomValidatorDirective implements Validator {\n *   validate(control: AbstractControl): ValidationErrors | null {\n *     return { 'custom': true };\n *   }\n * }\n * ```\n *\n * @publicApi\n */\nexport declare const NG_VALIDATORS: InjectionToken<(Function | Validator)[]>;\n\n/**\n * Used to provide a `ControlValueAccessor` for form controls.\n *\n * See `DefaultValueAccessor` for how to implement one.\n *\n * @publicApi\n */\nexport declare const NG_VALUE_ACCESSOR: InjectionToken<readonly ControlValueAccessor[]>;\n\n/**\n * @description\n * A base class that all `FormControl`-based directives extend. It binds a `FormControl`\n * object to a DOM element.\n *\n * @publicApi\n */\nexport declare abstract class NgControl extends AbstractControlDirective {\n    /**\n     * @description\n     * The name for the control\n     */\n    name: string | number | null;\n    /**\n     * @description\n     * The value accessor for the control\n     */\n    valueAccessor: ControlValueAccessor | null;\n    /**\n     * @description\n     * The callback method to update the model from the view when requested\n     *\n     * @param newValue The new value for the view\n     */\n    abstract viewToModelUpdate(newValue: any): void;\n}\n\n/**\n * @description\n * Directive automatically applied to Angular form controls that sets CSS classes\n * based on control status.\n *\n * @usageNotes\n *\n * ### CSS classes applied\n *\n * The following classes are applied as the properties become true:\n *\n * * ng-valid\n * * ng-invalid\n * * ng-pending\n * * ng-pristine\n * * ng-dirty\n * * ng-untouched\n * * ng-touched\n *\n * @ngModule ReactiveFormsModule\n * @ngModule FormsModule\n * @publicApi\n */\nexport declare class NgControlStatus extends ɵangular_packages_forms_forms_i {\n    constructor(cd: NgControl);\n}\n\n/**\n * @description\n * Directive automatically applied to Angular form groups that sets CSS classes\n * based on control status (valid/invalid/dirty/etc). On groups, this includes the additional\n * class ng-submitted.\n *\n * @see `NgControlStatus`\n *\n * @ngModule ReactiveFormsModule\n * @ngModule FormsModule\n * @publicApi\n */\nexport declare class NgControlStatusGroup extends ɵangular_packages_forms_forms_i {\n    constructor(cd: ControlContainer);\n}\n\n/**\n * @description\n * Creates a top-level `FormGroup` instance and binds it to a form\n * to track aggregate form value and validation status.\n *\n * As soon as you import the `FormsModule`, this directive becomes active by default on\n * all `<form>` tags.  You don't need to add a special selector.\n *\n * You optionally export the directive into a local template variable using `ngForm` as the key\n * (ex: `#myForm=\"ngForm\"`). This is optional, but useful.  Many properties from the underlying\n * `FormGroup` instance are duplicated on the directive itself, so a reference to it\n * gives you access to the aggregate value and validity status of the form, as well as\n * user interaction properties like `dirty` and `touched`.\n *\n * To register child controls with the form, use `NgModel` with a `name`\n * attribute. You may use `NgModelGroup` to create sub-groups within the form.\n *\n * If necessary, listen to the directive's `ngSubmit` event to be notified when the user has\n * triggered a form submission. The `ngSubmit` event emits the original form\n * submission event.\n *\n * In template driven forms, all `<form>` tags are automatically tagged as `NgForm`.\n * To import the `FormsModule` but skip its usage in some forms,\n * for example, to use native HTML5 validation, add the `ngNoForm` and the `<form>`\n * tags won't create an `NgForm` directive. In reactive forms, using `ngNoForm` is\n * unnecessary because the `<form>` tags are inert. In that case, you would\n * refrain from using the `formGroup` directive.\n *\n * @usageNotes\n *\n * ### Listening for form submission\n *\n * The following example shows how to capture the form values from the \"ngSubmit\" event.\n *\n * {@example forms/ts/simpleForm/simple_form_example.ts region='Component'}\n *\n * ### Setting the update options\n *\n * The following example shows you how to change the \"updateOn\" option from its default using\n * ngFormOptions.\n *\n * ```html\n * <form [ngFormOptions]=\"{updateOn: 'blur'}\">\n *    <input name=\"one\" ngModel>  <!-- this ngModel will update on blur -->\n * </form>\n * ```\n *\n * ### Native DOM validation UI\n *\n * In order to prevent the native DOM form validation UI from interfering with Angular's form\n * validation, Angular automatically adds the `novalidate` attribute on any `<form>` whenever\n * `FormModule` or `ReactiveFormModule` are imported into the application.\n * If you want to explicitly enable native DOM validation UI with Angular forms, you can add the\n * `ngNativeValidate` attribute to the `<form>` element:\n *\n * ```html\n * <form ngNativeValidate>\n *   ...\n * </form>\n * ```\n *\n * @ngModule FormsModule\n * @publicApi\n */\nexport declare class NgForm extends ControlContainer implements Form, AfterViewInit {\n    /**\n     * @description\n     * Returns whether the form submission has been triggered.\n     */\n    readonly submitted: boolean;\n    private _directives;\n    /**\n     * @description\n     * The `FormGroup` instance created for this form.\n     */\n    form: FormGroup;\n    /**\n     * @description\n     * Event emitter for the \"ngSubmit\" event\n     */\n    ngSubmit: EventEmitter<any>;\n    /**\n     * @description\n     * Tracks options for the `NgForm` instance.\n     *\n     * **updateOn**: Sets the default `updateOn` value for all child `NgModels` below it\n     * unless explicitly set by a child `NgModel` using `ngModelOptions`). Defaults to 'change'.\n     * Possible values: `'change'` | `'blur'` | `'submit'`.\n     *\n     */\n    options: {\n        updateOn?: FormHooks;\n    };\n    constructor(validators: (Validator | ValidatorFn)[], asyncValidators: (AsyncValidator | AsyncValidatorFn)[]);\n    /** @nodoc */\n    ngAfterViewInit(): void;\n    /**\n     * @description\n     * The directive instance.\n     */\n    get formDirective(): Form;\n    /**\n     * @description\n     * The internal `FormGroup` instance.\n     */\n    get control(): FormGroup;\n    /**\n     * @description\n     * Returns an array representing the path to this group. Because this directive\n     * always lives at the top level of a form, it is always an empty array.\n     */\n    get path(): string[];\n    /**\n     * @description\n     * Returns a map of the controls in this group.\n     */\n    get controls(): {\n        [key: string]: AbstractControl;\n    };\n    /**\n     * @description\n     * Method that sets up the control directive in this group, re-calculates its value\n     * and validity, and adds the instance to the internal list of directives.\n     *\n     * @param dir The `NgModel` directive instance.\n     */\n    addControl(dir: NgModel): void;\n    /**\n     * @description\n     * Retrieves the `FormControl` instance from the provided `NgModel` directive.\n     *\n     * @param dir The `NgModel` directive instance.\n     */\n    getControl(dir: NgModel): FormControl;\n    /**\n     * @description\n     * Removes the `NgModel` instance from the internal list of directives\n     *\n     * @param dir The `NgModel` directive instance.\n     */\n    removeControl(dir: NgModel): void;\n    /**\n     * @description\n     * Adds a new `NgModelGroup` directive instance to the form.\n     *\n     * @param dir The `NgModelGroup` directive instance.\n     */\n    addFormGroup(dir: NgModelGroup): void;\n    /**\n     * @description\n     * Removes the `NgModelGroup` directive instance from the form.\n     *\n     * @param dir The `NgModelGroup` directive instance.\n     */\n    removeFormGroup(dir: NgModelGroup): void;\n    /**\n     * @description\n     * Retrieves the `FormGroup` for a provided `NgModelGroup` directive instance\n     *\n     * @param dir The `NgModelGroup` directive instance.\n     */\n    getFormGroup(dir: NgModelGroup): FormGroup;\n    /**\n     * Sets the new value for the provided `NgControl` directive.\n     *\n     * @param dir The `NgControl` directive instance.\n     * @param value The new value for the directive's control.\n     */\n    updateModel(dir: NgControl, value: any): void;\n    /**\n     * @description\n     * Sets the value for this `FormGroup`.\n     *\n     * @param value The new value\n     */\n    setValue(value: {\n        [key: string]: any;\n    }): void;\n    /**\n     * @description\n     * Method called when the \"submit\" event is triggered on the form.\n     * Triggers the `ngSubmit` emitter to emit the \"submit\" event as its payload.\n     *\n     * @param $event The \"submit\" event object\n     */\n    onSubmit($event: Event): boolean;\n    /**\n     * @description\n     * Method called when the \"reset\" event is triggered on the form.\n     */\n    onReset(): void;\n    /**\n     * @description\n     * Resets the form to an initial value and resets its submitted status.\n     *\n     * @param value The new value for the form.\n     */\n    resetForm(value?: any): void;\n    private _setUpdateStrategy;\n}\n\n/**\n * @description\n * Creates a `FormControl` instance from a domain model and binds it\n * to a form control element.\n *\n * The `FormControl` instance tracks the value, user interaction, and\n * validation status of the control and keeps the view synced with the model. If used\n * within a parent form, the directive also registers itself with the form as a child\n * control.\n *\n * This directive is used by itself or as part of a larger form. Use the\n * `ngModel` selector to activate it.\n *\n * It accepts a domain model as an optional `Input`. If you have a one-way binding\n * to `ngModel` with `[]` syntax, changing the domain model's value in the component\n * class sets the value in the view. If you have a two-way binding with `[()]` syntax\n * (also known as 'banana-in-a-box syntax'), the value in the UI always syncs back to\n * the domain model in your class.\n *\n * To inspect the properties of the associated `FormControl` (like the validity state),\n * export the directive into a local template variable using `ngModel` as the key (ex:\n * `#myVar=\"ngModel\"`). You can then access the control using the directive's `control` property.\n * However, the most commonly used properties (like `valid` and `dirty`) also exist on the control\n * for direct access. See a full list of properties directly available in\n * `AbstractControlDirective`.\n *\n * @see `RadioControlValueAccessor`\n * @see `SelectControlValueAccessor`\n *\n * @usageNotes\n *\n * ### Using ngModel on a standalone control\n *\n * The following examples show a simple standalone control using `ngModel`:\n *\n * {@example forms/ts/simpleNgModel/simple_ng_model_example.ts region='Component'}\n *\n * When using the `ngModel` within `<form>` tags, you'll also need to supply a `name` attribute\n * so that the control can be registered with the parent form under that name.\n *\n * In the context of a parent form, it's often unnecessary to include one-way or two-way binding,\n * as the parent form syncs the value for you. You access its properties by exporting it into a\n * local template variable using `ngForm` such as (`#f=\"ngForm\"`). Use the variable where\n * needed on form submission.\n *\n * If you do need to populate initial values into your form, using a one-way binding for\n * `ngModel` tends to be sufficient as long as you use the exported form's value rather\n * than the domain model's value on submit.\n *\n * ### Using ngModel within a form\n *\n * The following example shows controls using `ngModel` within a form:\n *\n * {@example forms/ts/simpleForm/simple_form_example.ts region='Component'}\n *\n * ### Using a standalone ngModel within a group\n *\n * The following example shows you how to use a standalone ngModel control\n * within a form. This controls the display of the form, but doesn't contain form data.\n *\n * ```html\n * <form>\n *   <input name=\"login\" ngModel placeholder=\"Login\">\n *   <input type=\"checkbox\" ngModel [ngModelOptions]=\"{standalone: true}\"> Show more options?\n * </form>\n * <!-- form value: {login: ''} -->\n * ```\n *\n * ### Setting the ngModel `name` attribute through options\n *\n * The following example shows you an alternate way to set the name attribute. Here,\n * an attribute identified as name is used within a custom form control component. To still be able\n * to specify the NgModel's name, you must specify it using the `ngModelOptions` input instead.\n *\n * ```html\n * <form>\n *   <my-custom-form-control name=\"Nancy\" ngModel [ngModelOptions]=\"{name: 'user'}\">\n *   </my-custom-form-control>\n * </form>\n * <!-- form value: {user: ''} -->\n * ```\n *\n * @ngModule FormsModule\n * @publicApi\n */\nexport declare class NgModel extends NgControl implements OnChanges, OnDestroy {\n    readonly control: FormControl;\n    /** @nodoc */\n    static ngAcceptInputType_isDisabled: boolean | string;\n    /**\n     * Internal reference to the view model value.\n     * @nodoc\n     */\n    viewModel: any;\n    /**\n     * @description\n     * Tracks the name bound to the directive. If a parent form exists, it\n     * uses this name as a key to retrieve this control's value.\n     */\n    name: string;\n    /**\n     * @description\n     * Tracks whether the control is disabled.\n     */\n    isDisabled: boolean;\n    /**\n     * @description\n     * Tracks the value bound to this directive.\n     */\n    model: any;\n    /**\n     * @description\n     * Tracks the configuration options for this `ngModel` instance.\n     *\n     * **name**: An alternative to setting the name attribute on the form control element. See\n     * the [example](api/forms/NgModel#using-ngmodel-on-a-standalone-control) for using `NgModel`\n     * as a standalone control.\n     *\n     * **standalone**: When set to true, the `ngModel` will not register itself with its parent form,\n     * and acts as if it's not in the form. Defaults to false. If no parent form exists, this option\n     * has no effect.\n     *\n     * **updateOn**: Defines the event upon which the form control value and validity update.\n     * Defaults to 'change'. Possible values: `'change'` | `'blur'` | `'submit'`.\n     *\n     */\n    options: {\n        name?: string;\n        standalone?: boolean;\n        updateOn?: FormHooks;\n    };\n    /**\n     * @description\n     * Event emitter for producing the `ngModelChange` event after\n     * the view model updates.\n     */\n    update: EventEmitter<any>;\n    constructor(parent: ControlContainer, validators: (Validator | ValidatorFn)[], asyncValidators: (AsyncValidator | AsyncValidatorFn)[], valueAccessors: ControlValueAccessor[]);\n    /** @nodoc */\n    ngOnChanges(changes: SimpleChanges): void;\n    /** @nodoc */\n    ngOnDestroy(): void;\n    /**\n     * @description\n     * Returns an array that represents the path from the top-level form to this control.\n     * Each index is the string name of the control on that level.\n     */\n    get path(): string[];\n    /**\n     * @description\n     * The top-level directive for this control if present, otherwise null.\n     */\n    get formDirective(): any;\n    /**\n     * @description\n     * Sets the new value for the view model and emits an `ngModelChange` event.\n     *\n     * @param newValue The new value emitted by `ngModelChange`.\n     */\n    viewToModelUpdate(newValue: any): void;\n    private _setUpControl;\n    private _setUpdateStrategy;\n    private _isStandalone;\n    private _setUpStandalone;\n    private _checkForErrors;\n    private _checkParentType;\n    private _checkName;\n    private _updateValue;\n    private _updateDisabled;\n}\n\n/**\n * @description\n * Creates and binds a `FormGroup` instance to a DOM element.\n *\n * This directive can only be used as a child of `NgForm` (within `<form>` tags).\n *\n * Use this directive to validate a sub-group of your form separately from the\n * rest of your form, or if some values in your domain model make more sense\n * to consume together in a nested object.\n *\n * Provide a name for the sub-group and it will become the key\n * for the sub-group in the form's full value. If you need direct access, export the directive into\n * a local template variable using `ngModelGroup` (ex: `#myGroup=\"ngModelGroup\"`).\n *\n * @usageNotes\n *\n * ### Consuming controls in a grouping\n *\n * The following example shows you how to combine controls together in a sub-group\n * of the form.\n *\n * {@example forms/ts/ngModelGroup/ng_model_group_example.ts region='Component'}\n *\n * @ngModule FormsModule\n * @publicApi\n */\nexport declare class NgModelGroup extends AbstractFormGroupDirective implements OnInit, OnDestroy {\n    /**\n     * @description\n     * Tracks the name of the `NgModelGroup` bound to the directive. The name corresponds\n     * to a key in the parent `NgForm`.\n     */\n    name: string;\n    constructor(parent: ControlContainer, validators: (Validator | ValidatorFn)[], asyncValidators: (AsyncValidator | AsyncValidatorFn)[]);\n}\n\n/**\n * @description\n * Marks `<option>` as dynamic, so Angular can be notified when options change.\n *\n * @see `SelectControlValueAccessor`\n *\n * @ngModule ReactiveFormsModule\n * @ngModule FormsModule\n * @publicApi\n */\nexport declare class NgSelectOption implements OnDestroy {\n    private _element;\n    private _renderer;\n    private _select;\n    /**\n     * @description\n     * ID of the option element\n     */\n    id: string;\n    constructor(_element: ElementRef, _renderer: Renderer2, _select: SelectControlValueAccessor);\n    /**\n     * @description\n     * Tracks the value bound to the option element. Unlike the value binding,\n     * ngValue supports binding to objects.\n     */\n    set ngValue(value: any);\n    /**\n     * @description\n     * Tracks simple string values bound to the option element.\n     * For objects, use the `ngValue` input binding.\n     */\n    set value(value: any);\n    /** @nodoc */\n    ngOnDestroy(): void;\n}\n\n/**\n * @description\n * The `ControlValueAccessor` for writing a number value and listening to number input changes.\n * The value accessor is used by the `FormControlDirective`, `FormControlName`, and `NgModel`\n * directives.\n *\n * @usageNotes\n *\n * ### Using a number input with a reactive form.\n *\n * The following example shows how to use a number input with a reactive form.\n *\n * ```ts\n * const totalCountControl = new FormControl();\n * ```\n *\n * ```\n * <input type=\"number\" [formControl]=\"totalCountControl\">\n * ```\n *\n * @ngModule ReactiveFormsModule\n * @ngModule FormsModule\n * @publicApi\n */\nexport declare class NumberValueAccessor extends ɵangular_packages_forms_forms_g implements ControlValueAccessor {\n    /**\n     * Sets the \"value\" property on the input element.\n     * @nodoc\n     */\n    writeValue(value: number): void;\n    /**\n     * Registers a function called when the control value changes.\n     * @nodoc\n     */\n    registerOnChange(fn: (_: number | null) => void): void;\n}\n\n/**\n * @description\n * A directive that adds regex pattern validation to controls marked with the\n * `pattern` attribute. The regex must match the entire control value.\n * The directive is provided with the `NG_VALIDATORS` multi-provider list.\n *\n * @see [Form Validation](guide/form-validation)\n *\n * @usageNotes\n *\n * ### Adding a pattern validator\n *\n * The following example shows how to add a pattern validator to an input attached to an\n * ngModel binding.\n *\n * ```html\n * <input name=\"firstName\" ngModel pattern=\"[a-zA-Z ]*\">\n * ```\n *\n * @ngModule ReactiveFormsModule\n * @ngModule FormsModule\n * @publicApi\n */\nexport declare class PatternValidator implements Validator, OnChanges {\n    private _validator;\n    private _onChange?;\n    /**\n     * @description\n     * Tracks changes to the pattern bound to this directive.\n     */\n    pattern: string | RegExp;\n    /** @nodoc */\n    ngOnChanges(changes: SimpleChanges): void;\n    /**\n     * Method that validates whether the value matches the pattern requirement.\n     * @nodoc\n     */\n    validate(control: AbstractControl): ValidationErrors | null;\n    /**\n     * Registers a callback function to call when the validator inputs change.\n     * @nodoc\n     */\n    registerOnValidatorChange(fn: () => void): void;\n    private _createValidator;\n}\n\n/**\n * @description\n * The `ControlValueAccessor` for writing radio control values and listening to radio control\n * changes. The value accessor is used by the `FormControlDirective`, `FormControlName`, and\n * `NgModel` directives.\n *\n * @usageNotes\n *\n * ### Using radio buttons with reactive form directives\n *\n * The follow example shows how to use radio buttons in a reactive form. When using radio buttons in\n * a reactive form, radio buttons in the same group should have the same `formControlName`.\n * Providing a `name` attribute is optional.\n *\n * {@example forms/ts/reactiveRadioButtons/reactive_radio_button_example.ts region='Reactive'}\n *\n * @ngModule ReactiveFormsModule\n * @ngModule FormsModule\n * @publicApi\n */\nexport declare class RadioControlValueAccessor extends ɵangular_packages_forms_forms_g implements ControlValueAccessor, OnDestroy, OnInit {\n    private _registry;\n    private _injector;\n    /**\n     * The registered callback function called when a change event occurs on the input element.\n     * Note: we declare `onChange` here (also used as host listener) as a function with no arguments\n     * to override the `onChange` function (which expects 1 argument) in the parent\n     * `BaseControlValueAccessor` class.\n     * @nodoc\n     */\n    onChange: () => void;\n    /**\n     * @description\n     * Tracks the name of the radio input element.\n     */\n    name: string;\n    /**\n     * @description\n     * Tracks the name of the `FormControl` bound to the directive. The name corresponds\n     * to a key in the parent `FormGroup` or `FormArray`.\n     */\n    formControlName: string;\n    /**\n     * @description\n     * Tracks the value of the radio input element\n     */\n    value: any;\n    constructor(renderer: Renderer2, elementRef: ElementRef, _registry: ɵangular_packages_forms_forms_r, _injector: Injector);\n    /** @nodoc */\n    ngOnInit(): void;\n    /** @nodoc */\n    ngOnDestroy(): void;\n    /**\n     * Sets the \"checked\" property value on the radio input element.\n     * @nodoc\n     */\n    writeValue(value: any): void;\n    /**\n     * Registers a function called when the control value changes.\n     * @nodoc\n     */\n    registerOnChange(fn: (_: any) => {}): void;\n    /**\n     * Sets the \"value\" on the radio input element and unchecks it.\n     *\n     * @param value\n     */\n    fireUncheck(value: any): void;\n    private _checkName;\n}\n\n/**\n * @description\n * The `ControlValueAccessor` for writing a range value and listening to range input changes.\n * The value accessor is used by the `FormControlDirective`, `FormControlName`, and  `NgModel`\n * directives.\n *\n * @usageNotes\n *\n * ### Using a range input with a reactive form\n *\n * The following example shows how to use a range input with a reactive form.\n *\n * ```ts\n * const ageControl = new FormControl();\n * ```\n *\n * ```\n * <input type=\"range\" [formControl]=\"ageControl\">\n * ```\n *\n * @ngModule ReactiveFormsModule\n * @ngModule FormsModule\n * @publicApi\n */\nexport declare class RangeValueAccessor extends ɵangular_packages_forms_forms_g implements ControlValueAccessor {\n    /**\n     * Sets the \"value\" property on the input element.\n     * @nodoc\n     */\n    writeValue(value: any): void;\n    /**\n     * Registers a function called when the control value changes.\n     * @nodoc\n     */\n    registerOnChange(fn: (_: number | null) => void): void;\n}\n\n/**\n * Exports the required infrastructure and directives for reactive forms,\n * making them available for import by NgModules that import this module.\n *\n * Providers associated with this module:\n * * `FormBuilder`\n * * `RadioControlRegistry`\n *\n * @see [Forms Overview](guide/forms-overview)\n * @see [Reactive Forms Guide](guide/reactive-forms)\n *\n * @publicApi\n */\nexport declare class ReactiveFormsModule {\n    /**\n     * @description\n     * Provides options for configuring the reactive forms module.\n     *\n     * @param opts An object of configuration options\n     * * `warnOnNgModelWithFormControl` Configures when to emit a warning when an `ngModel`\n     * binding is used with reactive form directives.\n     */\n    static withConfig(opts: {\n        /** @deprecated as of v6 */ warnOnNgModelWithFormControl: 'never' | 'once' | 'always';\n    }): ModuleWithProviders<ReactiveFormsModule>;\n}\n\n/**\n * @description\n * A directive that adds the `required` validator to any controls marked with the\n * `required` attribute. The directive is provided with the `NG_VALIDATORS` multi-provider list.\n *\n * @see [Form Validation](guide/form-validation)\n *\n * @usageNotes\n *\n * ### Adding a required validator using template-driven forms\n *\n * ```\n * <input name=\"fullName\" ngModel required>\n * ```\n *\n * @ngModule FormsModule\n * @ngModule ReactiveFormsModule\n * @publicApi\n */\nexport declare class RequiredValidator implements Validator {\n    private _required;\n    private _onChange?;\n    /**\n     * @description\n     * Tracks changes to the required attribute bound to this directive.\n     */\n    get required(): boolean | string;\n    set required(value: boolean | string);\n    /**\n     * Method that validates whether the control is empty.\n     * Returns the validation result if enabled, otherwise null.\n     * @nodoc\n     */\n    validate(control: AbstractControl): ValidationErrors | null;\n    /**\n     * Registers a callback function to call when the validator inputs change.\n     * @nodoc\n     */\n    registerOnValidatorChange(fn: () => void): void;\n}\n\n/**\n * @description\n * The `ControlValueAccessor` for writing select control values and listening to select control\n * changes. The value accessor is used by the `FormControlDirective`, `FormControlName`, and\n * `NgModel` directives.\n *\n * @usageNotes\n *\n * ### Using select controls in a reactive form\n *\n * The following examples show how to use a select control in a reactive form.\n *\n * {@example forms/ts/reactiveSelectControl/reactive_select_control_example.ts region='Component'}\n *\n * ### Using select controls in a template-driven form\n *\n * To use a select in a template-driven form, simply add an `ngModel` and a `name`\n * attribute to the main `<select>` tag.\n *\n * {@example forms/ts/selectControl/select_control_example.ts region='Component'}\n *\n * ### Customizing option selection\n *\n * Angular uses object identity to select option. It's possible for the identities of items\n * to change while the data does not. This can happen, for example, if the items are produced\n * from an RPC to the server, and that RPC is re-run. Even if the data hasn't changed, the\n * second response will produce objects with different identities.\n *\n * To customize the default option comparison algorithm, `<select>` supports `compareWith` input.\n * `compareWith` takes a **function** which has two arguments: `option1` and `option2`.\n * If `compareWith` is given, Angular selects option by the return value of the function.\n *\n * ```ts\n * const selectedCountriesControl = new FormControl();\n * ```\n *\n * ```\n * <select [compareWith]=\"compareFn\"  [formControl]=\"selectedCountriesControl\">\n *     <option *ngFor=\"let country of countries\" [ngValue]=\"country\">\n *         {{country.name}}\n *     </option>\n * </select>\n *\n * compareFn(c1: Country, c2: Country): boolean {\n *     return c1 && c2 ? c1.id === c2.id : c1 === c2;\n * }\n * ```\n *\n * **Note:** We listen to the 'change' event because 'input' events aren't fired\n * for selects in IE, see:\n * https://developer.mozilla.org/en-US/docs/Web/API/HTMLElement/input_event#browser_compatibility\n *\n * @ngModule ReactiveFormsModule\n * @ngModule FormsModule\n * @publicApi\n */\nexport declare class SelectControlValueAccessor extends ɵangular_packages_forms_forms_g implements ControlValueAccessor {\n    /** @nodoc */\n    value: any;\n    /**\n     * @description\n     * Tracks the option comparison algorithm for tracking identities when\n     * checking for changes.\n     */\n    set compareWith(fn: (o1: any, o2: any) => boolean);\n    private _compareWith;\n    /**\n     * Sets the \"value\" property on the input element. The \"selectedIndex\"\n     * property is also set if an ID is provided on the option element.\n     * @nodoc\n     */\n    writeValue(value: any): void;\n    /**\n     * Registers a function called when the control value changes.\n     * @nodoc\n     */\n    registerOnChange(fn: (value: any) => any): void;\n}\n\n/**\n * @description\n * The `ControlValueAccessor` for writing multi-select control values and listening to multi-select\n * control changes. The value accessor is used by the `FormControlDirective`, `FormControlName`, and\n * `NgModel` directives.\n *\n * @see `SelectControlValueAccessor`\n *\n * @usageNotes\n *\n * ### Using a multi-select control\n *\n * The follow example shows you how to use a multi-select control with a reactive form.\n *\n * ```ts\n * const countryControl = new FormControl();\n * ```\n *\n * ```\n * <select multiple name=\"countries\" [formControl]=\"countryControl\">\n *   <option *ngFor=\"let country of countries\" [ngValue]=\"country\">\n *     {{ country.name }}\n *   </option>\n * </select>\n * ```\n *\n * ### Customizing option selection\n *\n * To customize the default option comparison algorithm, `<select>` supports `compareWith` input.\n * See the `SelectControlValueAccessor` for usage.\n *\n * @ngModule ReactiveFormsModule\n * @ngModule FormsModule\n * @publicApi\n */\nexport declare class SelectMultipleControlValueAccessor extends ɵangular_packages_forms_forms_g implements ControlValueAccessor {\n    /**\n     * The current value.\n     * @nodoc\n     */\n    value: any;\n    /**\n     * @description\n     * Tracks the option comparison algorithm for tracking identities when\n     * checking for changes.\n     */\n    set compareWith(fn: (o1: any, o2: any) => boolean);\n    private _compareWith;\n    /**\n     * Sets the \"value\" property on one or of more of the select's options.\n     * @nodoc\n     */\n    writeValue(value: any): void;\n    /**\n     * Registers a function called when the control value changes\n     * and writes an array of the selected options.\n     * @nodoc\n     */\n    registerOnChange(fn: (value: any) => any): void;\n}\n\n/**\n * @description\n * Defines the map of errors returned from failed validation checks.\n *\n * @publicApi\n */\nexport declare type ValidationErrors = {\n    [key: string]: any;\n};\n\n/**\n * @description\n * An interface implemented by classes that perform synchronous validation.\n *\n * @usageNotes\n *\n * ### Provide a custom validator\n *\n * The following example implements the `Validator` interface to create a\n * validator directive with a custom error key.\n *\n * ```typescript\n * @Directive({\n *   selector: '[customValidator]',\n *   providers: [{provide: NG_VALIDATORS, useExisting: CustomValidatorDirective, multi: true}]\n * })\n * class CustomValidatorDirective implements Validator {\n *   validate(control: AbstractControl): ValidationErrors|null {\n *     return {'custom': true};\n *   }\n * }\n * ```\n *\n * @publicApi\n */\nexport declare interface Validator {\n    /**\n     * @description\n     * Method that performs synchronous validation against the provided control.\n     *\n     * @param control The control to validate against.\n     *\n     * @returns A map of validation errors if validation fails,\n     * otherwise null.\n     */\n    validate(control: AbstractControl): ValidationErrors | null;\n    /**\n     * @description\n     * Registers a callback function to call when the validator inputs change.\n     *\n     * @param fn The callback function\n     */\n    registerOnValidatorChange?(fn: () => void): void;\n}\n\n/**\n * @description\n * A function that receives a control and synchronously returns a map of\n * validation errors if present, otherwise null.\n *\n * @publicApi\n */\nexport declare interface ValidatorFn {\n    (control: AbstractControl): ValidationErrors | null;\n}\n\n/**\n * @description\n * Provides a set of built-in validators that can be used by form controls.\n *\n * A validator is a function that processes a `FormControl` or collection of\n * controls and returns an error map or null. A null map means that validation has passed.\n *\n * @see [Form Validation](/guide/form-validation)\n *\n * @publicApi\n */\nexport declare class Validators {\n    /**\n     * @description\n     * Validator that requires the control's value to be greater than or equal to the provided number.\n     *\n     * @usageNotes\n     *\n     * ### Validate against a minimum of 3\n     *\n     * ```typescript\n     * const control = new FormControl(2, Validators.min(3));\n     *\n     * console.log(control.errors); // {min: {min: 3, actual: 2}}\n     * ```\n     *\n     * @returns A validator function that returns an error map with the\n     * `min` property if the validation check fails, otherwise `null`.\n     *\n     * @see `updateValueAndValidity()`\n     *\n     */\n    static min(min: number): ValidatorFn;\n    /**\n     * @description\n     * Validator that requires the control's value to be less than or equal to the provided number.\n     *\n     * @usageNotes\n     *\n     * ### Validate against a maximum of 15\n     *\n     * ```typescript\n     * const control = new FormControl(16, Validators.max(15));\n     *\n     * console.log(control.errors); // {max: {max: 15, actual: 16}}\n     * ```\n     *\n     * @returns A validator function that returns an error map with the\n     * `max` property if the validation check fails, otherwise `null`.\n     *\n     * @see `updateValueAndValidity()`\n     *\n     */\n    static max(max: number): ValidatorFn;\n    /**\n     * @description\n     * Validator that requires the control have a non-empty value.\n     *\n     * @usageNotes\n     *\n     * ### Validate that the field is non-empty\n     *\n     * ```typescript\n     * const control = new FormControl('', Validators.required);\n     *\n     * console.log(control.errors); // {required: true}\n     * ```\n     *\n     * @returns An error map with the `required` property\n     * if the validation check fails, otherwise `null`.\n     *\n     * @see `updateValueAndValidity()`\n     *\n     */\n    static required(control: AbstractControl): ValidationErrors | null;\n    /**\n     * @description\n     * Validator that requires the control's value be true. This validator is commonly\n     * used for required checkboxes.\n     *\n     * @usageNotes\n     *\n     * ### Validate that the field value is true\n     *\n     * ```typescript\n     * const control = new FormControl('', Validators.requiredTrue);\n     *\n     * console.log(control.errors); // {required: true}\n     * ```\n     *\n     * @returns An error map that contains the `required` property\n     * set to `true` if the validation check fails, otherwise `null`.\n     *\n     * @see `updateValueAndValidity()`\n     *\n     */\n    static requiredTrue(control: AbstractControl): ValidationErrors | null;\n    /**\n     * @description\n     * Validator that requires the control's value pass an email validation test.\n     *\n     * Tests the value using a [regular\n     * expression](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Regular_Expressions)\n     * pattern suitable for common usecases. The pattern is based on the definition of a valid email\n     * address in the [WHATWG HTML\n     * specification](https://html.spec.whatwg.org/multipage/input.html#valid-e-mail-address) with\n     * some enhancements to incorporate more RFC rules (such as rules related to domain names and the\n     * lengths of different parts of the address).\n     *\n     * The differences from the WHATWG version include:\n     * - Disallow `local-part` (the part before the `@` symbol) to begin or end with a period (`.`).\n     * - Disallow `local-part` to be longer than 64 characters.\n     * - Disallow the whole address to be longer than 254 characters.\n     *\n     * If this pattern does not satisfy your business needs, you can use `Validators.pattern()` to\n     * validate the value against a different pattern.\n     *\n     * @usageNotes\n     *\n     * ### Validate that the field matches a valid email pattern\n     *\n     * ```typescript\n     * const control = new FormControl('bad@', Validators.email);\n     *\n     * console.log(control.errors); // {email: true}\n     * ```\n     *\n     * @returns An error map with the `email` property\n     * if the validation check fails, otherwise `null`.\n     *\n     * @see `updateValueAndValidity()`\n     *\n     */\n    static email(control: AbstractControl): ValidationErrors | null;\n    /**\n     * @description\n     * Validator that requires the length of the control's value to be greater than or equal\n     * to the provided minimum length. This validator is also provided by default if you use the\n     * the HTML5 `minlength` attribute. Note that the `minLength` validator is intended to be used\n     * only for types that have a numeric `length` property, such as strings or arrays. The\n     * `minLength` validator logic is also not invoked for values when their `length` property is 0\n     * (for example in case of an empty string or an empty array), to support optional controls. You\n     * can use the standard `required` validator if empty values should not be considered valid.\n     *\n     * @usageNotes\n     *\n     * ### Validate that the field has a minimum of 3 characters\n     *\n     * ```typescript\n     * const control = new FormControl('ng', Validators.minLength(3));\n     *\n     * console.log(control.errors); // {minlength: {requiredLength: 3, actualLength: 2}}\n     * ```\n     *\n     * ```html\n     * <input minlength=\"5\">\n     * ```\n     *\n     * @returns A validator function that returns an error map with the\n     * `minlength` property if the validation check fails, otherwise `null`.\n     *\n     * @see `updateValueAndValidity()`\n     *\n     */\n    static minLength(minLength: number): ValidatorFn;\n    /**\n     * @description\n     * Validator that requires the length of the control's value to be less than or equal\n     * to the provided maximum length. This validator is also provided by default if you use the\n     * the HTML5 `maxlength` attribute. Note that the `maxLength` validator is intended to be used\n     * only for types that have a numeric `length` property, such as strings or arrays.\n     *\n     * @usageNotes\n     *\n     * ### Validate that the field has maximum of 5 characters\n     *\n     * ```typescript\n     * const control = new FormControl('Angular', Validators.maxLength(5));\n     *\n     * console.log(control.errors); // {maxlength: {requiredLength: 5, actualLength: 7}}\n     * ```\n     *\n     * ```html\n     * <input maxlength=\"5\">\n     * ```\n     *\n     * @returns A validator function that returns an error map with the\n     * `maxlength` property if the validation check fails, otherwise `null`.\n     *\n     * @see `updateValueAndValidity()`\n     *\n     */\n    static maxLength(maxLength: number): ValidatorFn;\n    /**\n     * @description\n     * Validator that requires the control's value to match a regex pattern. This validator is also\n     * provided by default if you use the HTML5 `pattern` attribute.\n     *\n     * @usageNotes\n     *\n     * ### Validate that the field only contains letters or spaces\n     *\n     * ```typescript\n     * const control = new FormControl('1', Validators.pattern('[a-zA-Z ]*'));\n     *\n     * console.log(control.errors); // {pattern: {requiredPattern: '^[a-zA-Z ]*$', actualValue: '1'}}\n     * ```\n     *\n     * ```html\n     * <input pattern=\"[a-zA-Z ]*\">\n     * ```\n     *\n     * ### Pattern matching with the global or sticky flag\n     *\n     * `RegExp` objects created with the `g` or `y` flags that are passed into `Validators.pattern`\n     * can produce different results on the same input when validations are run consecutively. This is\n     * due to how the behavior of `RegExp.prototype.test` is\n     * specified in [ECMA-262](https://tc39.es/ecma262/#sec-regexpbuiltinexec)\n     * (`RegExp` preserves the index of the last match when the global or sticky flag is used).\n     * Due to this behavior, it is recommended that when using\n     * `Validators.pattern` you **do not** pass in a `RegExp` object with either the global or sticky\n     * flag enabled.\n     *\n     * ```typescript\n     * // Not recommended (since the `g` flag is used)\n     * const controlOne = new FormControl('1', Validators.pattern(/foo/g));\n     *\n     * // Good\n     * const controlTwo = new FormControl('1', Validators.pattern(/foo/));\n     * ```\n     *\n     * @param pattern A regular expression to be used as is to test the values, or a string.\n     * If a string is passed, the `^` character is prepended and the `$` character is\n     * appended to the provided string (if not already present), and the resulting regular\n     * expression is used to test the values.\n     *\n     * @returns A validator function that returns an error map with the\n     * `pattern` property if the validation check fails, otherwise `null`.\n     *\n     * @see `updateValueAndValidity()`\n     *\n     */\n    static pattern(pattern: string | RegExp): ValidatorFn;\n    /**\n     * @description\n     * Validator that performs no operation.\n     *\n     * @see `updateValueAndValidity()`\n     *\n     */\n    static nullValidator(control: AbstractControl): ValidationErrors | null;\n    /**\n     * @description\n     * Compose multiple validators into a single function that returns the union\n     * of the individual error maps for the provided control.\n     *\n     * @returns A validator function that returns an error map with the\n     * merged error maps of the validators if the validation check fails, otherwise `null`.\n     *\n     * @see `updateValueAndValidity()`\n     *\n     */\n    static compose(validators: null): null;\n    static compose(validators: (ValidatorFn | null | undefined)[]): ValidatorFn | null;\n    /**\n     * @description\n     * Compose multiple async validators into a single function that returns the union\n     * of the individual error objects for the provided control.\n     *\n     * @returns A validator function that returns an error map with the\n     * merged error objects of the async validators if the validation check fails, otherwise `null`.\n     *\n     * @see `updateValueAndValidity()`\n     *\n     */\n    static composeAsync(validators: (AsyncValidatorFn | null)[]): AsyncValidatorFn | null;\n}\n\n/**\n * @publicApi\n */\nexport declare const VERSION: Version;\n\nexport declare const ɵangular_packages_forms_forms_a: Type<any>[];\n\nexport declare const ɵangular_packages_forms_forms_b: Type<any>[];\n\nexport declare const ɵangular_packages_forms_forms_ba: StaticProvider;\n\n/**\n * @description\n * Provider which adds `MaxValidator` to the `NG_VALIDATORS` multi-provider list.\n */\nexport declare const ɵangular_packages_forms_forms_bd: StaticProvider;\n\n/**\n * @description\n * Provider which adds `MinValidator` to the `NG_VALIDATORS` multi-provider list.\n */\nexport declare const ɵangular_packages_forms_forms_be: StaticProvider;\n\n/**\n * @description\n * Provider which adds `RequiredValidator` to the `NG_VALIDATORS` multi-provider list.\n */\nexport declare const ɵangular_packages_forms_forms_bf: StaticProvider;\n\n/**\n * @description\n * Provider which adds `CheckboxRequiredValidator` to the `NG_VALIDATORS` multi-provider list.\n */\nexport declare const ɵangular_packages_forms_forms_bg: StaticProvider;\n\n/**\n * @description\n * Provider which adds `EmailValidator` to the `NG_VALIDATORS` multi-provider list.\n */\nexport declare const ɵangular_packages_forms_forms_bh: any;\n\n/**\n * @description\n * Provider which adds `MinLengthValidator` to the `NG_VALIDATORS` multi-provider list.\n */\nexport declare const ɵangular_packages_forms_forms_bi: any;\n\n/**\n * @description\n * Provider which adds `MaxLengthValidator` to the `NG_VALIDATORS` multi-provider list.\n */\nexport declare const ɵangular_packages_forms_forms_bj: any;\n\n/**\n * @description\n * Provider which adds `PatternValidator` to the `NG_VALIDATORS` multi-provider list.\n */\nexport declare const ɵangular_packages_forms_forms_bk: any;\n\n/**\n * Validator that requires the control's value to be greater than or equal to the provided number.\n * See `Validators.min` for additional information.\n */\nexport declare function ɵangular_packages_forms_forms_bl(min: number): ValidatorFn;\n\n/**\n * Validator that requires the control's value to be less than or equal to the provided number.\n * See `Validators.max` for additional information.\n */\nexport declare function ɵangular_packages_forms_forms_bm(max: number): ValidatorFn;\n\n/**\n * Validator that requires the control have a non-empty value.\n * See `Validators.required` for additional information.\n */\nexport declare function ɵangular_packages_forms_forms_bn(control: AbstractControl): ValidationErrors | null;\n\n/**\n * Validator that requires the control's value be true. This validator is commonly\n * used for required checkboxes.\n * See `Validators.requiredTrue` for additional information.\n */\nexport declare function ɵangular_packages_forms_forms_bo(control: AbstractControl): ValidationErrors | null;\n\n/**\n * Validator that requires the control's value pass an email validation test.\n * See `Validators.email` for additional information.\n */\nexport declare function ɵangular_packages_forms_forms_bp(control: AbstractControl): ValidationErrors | null;\n\n/**\n * Validator that requires the length of the control's value to be greater than or equal\n * to the provided minimum length. See `Validators.minLength` for additional information.\n */\nexport declare function ɵangular_packages_forms_forms_bq(minLength: number): ValidatorFn;\n\n/**\n * Validator that requires the length of the control's value to be less than or equal\n * to the provided maximum length. See `Validators.maxLength` for additional information.\n */\nexport declare function ɵangular_packages_forms_forms_br(maxLength: number): ValidatorFn;\n\n/**\n * Validator that requires the control's value to match a regex pattern.\n * See `Validators.pattern` for additional information.\n */\nexport declare function ɵangular_packages_forms_forms_bs(pattern: string | RegExp): ValidatorFn;\n\n/**\n * Function that has `ValidatorFn` shape, but performs no operation.\n */\nexport declare function ɵangular_packages_forms_forms_bt(control: AbstractControl): ValidationErrors | null;\n\nexport declare const ɵangular_packages_forms_forms_c: Type<any>[];\n\nexport declare const ɵangular_packages_forms_forms_e: any;\n\n/**\n * Base class for all ControlValueAccessor classes defined in Forms package.\n * Contains common logic and utility functions.\n *\n * Note: this is an *internal-only* class and should not be extended or used directly in\n * applications code.\n */\nexport declare class ɵangular_packages_forms_forms_f {\n    private _renderer;\n    private _elementRef;\n    /**\n     * The registered callback function called when a change or input event occurs on the input\n     * element.\n     * @nodoc\n     */\n    onChange: (_: any) => void;\n    /**\n     * The registered callback function called when a blur event occurs on the input element.\n     * @nodoc\n     */\n    onTouched: () => void;\n    constructor(_renderer: Renderer2, _elementRef: ElementRef);\n    /**\n     * Helper method that sets a property on a target element using the current Renderer\n     * implementation.\n     * @nodoc\n     */\n    protected setProperty(key: string, value: any): void;\n    /**\n     * Registers a function called when the control is touched.\n     * @nodoc\n     */\n    registerOnTouched(fn: () => void): void;\n    /**\n     * Registers a function called when the control value changes.\n     * @nodoc\n     */\n    registerOnChange(fn: (_: any) => {}): void;\n    /**\n     * Sets the \"disabled\" property on the range input element.\n     * @nodoc\n     */\n    setDisabledState(isDisabled: boolean): void;\n}\n\n/**\n * Base class for all built-in ControlValueAccessor classes (except DefaultValueAccessor, which is\n * used in case no other CVAs can be found). We use this class to distinguish between default CVA,\n * built-in CVAs and custom CVAs, so that Forms logic can recognize built-in CVAs and treat custom\n * ones with higher priority (when both built-in and custom CVAs are present).\n *\n * Note: this is an *internal-only* class and should not be extended or used directly in\n * applications code.\n */\nexport declare class ɵangular_packages_forms_forms_g extends ɵangular_packages_forms_forms_f {\n}\n\nexport declare const ɵangular_packages_forms_forms_h: any;\n\nexport declare class ɵangular_packages_forms_forms_i {\n    private _cd;\n    constructor(cd: AbstractControlDirective | null);\n    is(status: AnyControlStatus): boolean;\n}\n\nexport declare const ɵangular_packages_forms_forms_j: {\n    '[class.ng-untouched]': string;\n    '[class.ng-touched]': string;\n    '[class.ng-pristine]': string;\n    '[class.ng-dirty]': string;\n    '[class.ng-valid]': string;\n    '[class.ng-invalid]': string;\n    '[class.ng-pending]': string;\n};\n\nexport declare const ɵangular_packages_forms_forms_k: {\n    '[class.ng-untouched]': string;\n    '[class.ng-touched]': string;\n    '[class.ng-pristine]': string;\n    '[class.ng-dirty]': string;\n    '[class.ng-valid]': string;\n    '[class.ng-invalid]': string;\n    '[class.ng-pending]': string;\n    '[class.ng-submitted]': string;\n};\n\nexport declare const ɵangular_packages_forms_forms_l: any;\n\nexport declare const ɵangular_packages_forms_forms_m: any;\n\nexport declare const ɵangular_packages_forms_forms_n: any;\n\nexport declare const ɵangular_packages_forms_forms_o: any;\n\nexport declare const ɵangular_packages_forms_forms_p: any;\n\n/**\n * Internal-only NgModule that works as a host for the `RadioControlRegistry` tree-shakable\n * provider. Note: the `InternalFormsSharedModule` can not be used here directly, since it's\n * declared *after* the `RadioControlRegistry` class and the `providedIn` doesn't support\n * `forwardRef` logic.\n */\nexport declare class ɵangular_packages_forms_forms_q {\n}\n\n/**\n * @description\n * Class used by Angular to track radio buttons. For internal use only.\n */\nexport declare class ɵangular_packages_forms_forms_r {\n    private _accessors;\n    /**\n     * @description\n     * Adds a control to the internal registry. For internal use only.\n     */\n    add(control: NgControl, accessor: RadioControlValueAccessor): void;\n    /**\n     * @description\n     * Removes a control from the internal registry. For internal use only.\n     */\n    remove(accessor: RadioControlValueAccessor): void;\n    /**\n     * @description\n     * Selects a radio button. For internal use only.\n     */\n    select(accessor: RadioControlValueAccessor): void;\n    private _isSameGroup;\n}\n\nexport declare const ɵangular_packages_forms_forms_s: StaticProvider;\n\n/**\n * Token to provide to turn off the ngModel warning on formControl and formControlName.\n */\nexport declare const ɵangular_packages_forms_forms_t: InjectionToken<unknown>;\n\nexport declare const ɵangular_packages_forms_forms_u: any;\n\nexport declare const ɵangular_packages_forms_forms_v: any;\n\nexport declare const ɵangular_packages_forms_forms_w: any;\n\nexport declare const ɵangular_packages_forms_forms_x: any;\n\nexport declare const ɵangular_packages_forms_forms_y: any;\n\nexport declare const ɵangular_packages_forms_forms_z: StaticProvider;\n\n/**\n * Internal module used for sharing directives between FormsModule and ReactiveFormsModule\n */\ndeclare class ɵInternalFormsSharedModule {\n}\nexport { ɵInternalFormsSharedModule }\nexport { ɵInternalFormsSharedModule as ɵangular_packages_forms_forms_d }\n\n\n/**\n * @description\n *\n * Adds `novalidate` attribute to all forms by default.\n *\n * `novalidate` is used to disable browser's native form validation.\n *\n * If you want to use native validation with Angular forms, just add `ngNativeValidate` attribute:\n *\n * ```\n * <form ngNativeValidate></form>\n * ```\n *\n * @publicApi\n * @ngModule ReactiveFormsModule\n * @ngModule FormsModule\n */\ndeclare class ɵNgNoValidate {\n}\nexport { ɵNgNoValidate }\nexport { ɵNgNoValidate as ɵangular_packages_forms_forms_bc }\n\n/**\n * @description\n * Marks `<option>` as dynamic, so Angular can be notified when options change.\n *\n * @see `SelectMultipleControlValueAccessor`\n *\n * @ngModule ReactiveFormsModule\n * @ngModule FormsModule\n * @publicApi\n */\ndeclare class ɵNgSelectMultipleOption implements OnDestroy {\n    private _element;\n    private _renderer;\n    private _select;\n    id: string;\n    constructor(_element: ElementRef, _renderer: Renderer2, _select: SelectMultipleControlValueAccessor);\n    /**\n     * @description\n     * Tracks the value bound to the option element. Unlike the value binding,\n     * ngValue supports binding to objects.\n     */\n    set ngValue(value: any);\n    /**\n     * @description\n     * Tracks simple string values bound to the option element.\n     * For objects, use the `ngValue` input binding.\n     */\n    set value(value: any);\n    /** @nodoc */\n    ngOnDestroy(): void;\n}\nexport { ɵNgSelectMultipleOption }\nexport { ɵNgSelectMultipleOption as ɵangular_packages_forms_forms_bb }\n\nexport { }\n"]}
>>>>>>> c5d4ca514d61d844d3a657bc982015321bfa338d
